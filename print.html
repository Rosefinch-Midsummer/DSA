<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>资料结构与演算法</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="弁言.html"><strong aria-hidden="true">1.</strong> 弁言</a></li><li class="chapter-item expanded "><a href="数据结构与算法概论.html"><strong aria-hidden="true">2.</strong> 数据结构与算法概论</a></li><li class="chapter-item expanded "><a href="MOOC-PTA复杂度题目.html"><strong aria-hidden="true">3.</strong> MOOC-PTA复杂度题目</a></li><li class="chapter-item expanded "><a href="线性结构.html"><strong aria-hidden="true">4.</strong> 线性结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="线性表.html"><strong aria-hidden="true">4.1.</strong> 线性表</a></li><li class="chapter-item expanded "><a href="栈.html"><strong aria-hidden="true">4.2.</strong> 栈</a></li><li class="chapter-item expanded "><a href="队列.html"><strong aria-hidden="true">4.3.</strong> 队列</a></li></ol></li><li class="chapter-item expanded "><a href="MOOC-PTA线性结构题目.html"><strong aria-hidden="true">5.</strong> MOOC-PTA线性结构题目</a></li><li class="chapter-item expanded "><a href="树.html"><strong aria-hidden="true">6.</strong> 树</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="二叉树.html"><strong aria-hidden="true">6.1.</strong> 二叉树</a></li><li class="chapter-item expanded "><a href="二叉搜索树.html"><strong aria-hidden="true">6.2.</strong> 二叉搜索树</a></li><li class="chapter-item expanded "><a href="二叉平衡树.html"><strong aria-hidden="true">6.3.</strong> 二叉平衡树</a></li><li class="chapter-item expanded "><a href="哈夫曼树.html"><strong aria-hidden="true">6.4.</strong> 哈夫曼树</a></li><li class="chapter-item expanded "><a href="并查集.html"><strong aria-hidden="true">6.5.</strong> 并查集</a></li></ol></li><li class="chapter-item expanded "><a href="MOOC-PTA树题目.html"><strong aria-hidden="true">7.</strong> MOOC-PTA树题目</a></li><li class="chapter-item expanded "><a href="图.html"><strong aria-hidden="true">8.</strong> 图</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="图的存储.html"><strong aria-hidden="true">8.1.</strong> 图的存储</a></li><li class="chapter-item expanded "><a href="图的遍历.html"><strong aria-hidden="true">8.2.</strong> 图的遍历</a></li><li class="chapter-item expanded "><a href="最短路径算法.html"><strong aria-hidden="true">8.3.</strong> 最短路径算法</a></li><li class="chapter-item expanded "><a href="最小生成树算法.html"><strong aria-hidden="true">8.4.</strong> 最小生成树算法</a></li></ol></li><li class="chapter-item expanded "><a href="MOOC-PTA图题目.html"><strong aria-hidden="true">9.</strong> MOOC-PTA图题目</a></li><li class="chapter-item expanded "><a href="排序算法.html"><strong aria-hidden="true">10.</strong> 排序算法</a></li><li class="chapter-item expanded "><a href="MOOC-PTA排序题目.html"><strong aria-hidden="true">11.</strong> MOOC-PTA排序题目</a></li><li class="chapter-item expanded "><a href="查找算法.html"><strong aria-hidden="true">12.</strong> 查找算法</a></li><li class="chapter-item expanded "><a href="MOOC-PTA查找题目.html"><strong aria-hidden="true">13.</strong> MOOC-PTA查找题目</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">资料结构与演算法</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="弁言"><a class="header" href="#弁言">弁言</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="数据结构与算法概论"><a class="header" href="#数据结构与算法概论">数据结构与算法概论</a></h1>
<ul>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA">数据结构绪论</a>
<ul>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E5%92%8C%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84">逻辑结构和物理结构</a>
<ul>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84">逻辑结构</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84">物理结构</a></li>
</ul>
</li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a></li>
</ul>
</li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E7%AE%97%E6%B3%95%E7%BB%AA%E8%AE%BA">算法绪论</a>
<ul>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7">算法特性</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%A6%81%E6%B1%82">算法设计的要求</a>
<ul>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E5%8F%AF%E8%AF%BB%E6%80%A7">可读性</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E5%81%A5%E5%A3%AE%E6%80%A7">健壮性</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E6%97%B6%E9%97%B4%E6%95%88%E7%8E%87%E9%AB%98%E5%92%8C%E5%AD%98%E5%82%A8%E9%87%8F%E4%BD%8E">时间效率高和存储量低</a></li>
</ul>
</li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E7%9A%84%E5%BA%A6%E9%87%8F%E6%96%B9%E6%B3%95">算法效率的度量方法</a>
<ul>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E4%BA%8B%E5%90%8E%E7%BB%9F%E8%AE%A1%E6%96%B9%E6%B3%95">事后统计方法</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E4%BA%8B%E5%89%8D%E5%88%86%E6%9E%90%E4%BC%B0%E7%AE%97%E6%96%B9%E6%B3%95">事前分析估算方法</a></li>
</ul>
</li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E5%87%BD%E6%95%B0%E7%9A%84%E6%B8%90%E8%BF%91%E5%A2%9E%E9%95%BF">函数的渐近增长</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">算法时间复杂度</a>
<ul>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AE%9A%E4%B9%89">算法时间复杂度定义</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E6%8E%A8%E5%AF%BC%E5%A4%A7o%E9%98%B6%E6%96%B9%E6%B3%95">推导大O阶方法</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E5%B8%B8%E6%95%B0%E9%98%B6o1">常数阶O(1)</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E7%BA%BF%E6%80%A7%E9%98%B6on">线性阶O(n)</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E5%AF%B9%E6%95%B0%E9%98%B6ologn">对数阶O(logn)</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E5%B9%B3%E6%96%B9%E9%98%B6on2">平方阶O(n^2)</a></li>
</ul>
</li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">常见的时间复杂度</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E6%9C%80%E5%9D%8F%E6%83%85%E5%86%B5%E5%92%8C%E5%B9%B3%E5%9D%87%E6%83%85%E5%86%B5">最坏情况和平均情况</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E7%AE%97%E6%B3%95%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">算法空间复杂度</a></li>
</ul>
</li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E8%81%94%E7%B3%BB">数据结构和算法的联系</a></li>
</ul>
<h1 id="数据结构绪论"><a class="header" href="#数据结构绪论">数据结构绪论</a></h1>
<p>数据结构是相互之间存在一种或多种特定关系的数据元素的集合。</p>
<h2 id="逻辑结构和物理结构"><a class="header" href="#逻辑结构和物理结构">逻辑结构和物理结构</a></h2>
<p>按照视点的不同，我们把数据结构分为逻辑结构和物理结构。</p>
<h3 id="逻辑结构"><a class="header" href="#逻辑结构">逻辑结构</a></h3>
<p>逻辑结构是指数据对象中数据元素之间的相互关系。其实这也是我们今后最需要关心的问题。逻辑结构分为以下四种。</p>
<p>（1）集合结构</p>
<p>集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。数据结构中的集合关系就类似于数学中的集合。</p>
<p>（2）线性结构</p>
<p>线性结构中的数据元素之间是一对一的关系。</p>
<p>（3）树形结构</p>
<p>树型结构中的数据元素之间存在一种一对多的层次关系。</p>
<p>（4）图形结构</p>
<p>图形结构的数据元素是多对多的关系。</p>
<p>从之前的例子也可以看出，逻辑结构是针对具体问题的，是为了解决某个问题，在对问题理解的基础上，选择一个合适的数据结构表示数据元素之间的逻辑关系。</p>
<h3 id="物理结构"><a class="header" href="#物理结构">物理结构</a></h3>
<p>物理结构（存储结构）是指数据的逻辑结构在计算机中的存储形式。</p>
<p>数据的存储结构应正确反映数据元素之间的逻辑关系，这才是最为关键的，如何存储数据元素之间的逻辑关系，是实现物理结构的重点和难点。</p>
<p>数据元素的存储结构形式有两种：顺序存储和链式存储。</p>
<p>（1）顺序存储结构</p>
<p><strong>顺序存储结构是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。</strong> 典型的顺序存储结构就是数组。</p>
<p>（2）链式存储结构</p>
<p><strong>链式存储结构是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置。</strong></p>
<p>显然链式存储就灵活多了，数据存在哪里不重要，只要有一个指针存放了相应的地址就能找到它了。</p>
<h2 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h2>
<p>数据类型是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。</p>
<p>在C语言中，按照取值的不同，数据类型可以分为两类：</p>
<ul>
<li>原子类型：不可再分解的类型，包括整型、实型、字符型等。</li>
<li>结构类型：由若干个类型组合而成，是可以再分解的。例如整型数组是由若干整型数据组成的。</li>
</ul>
<p><strong>抽象是指抽取出事物具有的普遍性的本质</strong>。它是抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节，只保留实现目标所必需的信息。 </p>
<p>抽象数据类型（Abstract Data Type，ADT）：一个数学模型及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309291221942.png" alt="" /></p>
<p>实际上，<strong>抽象数据类型体现了程序设计中问题分解、抽象和信息隐藏的特性</strong>。抽象数据类型把实际生活中的问题分解为多个小规模且容易处理的问题，然后建立一个计算机能处理的数据类型，并把每个功能模块的实现细节作为一个独立的单元，从而使具体实现过程隐藏起来。</p>
<p>为了便于在之后的讲解中对抽象数据类型进行规范的描述，我们给出了抽象数据类型的标准格式：</p>
<pre><code>ADT 抽象数据类型名
Data
	数据元素之间逻辑关系的定义
Operation
	操作1
		初始条件
		操作结构描述
	操作2
		...
	操作3
		...
endADT
</code></pre>
<h1 id="算法绪论"><a class="header" href="#算法绪论">算法绪论</a></h1>
<p>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p>
<h2 id="算法特性"><a class="header" href="#算法特性">算法特性</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309291225238.png" alt="" /></p>
<p>算法具有五个基本特性：输入、输出、有穷性、确定性和可行性</p>
<p>算法具有零个或多个输入，有一个或多个输出。</p>
<p>有穷性只算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且一个步骤在可接受的时间内完成。</p>
<p>确定性：算法的每一步骤都要具有确定的含义，不会出现二义性。算法在一定条件下，只有一条执行路径，相同的输入只能有唯一的输出结果。算法的每个步骤被精确定义而无歧义。</p>
<p>可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。可行性意味着算法可以转换为程序上机运行，并得到正确的结果。</p>
<h2 id="算法设计的要求"><a class="header" href="#算法设计的要求">算法设计的要求</a></h2>
<h3 id="正确性"><a class="header" href="#正确性">正确性</a></h3>
<p>算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性，能正确反映问题得需求，能够得到问题的正确答案。</p>
<p>但是算法得”正确“通常在用法上有很大的差别，大体上分为以下四个层次。</p>
<p>（1）算法程序没有语法错误。</p>
<p>（2）算法程序对于合法的输入数据能够产生满足要求的输出结果。 </p>
<p>（3）算法程序对于非法的输入数据能够得出满足规格说明的结果。</p>
<p>（4）算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。</p>
<p>一般情况下，我们把层次（3）作为一个算法是否正确的标准。</p>
<h3 id="可读性"><a class="header" href="#可读性">可读性</a></h3>
<p>算法设计的另一目的是为了便于阅读、理解和交流。</p>
<h3 id="健壮性"><a class="header" href="#健壮性">健壮性</a></h3>
<p>当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。</p>
<h3 id="时间效率高和存储量低"><a class="header" href="#时间效率高和存储量低">时间效率高和存储量低</a></h3>
<p>设计算法应该尽量满足时间效率高和存储量低的需求。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309291227220.png" alt="" /></p>
<h2 id="算法效率的度量方法"><a class="header" href="#算法效率的度量方法">算法效率的度量方法</a></h2>
<h3 id="事后统计方法"><a class="header" href="#事后统计方法">事后统计方法</a></h3>
<p>这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编写的程序的运行时间进行比较，从而确定算法效率的高低。</p>
<p>这种方法有多种缺陷，我们考虑不予采纳。</p>
<h3 id="事前分析估算方法"><a class="header" href="#事前分析估算方法">事前分析估算方法</a></h3>
<p>事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行统计。</p>
<p>一个程序的运行时间，依赖于算法的好坏和问题的输入规模。所谓问题输入规模是指输入量的多少。</p>
<p>最终，在分析程序的运行时间时，最重要的是把程序看成是独立于程序设计语言的算法或一系列步骤。</p>
<h2 id="函数的渐近增长"><a class="header" href="#函数的渐近增长">函数的渐近增长</a></h2>
<p>函数的渐近增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n&gt;N,f(n)总是比g(n)大，那么我们说f(n)的增长渐近快于g(n)。</p>
<p>判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309291235134.png" alt="" /></p>
<h2 id="算法时间复杂度"><a class="header" href="#算法时间复杂度">算法时间复杂度</a></h2>
<h3 id="算法时间复杂度定义"><a class="header" href="#算法时间复杂度定义">算法时间复杂度定义</a></h3>
<p>在进行算法分析时，语句总的执行次数T(n)是关于问题规模的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间度量，记作T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的函数。</p>
<p>这样用大写O()来体现算法时间复杂度的记法，我们称之为大O记法。</p>
<p>一般情况下，随着n的增大，T(n)增长最慢的算法为最优算法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309291241513.png" alt="" /></p>
<pre><code class="language-c">if ( A &gt; B ) {
    for ( i=0; i&lt;N; i++ )
        for ( j=N*N; j&gt;i; j-- )
            A += B;
}
else {
    for ( i=0; i&lt;N*2; i++ )
        for ( j=N*2; j&gt;i; j-- )
            A += B;
}
</code></pre>
<p>这段代码时间复杂度为<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<h3 id="推导大o阶方法"><a class="header" href="#推导大o阶方法">推导大O阶方法</a></h3>
<p>（1）用常数1取代运行时间中的所有加法常数。</p>
<p>（2）在修改后的运行次数函数中，只保留最高阶项。</p>
<p>（3）如果最高阶项存在且其系数不是1，则去除与这个项相乘的系数。得到的结果就是大O阶。</p>
<h3 id="常数阶o1"><a class="header" href="#常数阶o1">常数阶O(1)</a></h3>
<p>不管算法运行次数常数是多少，我们都记作O(1)，而不能是O(3)、O(12)等其他任何数字。</p>
<h3 id="线性阶on"><a class="header" href="#线性阶on">线性阶O(n)</a></h3>
<p>要分析算法的复杂度，关键就是要分析循环结构的运行情况。</p>
<pre><code class="language-c">int i,sum;
sum=0;
for(i=0;i&lt;n;i++)
	sum+=i;
</code></pre>
<h3 id="对数阶ologn"><a class="header" href="#对数阶ologn">对数阶O(logn)</a></h3>
<pre><code class="language-c">int count=1;
while(count&lt;n)
	count=count*2;
</code></pre>
<h3 id="平方阶on2"><a class="header" href="#平方阶on2">平方阶O(n^2)</a></h3>
<p>循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数。</p>
<p>下面这个程序的时间复杂度为<code>O(m*n)</code></p>
<pre><code class="language-c">int i,j;
for(i=0;i&lt;m;i++)
{
	for(j=0;j&lt;n;j++)
	{
		/*时间复杂度为O(1)的程序步骤序列*/
	}
}
</code></pre>
<p>下面这个程序的时间复杂度为<code>O(n^2)</code></p>
<pre><code class="language-c">int i,j;
for(i=0;i&lt;n;i++)
{
	for(j=i;j&lt;n;j++)
	{
		/*时间复杂度为O(1)的程序步骤序列*/
	}
}
</code></pre>
<h2 id="常见的时间复杂度"><a class="header" href="#常见的时间复杂度">常见的时间复杂度</a></h2>
<p>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309291237243.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309291237024.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309291240341.png" alt="" /></p>
<h2 id="最坏情况和平均情况"><a class="header" href="#最坏情况和平均情况">最坏情况和平均情况</a></h2>
<p>平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。也就是说，我们运行一段程序代码时，是希望看到平均运行时间的。可现实中，平均运行时间很难通过分析得到，一般都是通过一定数量的实验数据后估算出来的。</p>
<p>对于算法的分析，一种方法是计算所有情况的平均值，这种时间复杂度的计算方法被称为平均时间复杂度。另一种方法是计算最坏情况下的时间复杂度，这种方法被称为最坏时间复杂度。一般在没有特殊说明的情况下，都是指最坏时间复杂度。</p>
<h2 id="算法空间复杂度"><a class="header" href="#算法空间复杂度">算法空间复杂度</a></h2>
<p>算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n)=O(f(n))，其中n为问题的规模，f(n)为语句关于n所占存储空间的函数。</p>
<h1 id="数据结构和算法的联系"><a class="header" href="#数据结构和算法的联系">数据结构和算法的联系</a></h1>
<p>由放书问题得出了下面的结论：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309290959246.png" alt="" /></p>
<p>打印1-N这N个数的循环写法和递归写法运行结果不同，得出了下面的结论：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309290958683.png" alt="" /></p>
<p>计算多项式，普通写法和秦久韶算法有着明显的区别。</p>
<p>计时的基本程序如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

clock_t start,stop;
//clock_t是clock()函数返回的变量类型
double duration;
//记录被调函数运行时间——以秒为单位
void MyFunction()
{

}
int main()
{
    printf(&quot;%d\n&quot;,CLK_TCK);//本机每秒所走的时钟打点数为1000
    start = clock();
    MyFunction();
    stop = clock();
    duration = ((double)(stop-start))/CLK_TCK;
    printf(&quot;%f\n&quot;,duration);
}
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309291049929.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;time.h&gt;

clock_t start,stop;
//clock_t是clock()函数返回的变量类型
double duration;
//记录被调函数运行时间——以秒为单位

#define MAXN 10    //多项式最大项数，即多项式阶数+1
double f1(int n,double a[],double x);
double f2(int n,double a[],double x);

int main()
{
    int i;
    double a[MAXN];    //存储多项式的系数
    for(i=0;i&lt;MAXN;i++) a[i] = double(i);
    return 0;
}
</code></pre>
<p>这个程序第18行为何会报错<code>error: expected expression before 'double'</code>？</p>
<p>double(i)应该写成(double)i。。。。。</p>
<p>此外在C语言中，<code>CLK_TCK</code> 是一个过时的宏定义，代表每秒的时钟计时单元数。在新的标准中，该宏定义已被废弃。可以直接使用 <code>CLOCKS_PER_SEC</code> 来代替 <code>CLK_TCK</code>。</p>
<p>所以，将计算duration的代码修改为以下形式：</p>
<pre><code class="language-c">duration = ((double)(stop - start))/CLOCKS_PER_SEC;
</code></pre>
<p>单次运行代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;time.h&gt;

clock_t start,stop;
//clock_t是clock()函数返回的变量类型
double duration;
//记录被调函数运行时间——以秒为单位

#define MAXN 10    //多项式最大项数，即多项式阶数+1
double f1(int n,double a[],double x);
double f2(int n,double a[],double x);

int main()
{
    int i;
    double a[MAXN];    //存储多项式的系数
    for(i=0;i&lt;MAXN;i++)
        a[i] = (double)i;

    start = clock();
    f1(MAXN,a,1.1);
    stop = clock();
    //duration = ((double)(stop-start))/CLK_TCK;
    duration = ((double)(stop - start))/CLOCKS_PER_SEC;
    printf(&quot;ticks1 = %f\n&quot;,(double)(stop - start));
    printf(&quot;duration1 = %6.2e\n&quot;, duration);

    start = clock();
    f2(MAXN,a,1.1);
    stop = clock();
    duration = ((double)(stop - start))/CLOCKS_PER_SEC;
    //duration = ((double)(stop-start))/CLK_TCK;
    printf(&quot;ticks1 = %f\n&quot;,(double)(stop - start));
    printf(&quot;duration1 = %6.2e\n&quot;, duration);

    return 0;
}

double f1(int n,double a[], double x)
{
    int i;
    double p = a[0];
    for(i=1;i&lt;=n;i++)
        p+=(a[i]*pow(x,i));
    return p;
}

double f2(int n,double a[], double x)
{
    int i;
    double p = a[n];
    for(i=n;i&gt;0;i--)
        p+=(a[i-1]+x*p);
    return p;
}
</code></pre>
<pre><code>ticks1 = 0.000000
duration1 = 0.00e+000
ticks1 = 0.000000
duration1 = 0.00e+000
</code></pre>
<p>多项式阶数太低，两个程序运行时间都不到一个tick，几乎没有差别。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309291116395.png" alt="" /></p>
<p>多次重复运行代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;time.h&gt;

clock_t start,stop;
//clock_t是clock()函数返回的变量类型
double duration;
//记录被调函数运行时间——以秒为单位

#define MAXN 10    //多项式最大项数，即多项式阶数+1
#define MAXK 1e7  //被测函数最大重复调用次数
double f1(int n,double a[],double x);
double f2(int n,double a[],double x);

int main()
{
    int i;
    double a[MAXN];    //存储多项式的系数
    for(i=0;i&lt;MAXN;i++)
        a[i] = (double)i;

    start = clock();
    for(i=1;i&lt;MAXK;i++)       //重复调用函数以获得充分多的时钟打点数
        f1(MAXN,a,1.1);
    stop = clock();
    //duration = ((double)(stop-start))/CLK_TCK;
    duration = ((double)(stop - start))/CLOCKS_PER_SEC/MAXK;    //计算函数单次运行的时间
    printf(&quot;ticks1 = %f\n&quot;,(double)(stop - start));
    printf(&quot;duration1 = %6.2e\n&quot;, duration);

    start = clock();
    for(i=1;i&lt;MAXK;i++)       //重复调用函数以获得充分多的时钟打点数
        f2(MAXN,a,1.1);
    stop = clock();
    //duration = ((double)(stop-start))/CLK_TCK;
    duration = ((double)(stop - start))/CLOCKS_PER_SEC/MAXK;    //计算函数单次运行的时间
    printf(&quot;ticks1 = %f\n&quot;,(double)(stop - start));
    printf(&quot;duration1 = %6.2e\n&quot;, duration);


    return 0;
}

double f1(int n,double a[], double x)
{
    int i;
    double p = a[0];
    for(i=1;i&lt;=n;i++)
        p+=(a[i]*pow(x,i));
    return p;
}

double f2(int n,double a[], double x)
{
    int i;
    double p = a[n];
    for(i=n;i&gt;0;i--)
        p+=(a[i-1]+x*p);
    return p;
}
</code></pre>
<pre><code>ticks1 = 2092.000000
duration1 = 2.09e-007
ticks1 = 443.000000
duration1 = 4.43e-008
</code></pre>
<p>两个程序运行时间差了一个数量级！由此可见：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309291128636.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="mooc-pta复杂度题目"><a class="header" href="#mooc-pta复杂度题目">MOOC-PTA复杂度题目</a></h1>
<ul>
<li><a href="MOOC-PTA%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%A2%98%E7%9B%AE.html#pta-01-%E5%A4%8D%E6%9D%82%E5%BA%A61-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98">PTA 01-复杂度1 最大子列和问题</a>
<ul>
<li><a href="MOOC-PTA%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%A2%98%E7%9B%AE.html#%E4%B8%89%E9%87%8D%E5%BE%AA%E7%8E%AF%E6%B1%82%E8%A7%A3">三重循环求解</a></li>
<li><a href="MOOC-PTA%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%A2%98%E7%9B%AE.html#%E4%BA%8C%E9%87%8D%E5%BE%AA%E7%8E%AF%E6%B1%82%E8%A7%A3">二重循环求解</a></li>
<li><a href="MOOC-PTA%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%A2%98%E7%9B%AE.html#%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95">分治算法</a></li>
<li><a href="MOOC-PTA%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%A2%98%E7%9B%AE.html#%E5%9C%A8%E7%BA%BF%E5%A4%84%E7%90%86%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">在线处理（动态规划）</a></li>
</ul>
</li>
<li><a href="MOOC-PTA%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%A2%98%E7%9B%AE.html#pta-01-%E5%A4%8D%E6%9D%82%E5%BA%A62-maximum-subsequence-sum">PTA 01-复杂度2 Maximum Subsequence Sum</a></li>
<li><a href="MOOC-PTA%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%A2%98%E7%9B%AE.html#pta-01-%E5%A4%8D%E6%9D%82%E5%BA%A63-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">PTA 01-复杂度3 二分查找</a></li>
</ul>
<h2 id="pta-01-复杂度1-最大子列和问题"><a class="header" href="#pta-01-复杂度1-最大子列和问题">PTA 01-复杂度1 最大子列和问题</a></h2>
<p>给定K个整数组成的序列{ N1​, N2​, ..., NK​ }，“连续子列”被定义为{ Ni​, Ni+1​, ..., Nj​ }，其中 1≤i≤j≤K。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。</p>
<p>本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下：</p>
<ul>
<li>数据1：与样例等价，测试基本正确性；</li>
<li>数据2：102个随机整数；</li>
<li>数据3：103个随机整数；</li>
<li>数据4：104个随机整数；</li>
<li>数据5：105个随机整数；</li>
</ul>
<p>输入格式:</p>
<p>输入第1行给出正整数K (≤100000)；第2行给出K个整数，其间以空格分隔。</p>
<p>输出格式:</p>
<p>在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。</p>
<p>输入样例:</p>
<pre><code class="language-in">6
-2 11 -4 13 -5 -2
</code></pre>
<p>输出样例:</p>
<pre><code class="language-out">20
</code></pre>
<h3 id="三重循环求解"><a class="header" href="#三重循环求解">三重循环求解</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202310081535329.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int MaxSubSeq(int A[], int N)
{
    int ThisSum = 0,MaxSum = 0;
    for(int i=0;i &lt; N;i++)
    {
        for(int j = i;j &lt; N;j++)
        {
            ThisSum = 0;
            for(int k=i;k&lt;=j;k++)
                ThisSum += A[k];
            if(ThisSum&gt;MaxSum)
                MaxSum = ThisSum;
        }
    }
    return MaxSum;
}

int main()
{
    int arr[100];
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=0;i&lt;n;i++)
        scanf(&quot;%d&quot;,&amp;arr[i]);
    printf(&quot;%d&quot;,MaxSubSeq(arr,n));
    return 0;
}
</code></pre>
<h3 id="二重循环求解"><a class="header" href="#二重循环求解">二重循环求解</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202310081535616.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int MaxSubSeq(int A[], int N)
{
    int ThisSum = 0,MaxSum = 0;
    for(int i=0;i &lt; N;i++)
    {
        ThisSum = 0;
        for(int j = i;j &lt; N;j++)
        {
            ThisSum += A[j];
            if(ThisSum&gt;MaxSum)
                MaxSum = ThisSum;
        }
    }
    return MaxSum;
}

int main()
{
    int arr[100];
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=0;i&lt;n;i++)
        scanf(&quot;%d&quot;,&amp;arr[i]);
    printf(&quot;%d&quot;,MaxSubSeq(arr,n));
    return 0;
}
</code></pre>
<h3 id="分治算法"><a class="header" href="#分治算法">分治算法</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202310081546769.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int Max3( int A, int B, int C )
{ /* 返回3个整数中的最大值 */
    return A &gt; B ? A &gt; C ? A : C : B &gt; C ? B : C;
}

int DivideAndConquer( int List[], int left, int right )
{ /* 分治法求List[left]到List[right]的最大子列和 */
    int MaxLeftSum, MaxRightSum; /* 存放左右子问题的解 */
    int MaxLeftBorderSum, MaxRightBorderSum; /*存放跨分界线的结果*/

    int LeftBorderSum, RightBorderSum;
    int center, i;

    if( left == right )  { /* 递归的终止条件，子列只有1个数字 */
        if( List[left] &gt; 0 )  return List[left];
        else return 0;
    }

    /* 下面是&quot;分&quot;的过程 */
    center = ( left + right ) / 2; /* 找到中分点 */
    /* 递归求得两边子列的最大和 */
    MaxLeftSum = DivideAndConquer( List, left, center );
    MaxRightSum = DivideAndConquer( List, center+1, right );

    /* 下面求跨分界线的最大子列和 */
    MaxLeftBorderSum = 0; LeftBorderSum = 0;
    for( i=center; i&gt;=left; i-- ) { /* 从中线向左扫描 */
        LeftBorderSum += List[i];
        if( LeftBorderSum &gt; MaxLeftBorderSum )
            MaxLeftBorderSum = LeftBorderSum;
    } /* 左边扫描结束 */

    MaxRightBorderSum = 0; RightBorderSum = 0;
    for( i=center+1; i&lt;=right; i++ ) { /* 从中线向右扫描 */
        RightBorderSum += List[i];
        if( RightBorderSum &gt; MaxRightBorderSum )
            MaxRightBorderSum = RightBorderSum;
    } /* 右边扫描结束 */

    /* 下面返回&quot;治&quot;的结果 */
    return Max3( MaxLeftSum, MaxRightSum, MaxLeftBorderSum + MaxRightBorderSum );
}

int MaxSubseqSum3( int List[], int N )
{ /* 保持与前2种算法相同的函数接口 */
    return DivideAndConquer( List, 0, N-1 );
}

int main()
{
    int arr[100];
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=0;i&lt;n;i++)
        scanf(&quot;%d&quot;,&amp;arr[i]);
    printf(&quot;%d&quot;,MaxSubseqSum3(arr,n));
    return 0;
}
</code></pre>
<h3 id="在线处理动态规划"><a class="header" href="#在线处理动态规划">在线处理（动态规划）</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202310081549404.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int MaxSubSeq(int A[], int N)
{
    int i;
    int ThisSum,MaxSum;
    ThisSum = 0,MaxSum = 0;
    for(i=0;i &lt; N;i++)
    {
        ThisSum += A[i];
        if(ThisSum &gt; MaxSum)
            MaxSum = ThisSum;
        else if(ThisSum &lt; 0)
            ThisSum = 0;
    }
    return MaxSum;
}

int main()
{
    int arr[100];
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=0;i&lt;n;i++)
        scanf(&quot;%d&quot;,&amp;arr[i]);
    printf(&quot;%d&quot;,MaxSubSeq(arr,n));
    return 0;
}
</code></pre>
<h2 id="pta-01-复杂度2-maximum-subsequence-sum"><a class="header" href="#pta-01-复杂度2-maximum-subsequence-sum">PTA 01-复杂度2 Maximum Subsequence Sum</a></h2>
<p>Given a sequence of K integers { N1​, N2​, ..., NK​ }. A continuous subsequence is defined to be { Ni​, Ni+1​, ..., Nj​ } where 1≤i≤j≤K. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.</p>
<p>Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer K (≤10000). The second line contains K numbers, separated by a space.</p>
<p>Output Specification:</p>
<p>For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.</p>
<p>Sample Input:</p>
<pre><code class="language-in">10
-10 1 2 3 4 -5 -23 3 7 -21
</code></pre>
<p>Sample Output:</p>
<pre><code class="language-out">10 1 4
</code></pre>
<p>注意：这里需特别注意输出部分，因为题目中说“<em>If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.</em>”（当输入的这K个数全为负时，输出的最大子列和应为0，并输出整个输入序列的首尾两个数）。那就需要对应MaxSum &gt;= 0和MaxSum &lt; 0的情况，之所以要把 = 0的情况放到前者，是因为 = 0可能是输入序列中有0有负的结果，比如输入6个数-2，0，-1，0，0，0。那最大子列和也是0但是显然不应输出题意要求的全为负情况下的首末两个数（-2和0）而是输出正常比较后的0和0（对应下标都为1）。</p>
<p>这也涉及到和前一题不同的MaxSum初值问题，因为输入全为负的情况下，累加时ThisSum不断重置为0，MaxSum保持不变，最后直接进入输出的else情况，符合题意。</p>
<pre><code>6
-2 0 -1 0 0 0
ThisSum=0, MaxSum=-1, MaxIndex=0, MinIndex=0, tmpMinIndex=1
ThisSum=0, MaxSum=0, MaxIndex=1, MinIndex=1, tmpMinIndex=1
ThisSum=0, MaxSum=0, MaxIndex=1, MinIndex=1, tmpMinIndex=3
ThisSum=0, MaxSum=0, MaxIndex=1, MinIndex=1, tmpMinIndex=3
ThisSum=0, MaxSum=0, MaxIndex=1, MinIndex=1, tmpMinIndex=3
ThisSum=0, MaxSum=0, MaxIndex=1, MinIndex=1, tmpMinIndex=3
0 0 0
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void MaxSubSumWithIndex(int List[], int K)
{
    int i;
    int MaxIndex = 0, MinIndex = 0, tmpMinIndex = 0;
    int ThisSum = 0, MaxSum = -1;    //这里MaxSum不能改成0
    for(i = 0; i &lt; K; i++)
    {
        ThisSum += List[i];
        if (ThisSum &gt; MaxSum)
        {
            MaxSum = ThisSum;
            MaxIndex = i;
            MinIndex = tmpMinIndex;
        }else if(ThisSum &lt; 0)
        {
            ThisSum = 0;
            tmpMinIndex = i + 1;
        }
        printf(&quot;ThisSum=%d, MaxSum=%d, MaxIndex=%d, MinIndex=%d, tmpMinIndex=%d\n&quot;,ThisSum, MaxSum, MaxIndex, MinIndex, tmpMinIndex);
    }
    if(MaxSum &gt;= 0)
      printf(&quot;%d %d %d\n&quot;, MaxSum, List[MinIndex], List[MaxIndex]);
    else
      printf(&quot;0 %d %d\n&quot;, List[0], List[K - 1]);
}

int main()
{
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    int arr[n];
    for(int i = 0; i&lt;n; i++)
        scanf(&quot;%d&quot;,&amp;arr[i]);
    MaxSubSumWithIndex(arr, n);
    return 0;
}
</code></pre>
<h2 id="pta-01-复杂度3-二分查找"><a class="header" href="#pta-01-复杂度3-二分查找">PTA 01-复杂度3 二分查找</a></h2>
<p>本题要求实现二分查找算法。</p>
<p>函数接口定义：</p>
<pre><code class="language-c++">Position BinarySearch( List L, ElementType X );
</code></pre>
<p>其中<code>List</code>结构定义如下：</p>
<pre><code class="language-c">typedef int Position;
typedef struct LNode *List;
struct LNode {
    ElementType Data[MAXSIZE];
    Position Last; /* 保存线性表中最后一个元素的位置 */
};
</code></pre>
<p><code>L</code>是用户传入的一个线性表，其中<code>ElementType</code>元素可以通过&gt;、<code>==</code>、&lt;进行比较，并且题目保证传入的数据是递增有序的。函数<code>BinarySearch</code>要查找<code>X</code>在<code>Data</code>中的位置，即数组下标（注意：元素从下标1开始存储）。找到则返回下标，否则返回一个特殊的失败标记<code>NotFound</code>。</p>
<p>裁判测试程序样例：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MAXSIZE 10
#define NotFound 0
typedef int ElementType;

typedef int Position;
typedef struct LNode *List;
struct LNode {
    ElementType Data[MAXSIZE];
    Position Last; /* 保存线性表中最后一个元素的位置 */
};

List ReadInput(); /* 裁判实现，细节不表。元素从下标1开始存储 */
Position BinarySearch( List L, ElementType X );

int main()
{
    List L;
    ElementType X;
    Position P;

    L = ReadInput();
    scanf(&quot;%d&quot;, &amp;X);
    P = BinarySearch( L, X );
    printf(&quot;%d\n&quot;, P);

    return 0;
}

/* 你的代码将被嵌在这里 */
</code></pre>
<p>\输入样例1：</p>
<pre><code>5
12 31 55 89 101
31
</code></pre>
<p>输出样例1：</p>
<pre><code>2
</code></pre>
<p>输入样例2：</p>
<pre><code>3
26 78 233
31
</code></pre>
<p>输出样例2：</p>
<pre><code>0
</code></pre>
<pre><code class="language-c">Position BinarySearch( List L, ElementType X )
{
    Position left = 1;
    Position right = L-&gt;Last;
    Position mid;
    while(left &lt;= right)
    {
        mid = (left + right) / 2;
        if(L-&gt;Data[mid] &lt; X)
            left = mid + 1;
        else if(L-&gt;Data[mid] &gt; X)
            right = mid - 1;
        else
            return mid;
    }
    return NotFound;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="线性结构"><a class="header" href="#线性结构">线性结构</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="线性表linear-list"><a class="header" href="#线性表linear-list">线性表Linear List</a></h1>
<ul>
<li><a href="%E7%BA%BF%E6%80%A7%E8%A1%A8.html#%E5%BC%95%E5%AD%90%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%A1%A8%E7%A4%BA">引子：多项式表示</a></li>
<li><a href="%E7%BA%BF%E6%80%A7%E8%A1%A8.html#%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%AE%9A%E4%B9%89">线性表定义</a>
<ul>
<li><a href="%E7%BA%BF%E6%80%A7%E8%A1%A8.html#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89">线性表的抽象数据类型定义</a></li>
<li><a href="%E7%BA%BF%E6%80%A7%E8%A1%A8.html#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0">线性表的顺序存储实现</a></li>
<li><a href="%E7%BA%BF%E6%80%A7%E8%A1%A8.html#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0">线性表的链式存储实现</a></li>
<li><a href="%E7%BA%BF%E6%80%A7%E8%A1%A8.html#%E5%B9%BF%E4%B9%89%E8%A1%A8%E5%92%8C%E5%A4%9A%E9%87%8D%E9%93%BE%E8%A1%A8">广义表和多重链表</a></li>
</ul>
</li>
</ul>
<h2 id="引子多项式表示"><a class="header" href="#引子多项式表示">引子：多项式表示</a></h2>
<p>一元多项式及其运算：<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8144em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></p>
<p>主要运算：多项式相加、相减、相乘等</p>
<p>分析：如何表示多项式？</p>
<p>（1）顺序存储结构直接表示</p>
<p>数组各分量对应多项式各项，<code>a[i]</code>：项<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的系数<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>两个多项式相加：两个数组对应分量相加</p>
<p>问题：如何表示多项式<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">3</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2000</span></span></span></span></span></span></span></span></span></span></span></span>？</p>
<p>空间利用率较低</p>
<p>（2）顺序存储结构表示非零项</p>
<p>每个非零项<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9747em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span>涉及两个信息：系数<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和指数i</p>
<p>可以将一个多项式看成是一个<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span>二元组的集合。</p>
<p>用结构数组表示：数组分量是由系数<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、指数i组成的结构，对应一个非零项</p>
<p>例如：<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">9</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">15</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">3</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>       <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">26</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">19</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">13</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">82</span></span></span></span></p>
<p>为了方便相加可以<strong>按指数大小存储</strong>！</p>
<p>相加过程：从头开始，比较两个多项式当前对应项的指数</p>
<p>（3）链表结构存储非零项</p>
<p>链表中每个节点存储多项式中的一个非零项，包括系数和指数两个数据域以及一个指针域</p>
<div class="table-wrapper"><table><thead><tr><th>coef</th><th>expon</th><th>link</th></tr></thead><tbody>
</tbody></table>
</div>
<pre><code class="language-c">typedef struct PolyNode *Polynomial;

struct PolyNode
{
    int coef;
    int expon;
    Polynomial link;
};
</code></pre>
<h2 id="线性表定义"><a class="header" href="#线性表定义">线性表定义</a></h2>
<p>多项式表示问题的启示：</p>
<p>1.同一个问题可以有不同的表示（存储）方法</p>
<p>2.有一类共性问题：有序线性序列的组织和管理</p>
<p>线性表：0个或多个同类型数据元素的<font color="red">有限序列</font>。</p>
<p>班级同学的花名册是线性表，因为这是有限序列。在较复杂的线性表中，一个数据元素可以由若干个数据项组成。</p>
<h3 id="线性表的抽象数据类型定义"><a class="header" href="#线性表的抽象数据类型定义">线性表的抽象数据类型定义</a></h3>
<p>线性表的抽象数据类型定义如下：</p>
<pre><code>ADT 线性表(List)
Data
	线性表的数据对象集合为{a1,a2,...,an}，每个元素的类型均为DataType。其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。
Operation
	InitList(*L):初始化操作，建立一个空的线性表L。
	ListEmpty(L):若线性表为空，返回true，否则返回false。
	ClearList(*L)：将线性表清空。
	GetElem(L,i,*e)：将线性表L中的第i个未知元素值返回给e。
	LocateElem(L,e)：在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回0表示失败。
	ListInsert(*L,i,e)：在线性表L中的第i个位置插入新元素e。
	ListDelete(*L,i,*e)：删除线性表L中第i个位置元素，并用e返回其值。
	ListLength(L)：返回线性表L的元素个数。
endADT
</code></pre>
<h3 id="线性表的顺序存储实现"><a class="header" href="#线性表的顺序存储实现">线性表的顺序存储实现</a></h3>
<p>利用数组的连续存储空间顺序存放线性表的各元素</p>
<pre><code class="language-c">typedef struct LNode* List;

struct LNode
{
    ElementType Data[MAXSIZE];
    int Last;//记录最后一位有效位
};
struct LNode L;
List PtrL;
</code></pre>
<p>访问下标为i的元素：<code>L.Data[i]</code>或<code>PtrL-&gt;Data[i]</code></p>
<p>线性表的长度：<code>L.Last+1</code>或<code>PtrL-&gt;Last+1</code></p>
<p>陈越姥姥《数据结构》课程实现版本：</p>
<pre><code class="language-c">#define MAXSIZE 20 /*存储空间初始分配量*/

typedef struct LNode* List;

struct LNode
{
    ElementType Data[MAXSIZE];
    int Last;//记录最后一位有效位
};
struct LNode L;
List PtrL;

List MakeEmpty()
{
    List PtrL;
    PtrL=(List)malloc(sizeof(struct LNode));
    PtrL-&gt;Last=-1;
    return PtrL;
}
int Find(ElementType X,List PtrL)
{
    int i=0;
    while(i&lt;=PtrL-&gt;Last&amp;&amp;PtrL-&gt;Data[i]!=X)
        i++;
    if(i&gt;PtrL-&gt;Last) return -1;//如果没找到，返回-1
    else return i;//找到后返回的是存储位置（下标）
}

/*插入（第i（1&lt;=i&lt;=n+1）个位置上插入一个值为X的新元素*/

void Insert(ElementType X,int i,List PtrL)       /*i是序数，为下标+1，不是下标*/
{
    int j;
    if(PtrL-&gt;Last==MAXSIZE-1) /*表空间已满，不能插入*/
    {
        printf(&quot;表满&quot;);
        return;
    }
    if(i&lt;1||i&gt;PtrL-&gt;Last+2)    /*检查插入位置的合法性*/
    {
        printf(&quot;位置不合法&quot;);
        return;
    }
    for(j=PtrL-&gt;Last;j&gt;=i-1;j--)
        PtrL-&gt;Data[j+1]=PtrL-&gt;Data[j];    /*将ai~an倒序向后移动*/
    PtrL-&gt;Data[i-1]=X;       /*新元素插入*/
    PtrL-&gt;Last++;        /*Last仍指向最后一个元素*/
    return;
}

/*删除：删除表的第i（1&lt;=i&lt;=n）个位置上的元素*/

void Delete(int i,List PtrL)
{
    int j;
    if(i&lt;1||i&gt;PtrL-&gt;Last+1)    /*检查是否为空表及删除位置的合法性*/
    {
        printf(&quot;不存在第%d个元素&quot;,i);
        return;
    }
    for(j=i;j&lt;=PtrL-&gt;Last;j++)
        PtrL-&gt;Data[j-1]=PtrL-&gt;Data[j];     /*将a(i+1)~an顺序向前移动*/
    PtrL-&gt;Last--;         /*Last仍指向最后一个元素*/
    return;
}
</code></pre>
<p>《大话数据结构》给出的顺序存储的链表实例：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

#define MAXSIZE 100
#define OK 1
#define ERROR 0
#define OVERFLOW -2             //这样就为 `OVERFLOW` 定义了一个值为 `-2` 的常量。

typedef int ElemType;
typedef int Status;

typedef struct
{
    ElemType *elem;
    int length;
}SqList;

//线性表的初始化
Status InitList(SqList &amp;L)
{
    L.elem=new ElemType[MAXSIZE];
    if(!L.elem)
        exit(OVERFLOW);
    L.length=0;
    return OK;
}
//线性表的取值
Status GetElem(SqList L,int i,ElemType &amp;e)
{
    if(i&lt;1||i&gt;L.length)
        return ERROR;
    e=L.elem[i-1];
    return OK;
}
//查找元素
int LocateElem(SqList L,ElemType e)
{
    for(int i=0;i&lt;L.length;i++)
    {
        if(L.elem[i]==e)
            return i+1;
    }
    return 0;
}
//线性表插入元素
Status ListInsert(SqList &amp;L,int i,ElemType e)
{
    if(i&lt;1||i&gt;L.length+1)
        return ERROR;
    if(L.length==MAXSIZE)
        return ERROR;
    for(int j=L.length-1;j&gt;=i-1;j--)
    {
        L.elem[j+1]=L.elem[j];
    }
    L.elem[i-1]=e;
    L.length++;
    return OK;
}
//线性表删除元素
Status ListDelete(SqList &amp;L,int i)
{
    if(i&lt;1||i&gt;L.length)
        return ERROR;
    for(int j=i;j&lt;=L.length-1;j++)
        L.elem[j-1]=L.elem[j];
    L.length--;
    return OK;
}
//打印线性表
Status Display(SqList &amp;L)
{
    for(int i=0;i&lt;L.length;i++)
        printf(&quot;%d &quot;,L.elem[i]);
    printf(&quot;\n&quot;);
    return 0;
}

int main()
{
    SqList L;
    int v,k,opt;
    InitList(L);
    printf(&quot;1：在线性表中存入5个值\n&quot;);
    printf(&quot;2：查找线性表中的元素\n&quot;);
    printf(&quot;3：向线性表中插入一个元素\n&quot;);
    printf(&quot;4：从线性表中删除一个元素\n&quot;);
    printf(&quot;5：退出\n&quot;);
    while(1)
    {
        printf(&quot;输入你的选择：&quot;);
        cin&gt;&gt;opt;
        if(opt==1)
        {
            printf(&quot;请输入要插入的5个值：&quot;);
            for(int i=1;i&lt;=5;i++)
            {
                cin&gt;&gt;v;
                ListInsert(L,i,v);
            }
            printf(&quot;当前线性表为：&quot;);
            Display(L);
        }
        else if(opt==2)
        {
            printf(&quot;请输入要查找的元素：&quot;);
            cin&gt;&gt;v;
            k=LocateElem(L,v);
            printf(&quot;要查找的元素的所在的位置为：%d\n&quot;,k);
        }
        else if(opt==3)
        {
            printf(&quot;请输入要插入的元素及插入的位置：&quot;);
            cin&gt;&gt;v&gt;&gt;k;
            ListInsert(L,k,v);
            printf(&quot;插入元素后的线性表为：&quot;);
            Display(L);
        }
        else if(opt==4)
        {
            printf(&quot;输入要删除的元素的序数：&quot;);
            cin&gt;&gt;v;
            ListDelete(L,v);
            printf(&quot;删除后的线性表为：&quot;);
            Display(L);
        }
        else if(opt==5)
        {
            printf(&quot;退出成功！&quot;);
            break;
        }
    }
    return 0;

}
</code></pre>
<pre><code>1：在线性表中存入5个值
2：查找线性表中的元素
3：向线性表中插入一个元素
4：从线性表中删除一个元素
5：退出
输入你的选择：1
请输入要插入的5个值：9 4 2 1 0
当前线性表为：9 4 2 1 0
输入你的选择：2
请输入要查找的元素：4
要查找的元素的所在的位置为：2
输入你的选择：3
请输入要插入的元素及插入的位置：5 3
插入元素后的线性表为：9 4 5 2 1 0
输入你的选择：4
输入要删除的元素的序数：6
删除后的线性表为：9 4 5 2 1
输入你的选择：5
退出成功！
</code></pre>
<h3 id="线性表的链式存储实现"><a class="header" href="#线性表的链式存储实现">线性表的链式存储实现</a></h3>
<p>不要求逻辑上相邻的两个元素物理上也相邻；通过”链“建立起数据元素之间的逻辑关系。</p>
<p>插入、删除元素不需要移动数据元素，只需要修改”链“。</p>
<p>如果只知道链表头，该怎么访问序号为i的元素？以及怎么求线性表的长度？</p>
<p>建立结构体和结构体指针：</p>
<pre><code class="language-c">typedef struct LNode *List;

struct LNode
{
    ElementType Data;
    List Next;
};
struct LNode L;
List PtrL;
</code></pre>
<p>展示链表结构：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
struct  list_node
{
	int data ;
	struct list_node *next ;
};

typedef struct list_node list_single ;
list_single *create_list_node(int data)
{
	list_single *node = NULL ;
	node = (list_single *)malloc(sizeof(list_single));
	if(node == NULL){
		printf(&quot;malloc fair!\n&quot;);
	}
	memset(node,0,sizeof(list_single));
	node-&gt;data = data;
	node-&gt;next = NULL ;
	return node ;
}
int main(void)
{
	int data = 100 ;
	list_single *node_ptr = create_list_node(data); //创建一个节点
	printf(&quot;node_ptr-&gt;data=%d\n&quot;,node_ptr-&gt;data);   //打印节点里的数据
	printf(&quot;node_ptr-&gt;next=%d\n&quot;,node_ptr-&gt;next);
	free(node_ptr);
	return 0 ;
}
</code></pre>
<pre><code>node_ptr-&gt;data=100
node_ptr-&gt;next=0
</code></pre>
<p>1.求链表的长度</p>
<pre><code class="language-c">int Length(List Ptrl)
{
    List p=Ptrl;     //p指向表的第一个结点
    int j=0;
    while(p)
    {
        p=p-&gt;Next;     
        j++;        //当前p指向的是第j个结点
    }
    return j;
}
</code></pre>
<p>2.查找（1）按序号（不是下标）查找：<code>FindKth</code></p>
<pre><code class="language-c">List FindKth(int K,List PtrL)
{
    List p=PtrL;
    int i=1;
    while(p!=NULL&amp;&amp;i&lt;K)
    {
        p=p-&gt;Next;
        i++;
    }
    if(i==K)
        return p;     //找到第K个，返回指针
    else
        return NULL;  //否则返回空
}
</code></pre>
<p>（2）按值查找</p>
<pre><code class="language-c">List Find(ElementType X,List PtrL)
{
    List p=PtrL;
    while(p!=NULL &amp;&amp; p-&gt;Data!=X)
    {
        p=p-&gt;Next;
    }
    return p;
}
</code></pre>
<p>3.插入（在<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mord cjk_fallback">（</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord cjk_fallback">）</span></span></span></span>个结点后插入一个值为X的新结点</p>
<p>这个结点是第i个结点。</p>
<p>步骤（1）先构造一个新结点，用s指向；（2）再找到链表的第i-1个结点，用p指向；（3）然后修改指针，插入结点（p之后插入的新结点是s）。</p>
<p><strong>链表要先断再接，顺序不能更改！！</strong></p>
<p><strong>链表要先断再接，顺序不能更改！！</strong></p>
<p><strong>链表要先断再接，顺序不能更改！！</strong></p>
<pre><code class="language-c">List Insert(ElementType X,int i,List PtrL) 
{
    List p,s;
    if(i==1)           //新节点插在表头
    {
        s=(List)malloc(sizeof(struct LNode));     //申请、填装结点
        s-&gt;Data=X;
        s-&gt;Next=Ptrl;
        return s;           //返回新表头指针
    }
    p=FindKth(i-1;PtrL);       //查找第i-1个结点
    if(p==NULL)        //第i-1个不存在，不能插入
    {
        printf(&quot;参数i错&quot;);
        return NULL;
    }
    else
    {
        s=(List)malloc(sizeof(struct LNode));      //申请、填装结点
        s.Data=X;
        s-&gt;Next=p-&gt;Next;         //新节点插在第i-1个结点的后面
        p-&gt;Next=s;
        return PtrL;
    }
}
</code></pre>
<p>4.删除（删除链表的<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord cjk_fallback">第</span><span class="mord mathnormal">i</span><span class="mord cjk_fallback">个（</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">n</span><span class="mord cjk_fallback">）</span></span></span></span>个位置上的的结点</p>
<p>步骤：（1）先找到链表的第i-1个结点，用p指向；（2）再用指针s指向要被删除的结点（p的下一个结点）；（3）然后修改指针，删除s所指结点；（4）最后释放s所指结点的空间。</p>
<p>步骤不能更改！！！</p>
<p>步骤不能更改！！！</p>
<p>步骤不能更改！！！</p>
<pre><code class="language-c">List Delete(int i,List PtrL) 
{
    List p,s;
    if(i==1)           //若要删除的是表的第一个结点
    {
        s=PtrL;         //s指向第一个结点
        if(PtrL!=NULL)
            PtrL=PtrL-&gt;Next;   //从链表中删除
        else
            return NULL;
        free(s);             //释放被删除结点
        return PtrL;           //返回新表头指针
    }
    p=FindKth(i-1;PtrL);       //查找第i-1个结点
    if(p==NULL)        
    {
        printf(&quot;第%d个结点不存在&quot;,i-1);
        return NULL;
    }
    else if(p-&gt;Next==NULL)        
    {
        printf(&quot;第%d个结点不存在&quot;,i);
        return NULL;
    }
    else
    {
        s=p-&gt;Next;               //s指向第i个结点
        p-&gt;Next=s-&gt;Next;         //从链表中删除
        free(s);           //释放被删除结点
        return PtrL;
    }
}
</code></pre>
<p>陈越姥姥《数据结构》课程给出的完整代码如下：</p>
<pre><code class="language-c">typedef struct LNode *List;

struct LNode
{
    ElementType Data;
    List Next;
};
struct LNode L;
List PtrL;

int Length(List Ptrl)
{
    List p=Ptrl;     //p指向表的第一个结点
    int j=0;
    while(p)
    {
        p=p-&gt;Next;     
        j++;        //当前p指向的是第j个结点
    }
    return j;
}

List FindKth(int K,List PtrL)
{
    List p=PtrL;
    int i=1;
    while(p!=NULL&amp;&amp;i&lt;K)
    {
        p=p-&gt;Next;
        i++;
    }
    if(i==K)
        return p;     //找到第K个，返回指针
    else
        return NULL;  //否则返回空
}

List Find(ElementType X,List PtrL)
{
    List p=PtrL;
    while(p!=NULL &amp;&amp; p-&gt;Data!=X)
    {
        p=p-&gt;Next;
    }
    return p;
}

List Insert(ElementType X,int i,List PtrL) 
{
    List p,s;
    if(i==1)           //新节点插在表头
    {
        s=(List)malloc(sizeof(struct LNode));     //申请、填装结点
        s-&gt;Data=X;
        s-&gt;Next=Ptrl;
        return s;           //返回新表头指针
    }
    p=FindKth(i-1;PtrL);       //查找第i-1个结点
    if(p==NULL)        //第i-1个不存在，不能插入
    {
        printf(&quot;参数i错&quot;);
        return NULL;
    }
    else
    {
        s=(List)malloc(sizeof(struct LNode));      //申请、填装结点
        s.Data=X;
        s-&gt;Next=p-&gt;Next;         //新节点插在第i-1个结点的后面
        p-&gt;Next=s;
        return PtrL;
    }
}

List Delete(int i,List PtrL) 
{
    List p,s;
    if(i==1)           //若要删除的是表的第一个结点
    {
        s=PtrL;         //s指向第一个结点
        if(PtrL!=NULL)
            PtrL=PtrL-&gt;Next;   //从链表中删除
        else
            return NULL;
        free(s);             //释放被删除结点
        return PtrL;           //返回新表头指针
    }
    p=FindKth(i-1;PtrL);       //查找第i-1个结点
    if(p==NULL)        
    {
        printf(&quot;第%d个结点不存在&quot;,i-1);
        return NULL;
    }
    else if(p-&gt;Next==NULL)        
    {
        printf(&quot;第%d个结点不存在&quot;,i);
        return NULL;
    }
    else
    {
        s=p-&gt;Next;               //s指向第i个结点
        p-&gt;Next=s-&gt;Next;         //从链表中删除
        free(s);           //释放被删除结点
        return PtrL;
    }
}
</code></pre>
<p>《大话数据结构》中链式存储的链表实例：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define ERROR 0
#define OK 1
typedef int Status;
typedef int ElementType;

typedef struct LNode *List;

struct LNode
{
    ElementType Data;
    List Next;
};
struct LNode L;
List PtrL;

//表的创建（头插法）

void CreateListHead(List *L,int m[],int n)
{
    List p;
    int i;
    *L=(List)malloc(sizeof(struct LNode));
    (*L)-&gt;Next=NULL;
    for(i=0;i&lt;n;i++)
    {
        p=(List)malloc(sizeof(struct LNode));
        p-&gt;Data=m[i];
        p-&gt;Next=(*L)-&gt;Next;
        (*L)-&gt;Next=p;
    }
}

//表的创建（尾插法）
void CreateListTail(List *L,int m[],int n)
{
    List p,r;
    int i;
    *L=(List)malloc(sizeof(struct LNode));
    r=*L;
    for(i=0;i&lt;n;i++)
    {
        p=(List)malloc(sizeof(struct LNode));
        p-&gt;Data=m[i];
        r-&gt;Next=p;
        r=p;
    }
    r-&gt;Next=NULL;
}

Status GetElem(List L,int i,ElementType *e)
{
    int j;
    List p;
    p=L-&gt;Next;
    j=1;
    while(p&amp;&amp;j&lt;i)
    {
        p=p-&gt;Next;
        j++;
    }
    if(!p||j&gt;i)
        return ERROR;
    *e=p-&gt;Data;
    return OK;
}
Status ListInsert(List *L,int i,ElementType e)
{
    int j;
    List p,s;
    p=*L;
    j=1;
    while(p&amp;&amp;j&lt;i)
    {
        p=p-&gt;Next;
        j++;
    }
    if(!p||j&gt;i)
        return ERROR;
    s=(List)malloc(sizeof(struct LNode));
    s-&gt;Data=e;
    s-&gt;Next=p-&gt;Next;
    p-&gt;Next=s;
    return OK;
}

Status ListDelete(List *L,int i)
{
    int j;
    List p,q;
    p=*L;
    j=1;
    while(p-&gt;Next&amp;&amp;j&lt;i)
    {
        p=p-&gt;Next;
        j++;
    }
    if(!(p-&gt;Next)||j&gt;i)
        return ERROR;

    q=p-&gt;Next;
    p-&gt;Next=q-&gt;Next;
    free(q);
    return OK;
}
Status Output(List L)
{
    List p;
    p=L-&gt;Next;
    while(p)
    {
        printf(&quot;%d&quot;,p-&gt;Data);
        p=p-&gt;Next;
    }
    printf(&quot;\n&quot;);
}

int main()
{
    List L;
    int i,j,k,n,e,m[100];
    printf(&quot;请输入要存储元素的总个数：&quot;);
    scanf(&quot;%d&quot;,&amp;n);
    printf(&quot;请输入各个元素的值：&quot;);
    for(i=0;i&lt;n;i++)
        scanf(&quot;%d&quot;,&amp;m[i]);

    CreateListHead(&amp;L,m,n);
    printf(&quot;此时链表的元素如下所示：\n&quot;);
    Output(L);
    printf(&quot;请输入要获取的第j个元素并返回到e值中（输入j的值）：&quot;);
    scanf(&quot;%d&quot;,&amp;j);
    GetElem(L,j,&amp;e);
    printf(&quot;此时e的值为第j个元素值：%d\n&quot;,e);
    printf(&quot;请输入在第k个元素前插入一个元素e1：&quot;);
    int e1;
    scanf(&quot;%d%d&quot;,&amp;k,&amp;e1);
    ListInsert(&amp;L,k,e1);
    printf(&quot;此时链表的个元素如下：\n&quot;);
    Output(L);
    printf(&quot;请输入要删除元素的序号：&quot;);
    int l;
    scanf(&quot;%d&quot;,&amp;l);
    ListDelete(&amp;L,l);
    printf(&quot;此时链表的各元素如下：\n&quot;);
    Output(L);
    return 0;

}
</code></pre>
<pre><code>请输入要存储元素的总个数：5
请输入各个元素的值：1 2 3 4 5
此时链表的元素如下所示：
54321
请输入要获取的第j个元素并返回到e值中（输入j的值）：2
此时e的值为第j个元素值：4
请输入在第k个元素前插入一个元素e1：1 2
此时链表的个元素如下：
254321
请输入要删除元素的序号：2
此时链表的各元素如下：
24321
</code></pre>
<h3 id="广义表和多重链表"><a class="header" href="#广义表和多重链表">广义表和多重链表</a></h3>
<p>我们知道了一元多项式的表示，那么二元多项式又该如何表示呢？比如给定二元多项式：<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord">9</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord">15</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">3</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309231015068.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309231016967.png" alt="" /></p>
<p>广义表（Generalized List）</p>
<ul>
<li>广义表是线性表的推广；</li>
<li>对于线性表而言，n个元素都是基本的单元素；</li>
<li>广义表中，这些元素不仅可以是单元素也可以是另一个广义表。</li>
</ul>
<pre><code class="language-c">typedef struct GNode *Glist;
struct GNode
{
    int Tag;    //标志域：0表示结点是单元素，1表示结点是广义表
    union
    {
        ElementType Data;    //子表指针域SubList与单元素数据域Data复用，即共用存储空间
        GList SubList;
    }URegion;
    GList Next;      //指向后继结点
};
</code></pre>
<p>多重链表：链表中的结点可能同时隶属于多个链</p>
<ul>
<li>多重链表中结点的指针域会有多个，如前面例子包含了Next和SubList两个指针域</li>
<li>但包含两个指针域的链表并不一定是多重链表，比如双向链表不是多重链表</li>
</ul>
<p>多重链表有广泛的用途：基本上如树、图这样相对复杂的数据结构都可以采用多重链表的方式存储。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309231035479.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309231037452.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309231038863.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="栈stack"><a class="header" href="#栈stack">栈Stack</a></h1>
<ul>
<li><a href="%E6%A0%88.html#%E5%AE%9A%E4%B9%89">定义</a></li>
<li><a href="%E6%A0%88.html#%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0">栈的顺序存储实现</a></li>
<li><a href="%E6%A0%88.html#%E5%AE%9E%E4%BE%8Bpta6-7-%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E5%A0%86%E6%A0%88">实例PTA6-7 在一个数组中实现两个堆栈</a></li>
<li><a href="%E6%A0%88.html#%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0">栈的链式存储实现</a></li>
<li><a href="%E6%A0%88.html#%E6%A0%88%E5%BA%94%E7%94%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC">栈应用：表达式求值</a></li>
</ul>
<h2 id="定义"><a class="header" href="#定义">定义</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021433761.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021436202.png" alt="" /></p>
<p>还有一种表达式叫“前缀表达式”，即运算符号位于运算数之前,比如<code>a+b*c</code>的前缀表达式是<code>+a*bc</code>。</p>
<p>你能写出<code>a+b*c-d/e</code>的前缀表达式吗？<code>-+a*bc/de</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021437861.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021443709.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021447134.png" alt="" /></p>
<h2 id="栈的顺序存储实现"><a class="header" href="#栈的顺序存储实现">栈的顺序存储实现</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021455386.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021459833.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021504952.png" alt="" /></p>
<p>根据刚才讲的方法，用一个数组来表示双堆栈，如果这两个堆栈的栈顶位置分别是top1和top2，那么可以用<code>top1+top2==MaxSize(数组大小）</code>来判别堆栈是否满？</p>
<p><font color="red">不可以！！！</font></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021508548.png" alt="" /></p>
<p>《数据结构》课程给出的代码如下：</p>
<pre><code class="language-c">typedef int Position;
struct SNode {
    ElementType *Data; /* 存储元素的数组 */
    Position Top;      /* 栈顶指针 */
    int MaxSize;       /* 堆栈最大容量 */
};
typedef struct SNode *Stack;

Stack CreateStack( int MaxSize )
{
    Stack S = (Stack)malloc(sizeof(struct SNode));
    S-&gt;Data = (ElementType *)malloc(MaxSize * sizeof(ElementType));
    S-&gt;Top = -1;
    S-&gt;MaxSize = MaxSize;
    return S;
}

bool IsFull( Stack S )
{
    return (S-&gt;Top == S-&gt;MaxSize-1);
}

bool Push( Stack S, ElementType X )
{
    if ( IsFull(S) ) {
        printf(&quot;堆栈满&quot;);
        return false;
    }
    else {
        S-&gt;Data[++(S-&gt;Top)] = X;
        return true;
    }
}

bool IsEmpty( Stack S )
{
    return (S-&gt;Top == -1);
}

ElementType Pop( Stack S )
{
    if ( IsEmpty(S) ) {
        printf(&quot;堆栈空&quot;);
        return ERROR; /* ERROR是ElementType的特殊值，标志错误 */
    }
    else 
        return ( S-&gt;Data[(S-&gt;Top)--] );
}
</code></pre>
<p>测试程序如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

#define ElementType int
#define ERROR -1
#define OK 0

typedef int Position;
typedef struct SNode *Stack;

struct SNode
{
    ElementType *Data;
    Position Top;
    int MaxSize;
};

Stack CreateStack(int MaxSize)
{
    Stack S = (Stack)malloc(sizeof(struct SNode));
    S-&gt;Data = (ElementType*)malloc(MaxSize * sizeof(ElementType));
    S-&gt;Top = -1;
    S-&gt;MaxSize = MaxSize;
    return S;
}
bool IsFull(Stack S)
{
    return (S-&gt;Top == S-&gt;MaxSize-1);
}
bool Push(Stack PtrS,ElementType X)
{
    if(IsFull(PtrS))
        return false;
    else
    {
        PtrS-&gt;Data[++(PtrS-&gt;Top)] = X;
        return true;
    }
}

bool IsEmpty(Stack S)
{
    return (S-&gt;Top == -1);
}

ElementType Pop(Stack PtrS)
{

    if(IsEmpty(PtrS))
    {
        printf(&quot;栈已空！&quot;);
        return ERROR;
    }
    else
    {
        return (PtrS-&gt;Data[(PtrS-&gt;Top)--]);
    }
}

int main()
{
    Stack S = CreateStack(10);
    int choice;
    while(1)
    {
        printf(&quot;（1）进栈 （2）出栈 （3）读栈顶 （4）退出\n&quot;);
        scanf(&quot;%d&quot;,&amp;choice);
        if(choice == 1)
        {
            ElementType X;
            printf(&quot;输入进栈元素：&quot;);
            scanf(&quot;%d&quot;,&amp;X);
            if(Push(S,X))
                printf(&quot;\n元素进栈成功！\n&quot;);
        }
        else if(choice == 2)
        {
            ElementType X;
            X = Pop(S);
            if(X != ERROR)
                printf(&quot;出栈元素为%d\n&quot;,X);
        }
        else
            return 0;
    }
}
</code></pre>
<pre><code>（1）进栈 （2）出栈 （3）读栈顶 （4）退出
1
输入进栈元素：2

元素进栈成功！
（1）进栈 （2）出栈 （3）读栈顶 （4）退出
1
输入进栈元素：4

元素进栈成功！
（1）进栈 （2）出栈 （3）读栈顶 （4）退出
1
输入进栈元素：1

元素进栈成功！
（1）进栈 （2）出栈 （3）读栈顶 （4）退出
2
出栈元素为1
（1）进栈 （2）出栈 （3）读栈顶 （4）退出
2
出栈元素为4
（1）进栈 （2）出栈 （3）读栈顶 （4）退出
2
出栈元素为2
（1）进栈 （2）出栈 （3）读栈顶 （4）退出
2
栈已空！（1）进栈 （2）出栈 （3）读栈顶 （4）退出
4

Process returned 0 (0x0)   execution time : 18.576 s
Press any key to continue.
</code></pre>
<h2 id="实例pta6-7-在一个数组中实现两个堆栈"><a class="header" href="#实例pta6-7-在一个数组中实现两个堆栈">实例PTA6-7 在一个数组中实现两个堆栈</a></h2>
<p>本题要求在一个数组中实现两个堆栈。</p>
<p>函数接口定义：</p>
<pre><code class="language-c">Stack CreateStack( int MaxSize );
bool Push( Stack S, ElementType X, int Tag );
ElementType Pop( Stack S, int Tag );
</code></pre>
<p>其中<code>Tag</code>是堆栈编号，取1或2；<code>MaxSize</code>堆栈数组的规模；<code>Stack</code>结构定义如下：</p>
<pre><code class="language-c">typedef int Position;
struct SNode {
    ElementType *Data;
    Position Top1, Top2;
    int MaxSize;
};
typedef struct SNode *Stack;
</code></pre>
<p>注意：如果堆栈已满，<code>Push</code>函数必须输出“Stack Full”并且返回false；如果某堆栈是空的，则<code>Pop</code>函数必须输出“Stack Tag Empty”（其中Tag是该堆栈的编号），并且返回ERROR。</p>
<p>裁判测试程序样例：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define ERROR 1e8
typedef int ElementType;
typedef enum { push, pop, end } Operation;
typedef enum { false, true } bool;
typedef int Position;
struct SNode {
    ElementType *Data;
    Position Top1, Top2;
    int MaxSize;
};
typedef struct SNode *Stack;

Stack CreateStack( int MaxSize );
bool Push( Stack S, ElementType X, int Tag );
ElementType Pop( Stack S, int Tag );

Operation GetOp();  /* details omitted */
void PrintStack( Stack S, int Tag ); /* details omitted */

int main()
{
    int N, Tag, X;
    Stack S;
    int done = 0;

    scanf(&quot;%d&quot;, &amp;N);
    S = CreateStack(N);
    while ( !done ) {
        switch( GetOp() ) {
        case push: 
            scanf(&quot;%d %d&quot;, &amp;Tag, &amp;X);
            if (!Push(S, X, Tag)) printf(&quot;Stack %d is Full!\n&quot;, Tag);
            break;
        case pop:
            scanf(&quot;%d&quot;, &amp;Tag);
            X = Pop(S, Tag);
            if ( X==ERROR ) printf(&quot;Stack %d is Empty!\n&quot;, Tag);
            break;
        case end:
            PrintStack(S, 1);
            PrintStack(S, 2);
            done = 1;
            break;
        }
    }
    return 0;
}

/* 你的代码将被嵌在这里 */
</code></pre>
<p>输入样例：</p>
<pre><code class="language-in">5
Push 1 1
Pop 2
Push 2 11
Push 1 2
Push 2 12
Pop 1
Push 2 13
Push 2 14
Push 1 3
Pop 2
End
</code></pre>
<p>输出样例：</p>
<pre><code class="language-out">Stack 2 Empty
Stack 2 is Empty!
Stack Full
Stack 1 is Full!
Pop from Stack 1: 1
Pop from Stack 2: 13 12 11
</code></pre>
<p>能AC的代码如下：</p>
<pre><code class="language-c">Stack CreateStack( int MaxSize )
{
    Stack S = (Stack)malloc(sizeof(struct SNode));
    S-&gt;Data = (ElementType*)malloc(sizeof(ElementType)*MaxSize);
    S-&gt;Top1 = -1;
    S-&gt;Top2 = MaxSize;
    S-&gt;MaxSize = MaxSize;
    return S;
    
}
bool Push( Stack S, ElementType X, int Tag )
{
    if(S-&gt;Top1 + 1 == S-&gt;Top2)
    {
        printf(&quot;Stack Full\n&quot;);
        return false;
    }
    if(Tag == 1)
    {
        S-&gt;Data[++(S-&gt;Top1)] = X;
        return true;
    }
    else
    {
        S-&gt;Data[--(S-&gt;Top2)] = X;
        return true;
    }
    
}
ElementType Pop( Stack S, int Tag )
{
    if(Tag == 1)
    {
        if(S-&gt;Top1 == -1)
        {
            printf(&quot;Stack %d Empty\n&quot;,Tag);
            return ERROR;
        }
        else
            return (S-&gt;Data[(S-&gt;Top1)--]);
    }
    else
    {
        if(S-&gt;Top2 == S-&gt;MaxSize)
        {
            printf(&quot;Stack %d Empty\n&quot;,Tag);
            return ERROR;
        }
        else
            return (S-&gt;Data[(S-&gt;Top2)++]);
    }
}
</code></pre>
<h2 id="栈的链式存储实现"><a class="header" href="#栈的链式存储实现">栈的链式存储实现</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021510144.png" alt="" /></p>
<p>若用单向链表实现一个堆栈，只有<strong>链表的头可以作为top</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021547969.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021513985.png" alt="" /></p>
<p>《数据结构》课程给出的代码如下：</p>
<pre><code class="language-c">typedef struct SNode *PtrToSNode;
struct SNode {
    ElementType Data;
    PtrToSNode Next;
};
typedef PtrToSNode Stack;

Stack CreateStack( ) 
{ /* 构建一个堆栈的头结点，返回该结点指针 */
    Stack S;

    S = (Stack)malloc(sizeof(struct SNode));
    S-&gt;Next = NULL;
    return S;
}

bool IsEmpty ( Stack S )
{ /* 判断堆栈S是否为空，若是返回true；否则返回false */
    return ( S-&gt;Next == NULL );
}

bool Push( Stack S, ElementType X )
{ /* 将元素X压入堆栈S */
    PtrToSNode TmpCell;

    TmpCell = (PtrToSNode)malloc(sizeof(struct SNode));
    TmpCell-&gt;Data = X;
    TmpCell-&gt;Next = S-&gt;Next;
    S-&gt;Next = TmpCell;
    return true;
}

ElementType Pop( Stack S )  
{ /* 删除并返回堆栈S的栈顶元素 */
    PtrToSNode FirstCell;
    ElementType TopElem;

    if( IsEmpty(S) ) {
        printf(&quot;堆栈空&quot;); 
        return ERROR;
    }
    else {
        FirstCell = S-&gt;Next; 
        TopElem = FirstCell-&gt;Data;
        S-&gt;Next = FirstCell-&gt;Next;
        free(FirstCell);
        return TopElem;
    }
}
</code></pre>
<p>测试程序如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

#define ElementType int
#define ERROR -1
#define OK 0

typedef int Position;
typedef struct SNode *Stack;

struct SNode
{
    ElementType Data;
    Stack Next;
};

Stack CreateStack()
{
    Stack S = (Stack)malloc(sizeof(struct SNode));
    S-&gt;Next = NULL;
    return S;
}

bool Push(Stack PtrS,ElementType X)
{
    Stack TempCell = (Stack)malloc(sizeof(struct SNode));
    TempCell-&gt;Data = X;
    TempCell-&gt;Next = PtrS-&gt;Next;
    PtrS-&gt;Next = TempCell;
    return true;
}

bool IsEmpty(Stack S)
{
    return (S-&gt;Next == NULL);
}

ElementType Pop(Stack PtrS)
{
    Stack FirstCell;
    ElementType TopElem;

    if(IsEmpty(PtrS))
    {
        printf(&quot;栈已空！&quot;);
        return ERROR;
    }
    else
    {
        FirstCell = PtrS-&gt;Next;
        TopElem = FirstCell-&gt;Data;
        PtrS-&gt;Next = FirstCell-&gt;Next;
        free(FirstCell);
        return TopElem;
    }
}

int main()
{
    Stack S = CreateStack();
    int choice;
    while(1)
    {
        printf(&quot;（1）进栈 （2）出栈 （3）读栈顶 （4）退出\n&quot;);
        scanf(&quot;%d&quot;,&amp;choice);
        if(choice == 1)
        {
            ElementType X;
            printf(&quot;输入进栈元素：&quot;);
            scanf(&quot;%d&quot;,&amp;X);
            if(Push(S,X))
                printf(&quot;\n元素进栈成功！\n&quot;);
        }
        else if(choice == 2)
        {
            ElementType X;
            X = Pop(S);
            if(X != ERROR)
                printf(&quot;出栈元素为%d\n&quot;,X);
        }
        else
            return 0;
    }
}
</code></pre>
<pre><code>（1）进栈 （2）出栈 （3）读栈顶 （4）退出
1
输入进栈元素：2

元素进栈成功！
（1）进栈 （2）出栈 （3）读栈顶 （4）退出
1
输入进栈元素：3

元素进栈成功！
（1）进栈 （2）出栈 （3）读栈顶 （4）退出
1
输入进栈元素：1

元素进栈成功！
（1）进栈 （2）出栈 （3）读栈顶 （4）退出
2
出栈元素为1
（1）进栈 （2）出栈 （3）读栈顶 （4）退出
2
出栈元素为3
（1）进栈 （2）出栈 （3）读栈顶 （4）退出
2
出栈元素为2
（1）进栈 （2）出栈 （3）读栈顶 （4）退出
2
栈已空！（1）进栈 （2）出栈 （3）读栈顶 （4）退出
4

Process returned 0 (0x0)   execution time : 28.401 s
Press any key to continue.
</code></pre>
<h2 id="栈应用表达式求值"><a class="header" href="#栈应用表达式求值">栈应用：表达式求值</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021513692.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021514596.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021514830.png" alt="" /></p>
<p>左括号一旦放到堆栈中优先级就变为最低。碰到右括号（右括号不入栈）就把栈顶元素抛出，直到抛出左括号为止。<strong>注：括号是不会出现在后缀表达式或前缀表达式中的</strong></p>
<p>请试试应用堆栈将中缀表达式2*(6/3+4)-5转换为后缀表达式。在这个转换过程中，堆栈元素最多时元素个数是3。</p>
<p>借助堆栈将中缀表达式<code>A-(B-C/D)*E</code>转换为后缀表达式，则该堆栈的大小至少为：4</p>
<p>如果一堆栈的输入序列是aAbBc，输出为 abcBA，那么该堆栈所进行的操作序列是什么？ 设P代表入栈，O代表出栈。  POPPOPPOOO</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021514497.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021515284.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021515815.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021515575.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="队列queue"><a class="header" href="#队列queue">队列Queue</a></h1>
<ul>
<li><a href="%E9%98%9F%E5%88%97.html#%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0">队列的顺序存储实现</a></li>
<li><a href="%E9%98%9F%E5%88%97.html#%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0">队列的链式存储实现</a></li>
<li><a href="%E9%98%9F%E5%88%97.html#%E5%A6%82%E4%BD%95%E7%94%A8%E4%B8%A4%E4%B8%AA%E5%A0%86%E6%A0%88%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97">如何用两个堆栈模拟实现一个队列?</a></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311051520569.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311051522166.png" alt="" /></p>
<h2 id="队列的顺序存储实现"><a class="header" href="#队列的顺序存储实现">队列的顺序存储实现</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311051600042.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311051600901.png" alt="" /></p>
<p>这里对rear和front位置无要求。</p>
<p>如果空队列开始时front和rear值都是-1，当插入4个元素并删除2个元素后，front和rear值分别是多少？1和3</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311051601299.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311071815252.png" alt="" /></p>
<p>现采用大小为10的数组实现一个循环队列。设在某一时刻，队列为空且此时front和rear值均为5。经过若干操作后，front为8，rear为2，问：此时队列中有4个元素。</p>
<p>通用的队列长度计算公式：队列长度=（rear - front + MaxSize) % MaxSize</p>
<p>解释：front、rear方向一致，front指向实际存在的结点的前一个结点，rear指向实际存在的最后一个结点，此时队列中有9、0、1、2四个位置上的元素。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311051602307.png" alt="" /></p>
<p>《数据结构》课程给出的队列顺序存储实现方式如下：</p>
<pre><code class="language-c">typedef int Position;
struct QNode {
    ElementType *Data;     /* 存储元素的数组 */
    Position Front, Rear;  /* 队列的头、尾指针 */
    int MaxSize;           /* 队列最大容量 */
};
typedef struct QNode *Queue;

Queue CreateQueue( int MaxSize )
{
    Queue Q = (Queue)malloc(sizeof(struct QNode));
    Q-&gt;Data = (ElementType *)malloc(MaxSize * sizeof(ElementType));
    Q-&gt;Front = Q-&gt;Rear = 0;
    Q-&gt;MaxSize = MaxSize;
    return Q;
}

bool IsFull( Queue Q )
{
    return ((Q-&gt;Rear+1)%Q-&gt;MaxSize == Q-&gt;Front);
}

bool AddQ( Queue Q, ElementType X )
{
    if ( IsFull(Q) ) {
        printf(&quot;队列满&quot;);
        return false;
    }
    else {
        Q-&gt;Rear = (Q-&gt;Rear+1)%Q-&gt;MaxSize;
        Q-&gt;Data[Q-&gt;Rear] = X;
        return true;
    }
}

bool IsEmpty( Queue Q )
{
    return (Q-&gt;Front == Q-&gt;Rear);
}

ElementType DeleteQ( Queue Q )
{
    if ( IsEmpty(Q) ) { 
        printf(&quot;队列空&quot;);
        return ERROR;
    }
    else  {
        Q-&gt;Front =(Q-&gt;Front+1)%Q-&gt;MaxSize;
        return  Q-&gt;Data[Q-&gt;Front];
    }
}
</code></pre>
<p>测试程序如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

#define ERROR 0

typedef int ElementType;

typedef struct QNode *Queue;

struct QNode
{
    ElementType *Data;
    int MaxSize;
    int front;
    int rear;
};

Queue CreateQueue(int MaxSize)
{
    Queue q = (Queue)malloc(sizeof(struct QNode));
    q-&gt;Data = (ElementType*)malloc(sizeof(ElementType)*MaxSize);
    q-&gt;front = 0;
    q-&gt;rear = 0;
    q-&gt;MaxSize = MaxSize;
    return q;
}

bool IsFullQ(Queue q)
{
    return (((q-&gt;rear+1)%q-&gt;MaxSize) == q-&gt;front);
}


bool AddQ(Queue q,ElementType item)
{
    if(IsFullQ(q))
    {
        printf(&quot;队列已满\n&quot;);
        return false;
    }
    else
    {
        q-&gt;rear = (q-&gt;rear+1)%(q-&gt;MaxSize);
        q-&gt;Data[q-&gt;rear] = item;
        return true;
    }
}

bool IsEmptyQ(Queue q)
{
    return (q-&gt;rear == q-&gt;front);
}

ElementType DeleteQ(Queue q)
{
    if(IsEmptyQ(q))
    {
        printf(&quot;队列为空\n&quot;);
        return ERROR;
    }
    else
    {
        q-&gt;front = (q-&gt;front+1)%(q-&gt;MaxSize);
        return (q-&gt;Data[q-&gt;front]);
    }
}

int main()
{
    Queue q = CreateQueue(10);
    int choice;

    while(1)
    {
        printf(&quot;输入1添加1个元素，输入2删除1个元素，输入0结束循环\n&quot;);
        scanf(&quot;%d&quot;,&amp;choice);
        if(choice == 1)
        {
            ElementType X;
            scanf(&quot;%d&quot;,&amp;X);
            AddQ(q,X);
        }
        else if(choice == 2)
        {
            ElementType X = DeleteQ(q);
            printf(&quot;%d\n&quot;,X);
        }
        else
            return 0;
    }

}
</code></pre>
<pre><code>输入1添加1个元素，输入2删除1个元素，输入0结束循环
1
2
输入1添加1个元素，输入2删除1个元素，输入0结束循环
1
3
输入1添加1个元素，输入2删除1个元素，输入0结束循环
1
1
输入1添加1个元素，输入2删除1个元素，输入0结束循环
1
4
输入1添加1个元素，输入2删除1个元素，输入0结束循环
1
5
输入1添加1个元素，输入2删除1个元素，输入0结束循环
1
6
输入1添加1个元素，输入2删除1个元素，输入0结束循环
2
2
输入1添加1个元素，输入2删除1个元素，输入0结束循环
2
3
输入1添加1个元素，输入2删除1个元素，输入0结束循环
2
1
输入1添加1个元素，输入2删除1个元素，输入0结束循环
2
4
输入1添加1个元素，输入2删除1个元素，输入0结束循环
2
5
输入1添加1个元素，输入2删除1个元素，输入0结束循环
2
6
输入1添加1个元素，输入2删除1个元素，输入0结束循环
2
队列为空
0
输入1添加1个元素，输入2删除1个元素，输入0结束循环
0

Process returned 0 (0x0)   execution time : 56.625 s
Press any key to continue.
</code></pre>
<h2 id="队列的链式存储实现"><a class="header" href="#队列的链式存储实现">队列的链式存储实现</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311051608152.png" alt="" /></p>
<p>队列的front只能设在链表头部。如果front放在链表尾部，删除当前结点后无法找到上一个结点。</p>
<p>在一个链表表示的队列中， f和r分别指向队列的头和尾。<code>r-&gt;next=s; r=s;</code>能正确地将s结点插入到队列中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311051608220.png" alt="" /></p>
<p>《数据结构》课程给出的队列链式存储实现方式如下：</p>
<pre><code class="language-c">typedef struct Node *PtrToNode;
struct Node { /* 队列中的结点 */
    ElementType Data;
    PtrToNode Next;
};
typedef PtrToNode Position;

struct QNode {
    Position Front, Rear;  /* 队列的头、尾指针 */
    int MaxSize;           /* 队列最大容量 */
};
typedef struct QNode *Queue;

bool IsEmpty( Queue Q )
{
    return ( Q-&gt;Front == NULL);
}

ElementType DeleteQ( Queue Q )
{
    Position FrontCell; 
    ElementType FrontElem;
    
    if  ( IsEmpty(Q) ) {
        printf(&quot;队列空&quot;);
        return ERROR;
    }
    else {
        FrontCell = Q-&gt;Front;
        if ( Q-&gt;Front == Q-&gt;Rear ) /* 若队列只有一个元素 */
            Q-&gt;Front = Q-&gt;Rear = NULL; /* 删除后队列置为空 */
        else                     
            Q-&gt;Front = Q-&gt;Front-&gt;Next;
        FrontElem = FrontCell-&gt;Data;

        free( FrontCell );  /* 释放被删除结点空间  */
        return  FrontElem;
    }
}
</code></pre>
<p>测试程序如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;assert.h&gt;
#define ERROR 0

typedef int ElementType;

typedef struct Node *PtrToNode;

struct Node
{
    ElementType Data;
    PtrToNode Next;
};

PtrToNode CreateNode(ElementType Data)
{
    PtrToNode newNode = (PtrToNode)malloc(sizeof(struct Node));
    assert(newNode);
    newNode-&gt;Data = Data;
    newNode-&gt;Next = NULL;
    return newNode;
}

typedef PtrToNode Position;

typedef struct QNode *Queue;

struct QNode
{
    PtrToNode Front,Rear;
    int curSize;
};

Queue CreateQueue()
{
    Queue q = (Queue)malloc(sizeof(struct QNode));
    assert(q);
    q-&gt;curSize = 0;
    q-&gt;Front = q-&gt;Rear = NULL;
    return q;
}

void AddQ(Queue q,ElementType item)
{
    //PtrToNode s = (PtrToNode)malloc(sizeof(struct Node));
    //s-&gt;Data = item;
    //s-&gt;Next = NULL;
    PtrToNode s = CreateNode(item);
    if(q-&gt;curSize == 0)
        q-&gt;Front = s;
    else
        q-&gt;Rear-&gt;Next = s;
    q-&gt;Rear = s;
    q-&gt;curSize++;
}
bool IsEmptyQ(Queue q)
{
    return (q-&gt;Front == NULL);
}

ElementType DeleteQ(Queue q)
{
    PtrToNode FrontCell;
    ElementType FrontElem;
    if(IsEmptyQ(q))
    {
        printf(&quot;队列空!\n&quot;);
        return ERROR;
    }
    else
    {
        FrontCell = q-&gt;Front;
        if(q-&gt;Front == q-&gt;Rear)
            q-&gt;Front = q-&gt;Rear = NULL;
        else
            q-&gt;Front = q-&gt;Front-&gt;Next;
        FrontElem = FrontCell-&gt;Data;
        free(FrontCell);
        q-&gt;curSize--;
        return FrontElem;
    }

}

int main()
{
    Queue q = CreateQueue();
    int choice;

    while(1)
    {
        printf(&quot;输入1添加1个元素，输入2删除1个元素，输入0结束循环\n&quot;);
        scanf(&quot;%d&quot;,&amp;choice);
        if(choice == 1)
        {
            ElementType X;
            scanf(&quot;%d&quot;,&amp;X);
            AddQ(q,X);
        }
        else if(choice == 2)
        {
            ElementType X = DeleteQ(q);
            printf(&quot;%d\n&quot;,X);
        }
        else
            return 0;
    }

}
</code></pre>
<pre><code>输入1添加1个元素，输入2删除1个元素，输入0结束循环
1
2
输入1添加1个元素，输入2删除1个元素，输入0结束循环
1
3
输入1添加1个元素，输入2删除1个元素，输入0结束循环
1
4
输入1添加1个元素，输入2删除1个元素，输入0结束循环
1
5
输入1添加1个元素，输入2删除1个元素，输入0结束循环
2
2
输入1添加1个元素，输入2删除1个元素，输入0结束循环
2
3
输入1添加1个元素，输入2删除1个元素，输入0结束循环
2
4
输入1添加1个元素，输入2删除1个元素，输入0结束循环
2
5
输入1添加1个元素，输入2删除1个元素，输入0结束循环
2
队列空!
0
输入1添加1个元素，输入2删除1个元素，输入0结束循环
0

Process returned 0 (0x0)   execution time : 22.052 s
Press any key to continue.
</code></pre>
<h2 id="如何用两个堆栈模拟实现一个队列"><a class="header" href="#如何用两个堆栈模拟实现一个队列">如何用两个堆栈模拟实现一个队列?</a></h2>
<p>如何用两个堆栈模拟实现一个队列?  如果这两个堆栈的容量分别是m和n（m&gt;n)，你的方法能保证的队列容量是多少？</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="mooc-pta线性结构题目"><a class="header" href="#mooc-pta线性结构题目">MOOC-PTA线性结构题目</a></h1>
<ul>
<li><a href="MOOC-PTA%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E9%A2%98%E7%9B%AE.html#pta-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%841-%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%BA%8F%E5%88%97%E7%9A%84%E5%90%88%E5%B9%B6">PTA 02-线性结构1 两个有序链表序列的合并</a></li>
<li><a href="MOOC-PTA%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E9%A2%98%E7%9B%AE.html#pta02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%842-%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E4%B9%98%E6%B3%95%E4%B8%8E%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97">PTA02-线性结构2 一元多项式的乘法与加法运算</a></li>
<li><a href="MOOC-PTA%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E9%A2%98%E7%9B%AE.html#pta-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%843-reversing-linked-list">PTA 02-线性结构3 Reversing Linked List</a></li>
<li><a href="MOOC-PTA%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E9%A2%98%E7%9B%AE.html#pta-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%844-pop-sequence">PTA 02-线性结构4 Pop Sequence</a></li>
</ul>
<h2 id="pta-02-线性结构1-两个有序链表序列的合并"><a class="header" href="#pta-02-线性结构1-两个有序链表序列的合并">PTA 02-线性结构1 两个有序链表序列的合并</a></h2>
<p>本题要求实现一个函数，将两个链表表示的递增整数序列合并为一个非递减的整数序列。</p>
<p>函数接口定义：</p>
<pre><code class="language-c">List Merge( List L1, List L2 );
</code></pre>
<p>其中<code>List</code>结构定义如下：</p>
<pre><code class="language-c">typedef struct Node *PtrToNode;
struct Node {
    ElementType Data; /* 存储结点数据 */
    PtrToNode   Next; /* 指向下一个结点的指针 */
};
typedef PtrToNode List; /* 定义单链表类型 */
</code></pre>
<p><code>L1</code>和<code>L2</code>是给定的带头结点的单链表，其结点存储的数据是递增有序的；函数<code>Merge</code>要将<code>L1</code>和<code>L2</code>合并为一个非递减的整数序列。应直接使用原序列中的结点，返回归并后的带头结点的链表头指针。</p>
<p>裁判测试程序样例：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef int ElementType;
typedef struct Node *PtrToNode;
struct Node {
    ElementType Data;
    PtrToNode   Next;
};
typedef PtrToNode List;

List Read(); /* 细节在此不表 */
void Print( List L ); /* 细节在此不表；空链表将输出NULL */

List Merge( List L1, List L2 );

int main()
{
    List L1, L2, L;
    L1 = Read();
    L2 = Read();
    L = Merge(L1, L2);
    Print(L);
    Print(L1);
    Print(L2);
    return 0;
}

/* 你的代码将被嵌在这里 */
</code></pre>
<p>输入样例：</p>
<pre><code>3
1 3 5
5
2 4 6 8 10
</code></pre>
<p>输出样例：</p>
<pre><code>1 2 3 4 5 6 8 10 
NULL
NULL
</code></pre>
<p>能AC的代码如下：</p>
<pre><code class="language-c">List Merge( List L1, List L2 )
{
    if(L1 == NULL || L2 == NULL)
        return (L1 == NULL)?L2:L1;
    List head = (List)malloc(sizeof(struct Node));
    List cur1 = L1-&gt;Next;
    List cur2 = L2-&gt;Next;
    List pre = head;
    while(cur1 != NULL &amp;&amp; cur2 != NULL)
    {
        if(cur1-&gt;Data &lt;= cur2-&gt;Data)
        {
            pre-&gt;Next = cur1;
            cur1 = cur1-&gt;Next;
        }
        else
        {
            pre-&gt;Next = cur2;
            cur2 = cur2-&gt;Next;
        }
        pre = pre-&gt;Next;
    }
    pre-&gt;Next = (cur1 != NULL)?cur1:cur2;
    L1-&gt;Next = NULL;
    L2-&gt;Next = NULL;
    return head;

}
</code></pre>
<h2 id="pta02-线性结构2-一元多项式的乘法与加法运算"><a class="header" href="#pta02-线性结构2-一元多项式的乘法与加法运算">PTA02-线性结构2 一元多项式的乘法与加法运算</a></h2>
<p>设计函数分别求两个一元多项式的乘积与和。</p>
<p>输入格式:</p>
<p>输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。</p>
<p>输出格式:</p>
<p>输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出<code>0 0</code>。</p>
<p>输入样例:</p>
<pre><code>4 3 4 -5 2  6 1  -2 0
3 5 20  -7 4  3 1
</code></pre>
<p>输出样例:</p>
<pre><code>15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 1
5 20 -4 4 -5 2 9 1 -2 0
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311042023348.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311042023470.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311042023690.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311042024293.png" alt="" /></p>
<p>如果当前p1指向项的（系数，指数）为（2，4），同时P2指向项为(2，6)，那么循环中的switch是执行case -1。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311042024746.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311091547345.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct PolyNode *Polynomial;
struct PolyNode
{
    int coef;
    int expon;
    Polynomial link;
};

Polynomial ReadPoly()
{
    Polynomial P,Rear,temp;
    int n,e,c;
    scanf(&quot;%d&quot;,&amp;n);
    P = (Polynomial)malloc(sizeof(struct PolyNode));
    P-&gt;link = NULL;
    Rear = P;
    while(n--)
    {
        scanf(&quot;%d %d&quot;,&amp;c,&amp;e);
        Attach(c,e,&amp;Rear);
    }
    temp = P;
    P = P-&gt;link;
    free(temp);
    return P;
}

void Attach(int c,int e,Polynomial *pRear)
{
    Polynomial P = (Polynomial)malloc(sizeof(struct PolyNode));
    P-&gt;coef = c;
    P-&gt;expon = e;
    P-&gt;link = NULL;
    (*pRear)-&gt;link = P;
    *pRear = P;
}

int Compare(int a,int b)
{
    if(a&gt;b)
        return 1;
    else if(a&lt;b)
        return -1;
    else
        return 0;
}
/*
Polynomial AddPoly(Polynomial P1,Polynomial P2)
{
    Polynomial front,rear,temp;
    int sum = 0;
    rear = (Polynomial)malloc(sizeof(struct PolyNode));
    front = rear;
    while(P1&amp;&amp;P2)
    {
        switch(Compare(P1-&gt;expon,P2-&gt;expon))
        {
        case 1:
            Attach(P1-&gt;coef,P1-&gt;expon,&amp;rear);
            P1 = P1-&gt;link;
            break;
        case -1:
            Attach(P2-&gt;coef,P2-&gt;expon,&amp;rear);
            P2 = P2-&gt;link;
            break;
        case 0:
            sum = P1-&gt;coef + P2-&gt;coef;
            if(sum)
                Attach(sum,P1-&gt;expon,&amp;rear);
            P1 = P1-&gt;link;
            P2 = P2-&gt;link;
            break;
        }
        for(;P1;P1 = P1-&gt;link)
            Attach(P1-&gt;coef,P1-&gt;expon,&amp;rear);
        for(;P2;P2 = P2-&gt;link)
            Attach(P2-&gt;coef,P2-&gt;expon,&amp;rear);
        rear-&gt;link = NULL;
        temp = front;
        front = front-&gt;link;
        free(temp);
        return front;

    }
}

*/


Polynomial AddPoly(Polynomial P1,Polynomial P2)
{
    Polynomial t1,t2,P,Rear,temp;
    int sum;
    t1 = P1;
    t2 = P2;
    P = (Polynomial)malloc(sizeof(struct PolyNode));
    P-&gt;link = NULL;
    Rear = P;
    while(t1&amp;&amp;t2)
    {
        if(t1-&gt;expon == t2-&gt;expon)
        {
            sum = t1-&gt;coef + t2-&gt;coef;
            if(sum)
                Attach(sum,t1-&gt;expon,&amp;Rear);
            t1 = t1-&gt;link;
            t2 = t2-&gt;link;
        }
        else if(t1-&gt;expon &gt; t2-&gt;expon)
        {
            Attach(t1-&gt;coef,t1-&gt;expon,&amp;Rear);
            t1 = t1-&gt;link;
        }
        else
        {
            Attach(t2-&gt;coef,t2-&gt;expon,&amp;Rear);
            t2 = t2-&gt;link;
        }
    }
    while(t1)
    {
        Attach(t1-&gt;coef,t1-&gt;expon,&amp;Rear);
        t1 = t1-&gt;link;
    }
    while(t2)
    {
        Attach(t2-&gt;coef,t2-&gt;expon,&amp;Rear);
        t2 = t2-&gt;link;
    }
    Rear-&gt;link = NULL;
    temp = P;
    P = P-&gt;link;
    free(temp);
    return P;
}

Polynomial MultPoly(Polynomial P1,Polynomial P2)
{
    Polynomial t1,t2,temp,P,Rear;
    int c,e;
    if(!P1 || !P2)
        return NULL;
    t1 = P1;
    t2 = P2;
    P = (Polynomial)malloc(sizeof(struct PolyNode));
    P-&gt;link = NULL;
    Rear = P;
    while(t2)
    {
        Attach(t1-&gt;coef * t2-&gt;coef,t1-&gt;expon + t2-&gt;expon,&amp;Rear);
        t2 = t2-&gt;link;
    }
    t1 = t1-&gt;link;
    while(t1)
    {
        t2 = P2;
        Rear = P;
        while(t2)
        {
            e = t1-&gt;expon + t2-&gt;expon;
            c = t1-&gt;coef * t2-&gt;coef;
            while(Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon &gt; e)
                Rear = Rear-&gt;link;
            if(Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon == e)
            {
                if(Rear-&gt;link-&gt;coef + c)
                    Rear-&gt;link-&gt;coef += c;
                else
                {
                    temp = Rear-&gt;link;
                    Rear-&gt;link = temp-&gt;link;
                    free(temp);
                }
            }
            else
            {
                temp = (Polynomial)malloc(sizeof(struct PolyNode));
                temp-&gt;coef = c;
                temp-&gt;expon = e;
                temp-&gt;link = Rear-&gt;link;
                Rear-&gt;link = temp;
                Rear = Rear-&gt;link;
            }
            t2 = t2-&gt;link;
        }
        t1 = t1-&gt;link;
    }
    t2 = P;
    P = P-&gt;link;
    free(t2);
    return P;

}

void PrintPoly(Polynomial P)
{
    int flag = 0;
    if(!P)
    {
        printf(&quot;0 0\n&quot;);
        return;
    }
    while(P)
    {
        if(!flag)
            flag = 1;
        else
            printf(&quot; &quot;);
        printf(&quot;%d %d&quot;,P-&gt;coef,P-&gt;expon);
        P = P-&gt;link;
    }
    printf(&quot;\n&quot;);
}

int main()
{
    Polynomial P1,P2,PP,PS;
    P1 = ReadPoly();
    P2 = ReadPoly();
    PP = MultPoly(P1,P2);
    PrintPoly(PP);
    PS = AddPoly(P1,P2);
    PrintPoly(PS);
    return 0;

}
</code></pre>
<h2 id="pta-02-线性结构3-reversing-linked-list"><a class="header" href="#pta-02-线性结构3-reversing-linked-list">PTA 02-线性结构3 Reversing Linked List</a></h2>
<p>Given a constant K and a singly linked list L, you are supposed to reverse the links of every K elements on L. For example, given L being 1→2→3→4→5→6, if K=3, then you must output 3→2→1→6→5→4; if K=4, you must output 4→3→2→1→5→6.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line contains the address of the first node, a positive N (≤105) which is the total number of nodes, and a positive K (≤N) which is the length of the sublist to be reversed. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1.</p>
<p>Then N lines follow, each describes a node in the format:</p>
<pre><code>Address Data Next
</code></pre>
<p>where <code>Address</code> is the position of the node, <code>Data</code> is an integer, and <code>Next</code> is the position of the next node.</p>
<p>Output Specification:</p>
<p>For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input.</p>
<p>Sample Input:</p>
<pre><code>00100 6 4
00000 4 99999
00100 1 12309
68237 6 -1
33218 3 00000
99999 5 68237
12309 2 33218
</code></pre>
<p>Sample Output:</p>
<pre><code>00000 4 33218
33218 3 12309
12309 2 00100
00100 1 99999
99999 5 68237
68237 6 -1
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312131450347.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312131451609.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312131451508.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef int Address;
typedef int Data;
typedef struct Node *Ptr;
#define MaxSize 100001

struct Node
{
    Data data;
    Address next;
}Nodes[MaxSize];

int List[MaxSize];

void Reverse(Address head, Address tail)
{
    int tempHead = head;
    int tempTail = tail;
    int list;
    while(tempTail &gt; tempHead)
    {
        list = List[tempHead];
        List[tempHead] = List[tempTail];
        List[tempTail] = list;
        tempHead++;
        tempTail--;
    }
}


int main()
{
    int n;
    Address root;
    int K;
    scanf(&quot;%d %d %d&quot;,&amp;root,&amp;n,&amp;K);
    Address address;
    Data data;
    Address next;
    for(int i=0; i&lt;n; i++)
    {
        scanf(&quot;%d %d %d&quot;, &amp;address,&amp;data,&amp;next);
        Nodes[address].data = data;
        Nodes[address].next = next;
    }
    int maxn = 0;
    int pMove = root;
    while(pMove != -1)
    {
        List[maxn++] = pMove;
        pMove = Nodes[pMove].next;
    }
    int i = 0;
    while(i + K &lt; maxn)
    {
        Reverse(i,i+K-1);
        i = i + K;
    }
    for(i=0;i&lt;maxn-1;i++)
        printf(&quot;%05d %d %05d\n&quot;,List[i],Nodes[List[i]].data,List[i+1]);
    printf(&quot;%05d %d -1\n&quot;,List[i],Nodes[List[i]].data);
    return 0;
}
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312131634780.png" alt="" /></p>
<p>使用C++的reverse函数解法如下：</p>
<pre><code class="language-c">#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;    ///使用到reverse 翻转函数
using namespace std;
 
#define MAXSIZE 1000010   ///最大为五位数的地址
 
struct node    ///使用顺序表存储data和下一地址next
{
   int data;   
   int next;
}node[MAXSIZE];
 
int List[MAXSIZE];   ///存储可以连接上的顺序表
int main()
{
    int First, n, k;  
    cin&gt;&gt;First&gt;&gt;n&gt;&gt;k;   ///输入头地址 和 n，k；
    int Address,Data,Next;
    for(int i=0;i&lt;n;i++)
    {
        cin&gt;&gt;Address&gt;&gt;Data&gt;&gt;Next;
        node[Address].data=Data;
        node[Address].next=Next;
    }
 
    int j=0;  ///j用来存储能够首尾相连的节点数
    int p=First;   ///p指示当前结点
    while(p!=-1)
    {
        List[j++]=p;
        p=node[p].next;
    }
    int i=0;
    while(i+k&lt;=j)   ///每k个节点做一次翻转
    {
        reverse(&amp;List[i],&amp;List[i+k]);
        i=i+k;
    }
    for(i=0;i&lt;j-1;i++)
        printf(&quot;%05d %d %05d\n&quot;,List[i],node[List[i]].data,List[i+1]);
    printf(&quot;%05d %d -1\n&quot;,List[i],node[List[i]].data);
    return 0;
}
</code></pre>
<h2 id="pta-02-线性结构4-pop-sequence"><a class="header" href="#pta-02-线性结构4-pop-sequence">PTA 02-线性结构4 Pop Sequence</a></h2>
<p>Given a stack which can keep M numbers at most. Push N numbers in the order of 1, 2, 3, ..., N and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if M is 5 and N is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): M (the maximum capacity of the stack), N (the length of push sequence), and K (the number of pop sequences to be checked). Then K lines follow, each contains a pop sequence of N numbers. All the numbers in a line are separated by a space.</p>
<p>Output Specification:</p>
<p>For each pop sequence, print in one line &quot;YES&quot; if it is indeed a possible pop sequence of the stack, or &quot;NO&quot; if not.</p>
<p>Sample Input:</p>
<p><code>5 7 5 1 2 3 4 5 6 7 3 2 1 7 5 6 4 7 6 5 4 3 2 1 5 6 4 3 7 2 1 1 7 6 5 4 3 2   </code></p>
<p>Sample Output:</p>
<pre><code class="language-out">YES
NO
NO
YES
NO
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define Maxsize 1000//最大容量
typedef struct Node
{
    int Top;//栈顶
    int Data[Maxsize];//元素
    int Capacity;//容量
}*Stack;

int Test(int Array[],int M,int N)
{
    int count = 0;
    Stack Pile = (Stack)malloc(sizeof(struct Node));//申请并初始化一个空栈
    Pile-&gt;Capacity = M;
    Pile-&gt;Top = -1;
    for(int i = 1;i &lt;= N;i++)
    {
        if(Pile-&gt;Capacity == Pile-&gt;Top+1)//栈满
            return 0;
        else
            Pile-&gt;Data[++Pile-&gt;Top] = i;//入栈
        while(Pile-&gt;Data[Pile-&gt;Top] == Array[count])
        {//比较栈顶是否与某数相等
            Pile-&gt;Top--;//出栈
            count++;//数组往后移位
        }
    }
    if(count == N)//全部找到并且输出时
        return 1;
    else
        return 0;
}

int main()
{
    int M,N,K;
    scanf(&quot;%d %d %d&quot;,&amp;M,&amp;N,&amp;K);
    int Array[N];
    for(int i=0; i&lt;K; i++)
    {
        for(int j=0; j&lt;N; j++)
        {
            scanf(&quot;%d&quot;,&amp;Array[j]);
        }
        if(Test(Array,M,N))
            printf(&quot;YES\n&quot;);
        else
            printf(&quot;NO\n&quot;);
    }
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<ul>
<li><a href="%E6%A0%91.html#%E5%BC%95%E5%AD%90%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">引子：二分查找</a></li>
<li><a href="%E6%A0%91.html#%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89">树的定义</a></li>
</ul>
<h2 id="引子二分查找"><a class="header" href="#引子二分查找">引子：二分查找</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311071516238.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311071517513.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311071517306.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311071518809.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311071518159.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311071520969.png" alt="" /></p>
<pre><code class="language-c">int BinarySearch(StaticTable *Tbl,ElementType K)
{
    int left,right,mid,NotFound = -1;
    left = 1;
    right = Tbl-&gt;Length;

    while(left &lt;= right)
    {
        mid = (left + right) / 2;
        if(K &gt; Tbl-&gt;Element[mid])
            left = mid + 1;
        else if(K &lt; Tbl-&gt;Element[mid])
            right = mid - 1;
        else
            return mid;
    }
    return NotFound;
}
</code></pre>
<p>在分量1~11的数组中按从小到大顺序存放11个元素，如果用顺序查找和二分查找分别查找这11个元素，哪个位置的元素在这两种方法的查找中总次数最少？1</p>
<p>在分量1~11的数组中按从小到大顺序存放11个元素，如果进行二分查找，查找次数最少的元素位于什么位置？6</p>
<p>测试程序如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int OrderSearch(int arr[],int n,int x)
{
    for(int i = 0 ; i &lt; n; i++)
    {
        if(x == arr[i])
            return i;
    }
    return -1;
}

int BinarySearch(int arr[],int n,int x)
{
    int left = 0;
    int right = n-1;
    int mid;
    while(left &lt;= right)
    {
        mid = (left + right) / 2;
        if(arr[mid] &lt; x)
            left = mid + 1;
        else if(arr[mid] &gt; x)
            right = mid - 1;
        else
            return mid;
    }
    return -1;
}

int main()
{
    int n = 10;
    int arr[10] = {1,2,3,4,5,6,7,8,9,10};
    int x = 3;
    printf(&quot;%d\n&quot;,BinarySearch(arr,n,x));
    printf(&quot;%d\n&quot;,OrderSearch(arr,n,x));
    return 0;
}
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311071525846.png" alt="" /></p>
<p>ASL：Average Search Length平均查找长度</p>
<h2 id="树的定义"><a class="header" href="#树的定义">树的定义</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311071534677.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311071534726.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311071535966.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311071535157.png" alt="" /></p>
<p>有一个m棵树的集合（也叫森林）共有k条边，问这m颗树共有多少个结点？k+m</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311071536714.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311071537314.png" alt="" /></p>
<p>在用“儿子-兄弟”法表示的树中，如果从根结点开始访问其“次子”的“次子”，所经过的结点数与从根结点开始访问其“长子”的“长子”的“长子”的“长子”一样。(注意:比较的是结点数,而不是路径)</p>
<p>一棵度为 m的树有n个节点。若每个节点直接用m个链指向相应的儿子，则表示这个树所需要的总空间是n*(m+1) (假定每个链以及表示节点的数据域都是一个单位空间).。当采用儿子/兄弟（First Child/Next Sibling）表示法时，所需的总空间是：3n</p>
<p>树的集合称为森林。是否也可以使用“儿子-兄弟”表示法存储森林？如何实现？</p>
<p>是的，可以使用&quot;儿子-兄弟&quot;表示法（又称作&quot;左孩子-右兄弟&quot;表示法或&quot;孩子兄弟链表&quot;）来存储森林，其中每个节点表示一棵树。这种表示法适用于多叉树和森林结构，它使用两个指针来表示树中的节点之间的关系：左孩子指针和右兄弟指针。左孩子指针指向当前节点的第一个子节点，而右兄弟指针指向当前节点的兄弟节点。</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="二叉树"><a class="header" href="#二叉树">二叉树</a></h1>
<ul>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89">二叉树的定义</a></li>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">二叉树的存储结构</a></li>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA">二叉树的创建</a>
<ul>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%9D%9E%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F">非递归方式</a></li>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F">递归方式</a></li>
</ul>
</li>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86">二叉树的遍历</a></li>
</ul>
<h2 id="二叉树的定义"><a class="header" href="#二叉树的定义">二叉树的定义</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311101639161.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311101640282.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311101640953.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311101641998.png" alt="" /></p>
<h2 id="二叉树的存储结构"><a class="header" href="#二叉树的存储结构">二叉树的存储结构</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311101641616.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311101642386.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311101642383.png" alt="" /></p>
<p>链表结构：</p>
<pre><code class="language-c">typedef struct TNode *Position;
typedef Position BinTree; /* 二叉树类型 */
struct TNode{ /* 树结点定义 */
    ElementType Data; /* 结点数据 */
    BinTree Left;     /* 指向左子树 */
    BinTree Right;    /* 指向右子树 */
};
</code></pre>
<p>包含较多别名的写法如下：</p>
<pre><code class="language-c">typedef struct treenode
{
    char data;
    struct treenode* LChild;
    struct treenode* RChild;
}NODE,*LPNODE,*LPTREE;

//struct treenode : NODE
//struct treenode* : LPNODE或LPTREE
NODE node1;
struct treenode* p = NULL;
LPNODE p1 = NULL;
</code></pre>
<h2 id="二叉树的创建"><a class="header" href="#二叉树的创建">二叉树的创建</a></h2>
<h3 id="非递归方式"><a class="header" href="#非递归方式">非递归方式</a></h3>
<p>实现代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct TreeNode *LPNODE;
typedef LPNODE BinTree;
typedef char ElementType;

struct TreeNode
{
    ElementType Data;
    BinTree Left;
    BinTree Right;
};

LPNODE CreateNode(ElementType Data)
{
    LPNODE newNode = (LPNODE)malloc(sizeof(struct TreeNode));
    newNode-&gt;Left = NULL;
    newNode-&gt;Right = NULL;
    newNode-&gt;Data = Data;
    return newNode;
}

/* 非递归创建树 */
void InsertNode(BinTree parent, LPNODE Left, LPNODE Right)
{
    parent-&gt;Left = Left;
    parent-&gt;Right = Right;
}

void PreOrderTraversal(BinTree BT)
{
    if(BT)
    {
        printf(&quot;%c &quot;,BT-&gt;Data);
        PreOrderTraversal(BT-&gt;Left);
        PreOrderTraversal(BT-&gt;Right);
    }
}

void InOrderTraversal(BinTree BT)
{
    if(BT)
    {
        InOrderTraversal(BT-&gt;Left);
        printf(&quot;%c &quot;,BT-&gt;Data);
        InOrderTraversal(BT-&gt;Right);
    }
}

void PostOrderTraversal(BinTree BT)
{
    if(BT)
    {
        PostOrderTraversal(BT-&gt;Left);
        PostOrderTraversal(BT-&gt;Right);
        printf(&quot;%c &quot;,BT-&gt;Data);
    }
}

int main()
{
    LPNODE A = CreateNode('A');
    LPNODE B = CreateNode('B');
    LPNODE C = CreateNode('C');
    LPNODE D = CreateNode('D');
    LPNODE E = CreateNode('E');
    LPNODE F = CreateNode('F');
    InsertNode(A,B,C);
    InsertNode(B,D,NULL);
    InsertNode(C,E,NULL);
    InsertNode(E,NULL,F);
    PreOrderTraversal(A);
    printf(&quot;\n&quot;);
    InOrderTraversal(A);
    printf(&quot;\n&quot;);
    PostOrderTraversal(A);
    printf(&quot;\n&quot;);
    return 0;
}
</code></pre>
<pre><code>A B D C E F
D B A E F C
D B F E C A
</code></pre>
<h3 id="递归方式"><a class="header" href="#递归方式">递归方式</a></h3>
<p>实现代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef char ElementType;

typedef struct TreeNode
{
    ElementType Data;
    struct TreeNode* Left;
    struct TreeNode* Right;
}NODE,*LPNODE,*LPTREE;

/* 递归创建树 */
void createTree(LPTREE* root)
{
    char userKey = '\0';
    scanf_s(&quot;%c&quot;,&amp;userKey,1);
    if(userKey == '#')
    {
        *root = NULL;
    }
    else
    {
        *root = (LPTREE)malloc(sizeof(struct TreeNode));
        (*root)-&gt;Data = userKey;
        createTree(&amp;(*root)-&gt;Left);
        createTree(&amp;(*root)-&gt;Right);
    }
}

void PreOrderTraversal(LPTREE BT)
{
    if(BT)
    {
        printf(&quot;%c &quot;,BT-&gt;Data);
        PreOrderTraversal(BT-&gt;Left);
        PreOrderTraversal(BT-&gt;Right);
    }
}

int main()
{
    LPTREE root = NULL;
    createTree(&amp;root);
    printf(&quot;PreOrderTraversal:\n&quot;);
    PreOrderTraversal(root);
    printf(&quot;\n&quot;);
    return 0;
}
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311111523681.png" alt="" /></p>
<pre><code>ABD###CE#F###
PreOrderTraversal:
A B D C E F
</code></pre>
<h2 id="二叉树的遍历"><a class="header" href="#二叉树的遍历">二叉树的遍历</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311101506933.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311101508256.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311101511971.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311101512108.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311101516043.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311101521105.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct TreeNode *LPNODE;
typedef LPNODE BinTree;
typedef char ElementType;

struct TreeNode
{
    ElementType Data;
    BinTree Left;
    BinTree Right;
};

LPNODE CreateNode(ElementType Data)
{
    LPNODE newNode = (LPNODE)malloc(sizeof(struct TreeNode));
    newNode-&gt;Left = NULL;
    newNode-&gt;Right = NULL;
    newNode-&gt;Data = Data;
    return newNode;
}

void InsertNode(BinTree parent, LPNODE Left, LPNODE Right)
{
    parent-&gt;Left = Left;
    parent-&gt;Right = Right;
}

void PreOrderTraversal(BinTree BT)
{
    if(BT)
    {
        printf(&quot;%c &quot;,BT-&gt;Data);
        PreOrderTraversal(BT-&gt;Left);
        PreOrderTraversal(BT-&gt;Right);
    }
}

void PreOrderTraversalByStack(BinTree BT)
{
    if(BT == NULL)
        return;
    LPNODE pMove = BT;
    LPNODE stack[100];
    int stackTop = -1;
    while(stackTop != -1 || pMove)
    {
        while(pMove)
        {
            printf(&quot;%c &quot;,pMove-&gt;Data);
            stack[++stackTop] = pMove;
            pMove = pMove-&gt;Left;
        }
        if(stackTop != -1)
        {
            pMove = stack[stackTop--];
            pMove = pMove-&gt;Right;
        }
    }

}

void InOrderTraversal(BinTree BT)
{
    if(BT)
    {
        InOrderTraversal(BT-&gt;Left);
        printf(&quot;%c &quot;,BT-&gt;Data);
        InOrderTraversal(BT-&gt;Right);
    }
}

void InOrderTraversalByStack(BinTree BT)
{
    if(BT == NULL)
        return;
    LPNODE pMove = BT;
    LPNODE stack[100];
    int stackTop = -1;
    while(stackTop != -1 || pMove)
    {
        while(pMove)
        {
            stack[++stackTop] = pMove;
            pMove = pMove-&gt;Left;
        }
        if(stackTop != -1)
        {
            pMove = stack[stackTop--];
            printf(&quot;%c &quot;,pMove-&gt;Data);
            pMove = pMove-&gt;Right;
        }
    }

}

void PostOrderTraversal(BinTree BT)
{
    if(BT)
    {
        PostOrderTraversal(BT-&gt;Left);
        PostOrderTraversal(BT-&gt;Right);
        printf(&quot;%c &quot;,BT-&gt;Data);
    }
}

void PostOrderTraversalByStack(BinTree BT)
{
    if(BT == NULL)
        return;
    LPNODE pMove = BT;
    LPNODE stack[100];
    int stackTop = -1;
    LPNODE placeVisited = NULL;

    while(pMove)
    {
        stack[++stackTop] = pMove;
        pMove = pMove-&gt;Left;
    }

    while(stackTop != -1)
    {
        pMove = stack[stackTop--];
        if(pMove-&gt;Right == NULL || pMove-&gt;Right == placeVisited)
        {
            printf(&quot;%c &quot;,pMove-&gt;Data);
            placeVisited = pMove;
        }
        else
        {
            stack[++stackTop] = pMove;
            pMove = pMove-&gt;Right;
            while(pMove)
            {
                stack[++stackTop] = pMove;
                pMove = pMove-&gt;Left;
            }
        }
    }

}

void LevelTraversal(BinTree BT)
{
    LPNODE pMove = BT;
    LPNODE queue[100];
    int front = 0;
    int tail = 0;
    queue[tail++] = pMove;
    printf(&quot;%c &quot;,pMove-&gt;Data);
    while(front != tail)
    {
        pMove = queue[front++];
        if(pMove-&gt;Left != NULL)
        {
            queue[tail++] = pMove-&gt;Left;
            printf(&quot;%c &quot;,pMove-&gt;Left-&gt;Data);
        }
        if(pMove-&gt;Right != NULL)
        {
            queue[tail++] = pMove-&gt;Right;
            printf(&quot;%c &quot;,pMove-&gt;Right-&gt;Data);
        }

    }

}

int main()
{
    LPNODE A = CreateNode('A');
    LPNODE B = CreateNode('B');
    LPNODE C = CreateNode('C');
    LPNODE D = CreateNode('D');
    LPNODE E = CreateNode('E');
    LPNODE F = CreateNode('F');
    InsertNode(A,B,C);
    InsertNode(B,D,NULL);
    InsertNode(C,E,NULL);
    InsertNode(E,NULL,F);
    printf(&quot;PreOrderTraversal:\n&quot;);
    PreOrderTraversal(A);
    printf(&quot;\nPreOrderTraversalByStack:\n&quot;);
    PreOrderTraversalByStack(A);
    printf(&quot;\nInOrderTraversal:\n&quot;);
    InOrderTraversal(A);
    printf(&quot;\nInOrderTraversalByStack:\n&quot;);
    InOrderTraversalByStack(A);
    printf(&quot;\nPostOrderTraversal:\n&quot;);
    PostOrderTraversal(A);
    printf(&quot;\nPostOrderTraversalByStack:\n&quot;);
    PostOrderTraversalByStack(A);
    printf(&quot;\nLevelTraversal:\n&quot;);
    LevelTraversal(A);
    printf(&quot;\n&quot;);
    return 0;
}
</code></pre>
<pre><code>PreOrderTraversal:
A B D C E F
PreOrderTraversalByStack:
A B D C E F
InOrderTraversal:
D B A E F C
InOrderTraversalByStack:
D B A E F C
PostOrderTraversal:
D B F E C A
PostOrderTraversalByStack:
D B F E C A
LevelTraversal:
A B C D E F
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="二叉搜索树"><a class="header" href="#二叉搜索树">二叉搜索树</a></h1>
<p>查找分为静态查找和动态查找。静态查找可以使用二分查找方式。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311121615700.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311121616062.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311121616955.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311121623845.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311121623598.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311121624932.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311121624587.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311121624794.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311121625911.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311121625860.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311121625854.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311121626802.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311121626053.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef int ElementType;

typedef struct TreeNode *BinTree;

typedef BinTree Position;

typedef struct TreeNode
{
    ElementType Data;
    BinTree Left;
    BinTree Right;
}*LPNODE;

BinTree Insert(ElementType X,BinTree BST)
{
    if(!BST)
    {
        /*若原树为空，生成并返回一个结点的二叉搜索树*/
        BST = (BinTree)malloc(sizeof(struct TreeNode));
        BST-&gt;Data = X;
        BST-&gt;Left = NULL;
        BST-&gt;Right = NULL;
    }
    else   /*开始找要插入元素的位置*/
    {
        if(BST-&gt;Data &lt; X)
            BST-&gt;Right = Insert(X,BST-&gt;Right);
        else if(BST-&gt;Data &gt; X)
            BST-&gt;Left = Insert(X,BST-&gt;Left);
        /*else X已经存在，什么都不做 */
    }
    return BST;
}


/*尾递归方式查找*/
ElementType Find(ElementType X,BinTree BST)
{
    if(!BST)
        return NULL;
    if(BST-&gt;Data &lt; X)
        return Find(X,BST-&gt;Right);
    else if(BST-&gt;Data &gt; X)
        return Find(X,BST-&gt;Left);
    else       /*X == BST-&gt;Data*/
        return BST; /*查找成功，返回找到结点的地址*/
}

/*迭代、非递归方式*/
Position FindMax(BinTree BST)
{
    if(BST)
        while(BST-&gt;Right)
            BST = BST-&gt;Right;
    return BST;
}



Position FindMin(BinTree BST)
{
    if(!BST)
        return NULL;
    else if(!BST-&gt;Left)  /*有根结点，但没有左子树，直接返回根*/
            return BST;
    else
        return FindMin(BST-&gt;Left);
}

BinTree Delete(ElementType X,BinTree BST)
{
    Position Tmp;
    if(!BST)
        printf(&quot;找不到要删除的元素！\n&quot;);
    else if(X &lt; BST-&gt;Data)
        BST-&gt;Left = Delete(X,BST-&gt;Left);
    else if(X &gt; BST-&gt;Data)
        BST-&gt;Right = Delete(X,BST-&gt;Right);
    else
    {
        if(BST-&gt;Left &amp;&amp; BST-&gt;Right)
        {
            Tmp = FindMin(BST-&gt;Right);
            BST-&gt;Data = Tmp-&gt;Data;
            BST-&gt;Right = Delete(BST-&gt;Data,BST-&gt;Right);
        }
        else
        {
            Tmp = BST;
            if(!BST-&gt;Left)
                BST = BST-&gt;Right;
            else if(!BST-&gt;Right)
                BST = BST-&gt;Left;
            free(Tmp);
        }
    }
    return BST;

}

void PreOrderTraversalByStack(BinTree BST)
{
    if(!BST)
        return;
    BinTree pMove = BST;
    BinTree stack[100];
    int stackTop = -1;

    while(pMove || stackTop != -1 )
    {
        while(pMove)
        {
            printf(&quot;%d &quot;,pMove-&gt;Data);
            stack[++stackTop] = pMove;
            pMove = pMove-&gt;Left;
        }
        if(stackTop != -1)
        {
            pMove = stack[stackTop--];
            pMove = pMove-&gt;Right;
            while(pMove)
            {
                printf(&quot;%d &quot;,pMove-&gt;Data);
                stack[++stackTop] = pMove;
                pMove = pMove-&gt;Left;
            }
        }
    }
}

void InOrderTraversalByStack(BinTree BST)
{
    if(!BST)
        return;
    BinTree pMove = BST;
    BinTree stack[100];
    int stackTop = -1;

    while(pMove || stackTop != -1 )
    {
        while(pMove)
        {
            stack[++stackTop] = pMove;
            pMove = pMove-&gt;Left;
        }
        if(stackTop != -1)
        {
            pMove = stack[stackTop--];
            printf(&quot;%d &quot;,pMove-&gt;Data);
            pMove = pMove-&gt;Right;
            while(pMove)
            {
                stack[++stackTop] = pMove;
                pMove = pMove-&gt;Left;
            }
        }
    }
}


void LevelTraversal(BinTree BT)
{
    LPNODE pMove = BT;
    LPNODE queue[100];
    int front = 0;
    int tail = 0;
    queue[tail++] = pMove;
    printf(&quot;%d &quot;,pMove-&gt;Data);
    while(front != tail)
    {
        pMove = queue[front++];
        if(pMove-&gt;Left != NULL)
        {
            queue[tail++] = pMove-&gt;Left;
            printf(&quot;%d &quot;,pMove-&gt;Left-&gt;Data);
        }
        if(pMove-&gt;Right != NULL)
        {
            queue[tail++] = pMove-&gt;Right;
            printf(&quot;%d &quot;,pMove-&gt;Right-&gt;Data);
        }

    }

}

int main()
{
    BinTree BST = NULL;
    BST = Insert(5,BST);
    BST = Insert(3,BST);
    BST = Insert(4,BST);
    BST = Insert(9,BST);
    BST = Insert(20,BST);
    BST = Insert(30,BST);
    BST = Insert(40,BST);
    BST = Insert(43,BST);
    BST = Insert(34,BST);
    BST = Insert(6,BST);
    BST = Insert(7,BST);
    BST = Insert(8,BST);
    LevelTraversal(BST);
    printf(&quot;\n%d&quot;,FindMax(BST)-&gt;Data);
    printf(&quot;\n%d&quot;,FindMin(BST)-&gt;Data);
    BST = Delete(43,BST);
    BST = Delete(3,BST);
    printf(&quot;\n&quot;);
    LevelTraversal(BST);
    printf(&quot;\n%d&quot;,FindMax(BST)-&gt;Data);
    printf(&quot;\n%d&quot;,FindMin(BST)-&gt;Data);
    BinTree Tmp = Find(100,BST);
    if(!Tmp)
        printf(&quot;\nNULL\n&quot;);
    else
        printf(&quot;\n%d\n&quot;,Find(100,BST));
        //printf(&quot;\n%d\n&quot;,Tmp-&gt;Data);
    return 0;

}
</code></pre>
<pre><code>5 3 9 4 6 20 7 30 8 40 34 43
43
3
5 4 9 6 20 7 30 8 40 34
40
4
NULL
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="二叉平衡树"><a class="header" href="#二叉平衡树">二叉平衡树</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="哈夫曼树"><a class="header" href="#哈夫曼树">哈夫曼树</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="并查集"><a class="header" href="#并查集">并查集</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="mooc-pta树题目"><a class="header" href="#mooc-pta树题目">MOOC-PTA树题目</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="图"><a class="header" href="#图">图</a></h1>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202311301605836.png" alt="" /></p>
<p>多对多的数据结构</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202311301606904.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="图的存储"><a class="header" href="#图的存储">图的存储</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="图的遍历"><a class="header" href="#图的遍历">图的遍历</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="最短路径算法"><a class="header" href="#最短路径算法">最短路径算法</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="最小生成树算法"><a class="header" href="#最小生成树算法">最小生成树算法</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="mooc-pta图题目"><a class="header" href="#mooc-pta图题目">MOOC-PTA图题目</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="排序算法"><a class="header" href="#排序算法">排序算法</a></h1>
<ul>
<li><a href="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">选择排序</a></li>
<li><a href="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序</a></li>
</ul>
<h2 id="选择排序"><a class="header" href="#选择排序">选择排序</a></h2>
<ul>
<li>从所有元素中找到最小的元素放到数组的第0个位置</li>
<li>从剩余元素中找出最小的放到第1个位置，以此类推，直到所有元素都放到了适当的位置</li>
</ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main() {

    int lh,rh,k,tmp;
    int array[]={2,5,1,9,10,0,4,8,7,6};
    for(lh=0;lh&lt;10;lh++)
    {
        rh=lh;
        for(k=lh;k&lt;10;++k)
            if(array[k]&lt;array[rh])
                rh=k;
        tmp=array[lh];
        array[lh]=array[rh];
        array[rh]=tmp;
    }
    for(lh=0;lh&lt;10;lh++) cout&lt;&lt;array[lh]&lt;&lt;' ';

    return 0;
}
</code></pre>
<h2 id="冒泡排序"><a class="header" href="#冒泡排序">冒泡排序</a></h2>
<ul>
<li>大数沉淀、小数冒泡</li>
</ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main() {

    int i,j,tmp,n=10;
    int array[]={9,8,5,4,2,0,10,6,11,7};

    for(j=0;j&lt;n-1;j++)
        for(i=0;i&lt;n-1-j;i++)
            if(array[i]&gt;array[i+1])
            {
                tmp=array[i];
                array[i]=array[i+1];
                array[i+1]=tmp;
            }
    cout&lt;&lt;endl;

    for(i=0;i&lt;n;i++) cout&lt;&lt;array[i]&lt;&lt;' ';

    return 0;
}
</code></pre>
<p>改进版：增加一个标志变量，若数组已排好序，则只用扫描一遍</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main() {

    int i,j,tmp,n=10;
    bool flag;
    int array[]={9,8,5,4,2,0,10,6,11,7};

    for(j=0;j&lt;n-1;j++){
        flag=false;
        for(i=0;i&lt;n-1-j;i++)
            if(array[i]&gt;array[i+1])
            {
                tmp=array[i];
                array[i]=array[i+1];
                array[i+1]=tmp;
                flag=true;
            }
        if(!flag) break;
    }
    cout&lt;&lt;endl;

    for(i=0;i&lt;n;i++) cout&lt;&lt;array[i]&lt;&lt;' ';

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="mooc-pta排序题目"><a class="header" href="#mooc-pta排序题目">MOOC-PTA排序题目</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="查找算法"><a class="header" href="#查找算法">查找算法</a></h1>
<ul>
<li><a href="%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.html#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE">顺序查找</a></li>
<li><a href="%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.html#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">二分查找</a></li>
</ul>
<h2 id="顺序查找"><a class="header" href="#顺序查找">顺序查找</a></h2>
<ul>
<li>被查找的数存放在一个数组中</li>
<li>从数组的第一个元素开始，依次往下比较，直到找到要找的元素为止</li>
</ul>
<p>下面程序能在一整数数组中查找元素x的存储位置</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main() {

    int k,x;
    int array[]={2,3,1,7,5,8,9,0,4,6};
    cout&lt;&lt;&quot;输入要查找的元素值：&quot;;
    cin&gt;&gt;x;
    for(k=0;k&lt;10;k++)
    {
        if(x==array[k])
        {
            cout&lt;&lt;k;
            break;
        }
    }
    if(k==10) cout&lt;&lt;&quot;not found&quot;;
    return 0;
}
</code></pre>
<h2 id="二分查找"><a class="header" href="#二分查找">二分查找</a></h2>
<p>前提：数组已排序</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main() {

    int x;
    int array[]={5,13,19,21,37,56,64,74,80,88,92};
    int high,low,mid;
    cout&lt;&lt;&quot;输入要查找的元素值：&quot;;
    cin&gt;&gt;x;
    low=0;
    high=10;

    while(low&lt;=high)
    {
        mid=(high-low)/2+low;
        if(x==array[mid])
        {
            cout&lt;&lt;x&lt;&lt;&quot;的位置是：&quot;&lt;&lt;mid&lt;&lt;endl;
            break;
        }
        if(x&lt;array[mid]) high=mid-1;
        else low=mid+1;
    }
    if(low&gt;high) cout&lt;&lt;&quot;找不到&quot;&lt;&lt;x&lt;&lt;endl;

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="mooc-pta查找题目"><a class="header" href="#mooc-pta查找题目">MOOC-PTA查找题目</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
