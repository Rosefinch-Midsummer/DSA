<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>资料结构与演算法</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="弁言.html"><strong aria-hidden="true">1.</strong> 弁言</a></li><li class="chapter-item expanded "><a href="数据结构与算法概论.html"><strong aria-hidden="true">2.</strong> 数据结构与算法概论</a></li><li class="chapter-item expanded "><a href="MOOC-PTA复杂度题目.html"><strong aria-hidden="true">3.</strong> MOOC-PTA复杂度题目</a></li><li class="chapter-item expanded "><a href="线性结构.html"><strong aria-hidden="true">4.</strong> 线性结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="线性表.html"><strong aria-hidden="true">4.1.</strong> 线性表</a></li><li class="chapter-item expanded "><a href="栈.html"><strong aria-hidden="true">4.2.</strong> 栈</a></li><li class="chapter-item expanded "><a href="队列.html"><strong aria-hidden="true">4.3.</strong> 队列</a></li></ol></li><li class="chapter-item expanded "><a href="MOOC-PTA线性结构题目.html"><strong aria-hidden="true">5.</strong> MOOC-PTA线性结构题目</a></li><li class="chapter-item expanded "><a href="树.html"><strong aria-hidden="true">6.</strong> 树</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="二叉树.html"><strong aria-hidden="true">6.1.</strong> 二叉树</a></li><li class="chapter-item expanded "><a href="二叉搜索树.html"><strong aria-hidden="true">6.2.</strong> 二叉搜索树</a></li><li class="chapter-item expanded "><a href="平衡二叉树.html"><strong aria-hidden="true">6.3.</strong> 平衡二叉树</a></li><li class="chapter-item expanded "><a href="堆.html"><strong aria-hidden="true">6.4.</strong> 堆</a></li><li class="chapter-item expanded "><a href="哈夫曼树.html"><strong aria-hidden="true">6.5.</strong> 哈夫曼树</a></li><li class="chapter-item expanded "><a href="并查集.html"><strong aria-hidden="true">6.6.</strong> 并查集</a></li></ol></li><li class="chapter-item expanded "><a href="MOOC-PTA树题目.html"><strong aria-hidden="true">7.</strong> MOOC-PTA树题目</a></li><li class="chapter-item expanded "><a href="图.html"><strong aria-hidden="true">8.</strong> 图</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="图的存储.html"><strong aria-hidden="true">8.1.</strong> 图的存储</a></li><li class="chapter-item expanded "><a href="图的遍历.html"><strong aria-hidden="true">8.2.</strong> 图的遍历</a></li><li class="chapter-item expanded "><a href="最短路径算法.html"><strong aria-hidden="true">8.3.</strong> 最短路径算法</a></li><li class="chapter-item expanded "><a href="最小生成树算法.html"><strong aria-hidden="true">8.4.</strong> 最小生成树算法</a></li></ol></li><li class="chapter-item expanded "><a href="MOOC-PTA图题目.html"><strong aria-hidden="true">9.</strong> MOOC-PTA图题目</a></li><li class="chapter-item expanded "><a href="排序算法.html"><strong aria-hidden="true">10.</strong> 排序算法</a></li><li class="chapter-item expanded "><a href="MOOC-PTA排序题目.html"><strong aria-hidden="true">11.</strong> MOOC-PTA排序题目</a></li><li class="chapter-item expanded "><a href="查找算法.html"><strong aria-hidden="true">12.</strong> 查找算法</a></li><li class="chapter-item expanded "><a href="MOOC-PTA查找题目.html"><strong aria-hidden="true">13.</strong> MOOC-PTA查找题目</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">资料结构与演算法</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="弁言"><a class="header" href="#弁言">弁言</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="数据结构与算法概论"><a class="header" href="#数据结构与算法概论">数据结构与算法概论</a></h1>
<ul>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA">数据结构绪论</a>
<ul>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E5%92%8C%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84">逻辑结构和物理结构</a>
<ul>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84">逻辑结构</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84">物理结构</a></li>
</ul>
</li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a></li>
</ul>
</li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E7%AE%97%E6%B3%95%E7%BB%AA%E8%AE%BA">算法绪论</a>
<ul>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7">算法特性</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%A6%81%E6%B1%82">算法设计的要求</a>
<ul>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E6%AD%A3%E7%A1%AE%E6%80%A7">正确性</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E5%8F%AF%E8%AF%BB%E6%80%A7">可读性</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E5%81%A5%E5%A3%AE%E6%80%A7">健壮性</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E6%97%B6%E9%97%B4%E6%95%88%E7%8E%87%E9%AB%98%E5%92%8C%E5%AD%98%E5%82%A8%E9%87%8F%E4%BD%8E">时间效率高和存储量低</a></li>
</ul>
</li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E7%9A%84%E5%BA%A6%E9%87%8F%E6%96%B9%E6%B3%95">算法效率的度量方法</a>
<ul>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E4%BA%8B%E5%90%8E%E7%BB%9F%E8%AE%A1%E6%96%B9%E6%B3%95">事后统计方法</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E4%BA%8B%E5%89%8D%E5%88%86%E6%9E%90%E4%BC%B0%E7%AE%97%E6%96%B9%E6%B3%95">事前分析估算方法</a></li>
</ul>
</li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E5%87%BD%E6%95%B0%E7%9A%84%E6%B8%90%E8%BF%91%E5%A2%9E%E9%95%BF">函数的渐近增长</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">算法时间复杂度</a>
<ul>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AE%9A%E4%B9%89">算法时间复杂度定义</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E6%8E%A8%E5%AF%BC%E5%A4%A7o%E9%98%B6%E6%96%B9%E6%B3%95">推导大O阶方法</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E5%B8%B8%E6%95%B0%E9%98%B6o1">常数阶O(1)</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E7%BA%BF%E6%80%A7%E9%98%B6on">线性阶O(n)</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E5%AF%B9%E6%95%B0%E9%98%B6ologn">对数阶O(logn)</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E5%B9%B3%E6%96%B9%E9%98%B6on2">平方阶O(n^2)</a></li>
</ul>
</li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">常见的时间复杂度</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E6%9C%80%E5%9D%8F%E6%83%85%E5%86%B5%E5%92%8C%E5%B9%B3%E5%9D%87%E6%83%85%E5%86%B5">最坏情况和平均情况</a></li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E7%AE%97%E6%B3%95%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">算法空间复杂度</a></li>
</ul>
</li>
<li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%AE%BA.html#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E8%81%94%E7%B3%BB">数据结构和算法的联系</a></li>
</ul>
<h1 id="数据结构绪论"><a class="header" href="#数据结构绪论">数据结构绪论</a></h1>
<p>数据结构是相互之间存在一种或多种特定关系的数据元素的集合。</p>
<h2 id="逻辑结构和物理结构"><a class="header" href="#逻辑结构和物理结构">逻辑结构和物理结构</a></h2>
<p>按照视点的不同，我们把数据结构分为逻辑结构和物理结构。</p>
<h3 id="逻辑结构"><a class="header" href="#逻辑结构">逻辑结构</a></h3>
<p>逻辑结构是指数据对象中数据元素之间的相互关系。其实这也是我们今后最需要关心的问题。逻辑结构分为以下四种。</p>
<p>（1）集合结构</p>
<p>集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。数据结构中的集合关系就类似于数学中的集合。</p>
<p>（2）线性结构</p>
<p>线性结构中的数据元素之间是一对一的关系。</p>
<p>（3）树形结构</p>
<p>树型结构中的数据元素之间存在一种一对多的层次关系。</p>
<p>（4）图形结构</p>
<p>图形结构的数据元素是多对多的关系。</p>
<p>从之前的例子也可以看出，逻辑结构是针对具体问题的，是为了解决某个问题，在对问题理解的基础上，选择一个合适的数据结构表示数据元素之间的逻辑关系。</p>
<h3 id="物理结构"><a class="header" href="#物理结构">物理结构</a></h3>
<p>物理结构（存储结构）是指数据的逻辑结构在计算机中的存储形式。</p>
<p>数据的存储结构应正确反映数据元素之间的逻辑关系，这才是最为关键的，如何存储数据元素之间的逻辑关系，是实现物理结构的重点和难点。</p>
<p>数据元素的存储结构形式有两种：顺序存储和链式存储。</p>
<p>（1）顺序存储结构</p>
<p><strong>顺序存储结构是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。</strong> 典型的顺序存储结构就是数组。</p>
<p>（2）链式存储结构</p>
<p><strong>链式存储结构是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置。</strong></p>
<p>显然链式存储就灵活多了，数据存在哪里不重要，只要有一个指针存放了相应的地址就能找到它了。</p>
<h2 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h2>
<p>数据类型是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。</p>
<p>在C语言中，按照取值的不同，数据类型可以分为两类：</p>
<ul>
<li>原子类型：不可再分解的类型，包括整型、实型、字符型等。</li>
<li>结构类型：由若干个类型组合而成，是可以再分解的。例如整型数组是由若干整型数据组成的。</li>
</ul>
<p><strong>抽象是指抽取出事物具有的普遍性的本质</strong>。它是抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节，只保留实现目标所必需的信息。 </p>
<p>抽象数据类型（Abstract Data Type，ADT）：一个数学模型及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309291221942.png" alt="" /></p>
<p>实际上，<strong>抽象数据类型体现了程序设计中问题分解、抽象和信息隐藏的特性</strong>。抽象数据类型把实际生活中的问题分解为多个小规模且容易处理的问题，然后建立一个计算机能处理的数据类型，并把每个功能模块的实现细节作为一个独立的单元，从而使具体实现过程隐藏起来。</p>
<p>为了便于在之后的讲解中对抽象数据类型进行规范的描述，我们给出了抽象数据类型的标准格式：</p>
<pre><code>ADT 抽象数据类型名
Data
	数据元素之间逻辑关系的定义
Operation
	操作1
		初始条件
		操作结构描述
	操作2
		...
	操作3
		...
endADT
</code></pre>
<h1 id="算法绪论"><a class="header" href="#算法绪论">算法绪论</a></h1>
<p>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p>
<h2 id="算法特性"><a class="header" href="#算法特性">算法特性</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309291225238.png" alt="" /></p>
<p>算法具有五个基本特性：输入、输出、有穷性、确定性和可行性</p>
<p>算法具有零个或多个输入，有一个或多个输出。</p>
<p>有穷性只算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且一个步骤在可接受的时间内完成。</p>
<p>确定性：算法的每一步骤都要具有确定的含义，不会出现二义性。算法在一定条件下，只有一条执行路径，相同的输入只能有唯一的输出结果。算法的每个步骤被精确定义而无歧义。</p>
<p>可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。可行性意味着算法可以转换为程序上机运行，并得到正确的结果。</p>
<h2 id="算法设计的要求"><a class="header" href="#算法设计的要求">算法设计的要求</a></h2>
<h3 id="正确性"><a class="header" href="#正确性">正确性</a></h3>
<p>算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性，能正确反映问题得需求，能够得到问题的正确答案。</p>
<p>但是算法得”正确“通常在用法上有很大的差别，大体上分为以下四个层次。</p>
<p>（1）算法程序没有语法错误。</p>
<p>（2）算法程序对于合法的输入数据能够产生满足要求的输出结果。 </p>
<p>（3）算法程序对于非法的输入数据能够得出满足规格说明的结果。</p>
<p>（4）算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。</p>
<p>一般情况下，我们把层次（3）作为一个算法是否正确的标准。</p>
<h3 id="可读性"><a class="header" href="#可读性">可读性</a></h3>
<p>算法设计的另一目的是为了便于阅读、理解和交流。</p>
<h3 id="健壮性"><a class="header" href="#健壮性">健壮性</a></h3>
<p>当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。</p>
<h3 id="时间效率高和存储量低"><a class="header" href="#时间效率高和存储量低">时间效率高和存储量低</a></h3>
<p>设计算法应该尽量满足时间效率高和存储量低的需求。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309291227220.png" alt="" /></p>
<h2 id="算法效率的度量方法"><a class="header" href="#算法效率的度量方法">算法效率的度量方法</a></h2>
<h3 id="事后统计方法"><a class="header" href="#事后统计方法">事后统计方法</a></h3>
<p>这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编写的程序的运行时间进行比较，从而确定算法效率的高低。</p>
<p>这种方法有多种缺陷，我们考虑不予采纳。</p>
<h3 id="事前分析估算方法"><a class="header" href="#事前分析估算方法">事前分析估算方法</a></h3>
<p>事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行统计。</p>
<p>一个程序的运行时间，依赖于算法的好坏和问题的输入规模。所谓问题输入规模是指输入量的多少。</p>
<p>最终，在分析程序的运行时间时，最重要的是把程序看成是独立于程序设计语言的算法或一系列步骤。</p>
<h2 id="函数的渐近增长"><a class="header" href="#函数的渐近增长">函数的渐近增长</a></h2>
<p>函数的渐近增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n&gt;N,f(n)总是比g(n)大，那么我们说f(n)的增长渐近快于g(n)。</p>
<p>判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309291235134.png" alt="" /></p>
<h2 id="算法时间复杂度"><a class="header" href="#算法时间复杂度">算法时间复杂度</a></h2>
<h3 id="算法时间复杂度定义"><a class="header" href="#算法时间复杂度定义">算法时间复杂度定义</a></h3>
<p>在进行算法分析时，语句总的执行次数T(n)是关于问题规模的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间度量，记作T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的函数。</p>
<p>这样用大写O()来体现算法时间复杂度的记法，我们称之为大O记法。</p>
<p>一般情况下，随着n的增大，T(n)增长最慢的算法为最优算法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309291241513.png" alt="" /></p>
<pre><code class="language-c">if ( A &gt; B ) {
    for ( i=0; i&lt;N; i++ )
        for ( j=N*N; j&gt;i; j-- )
            A += B;
}
else {
    for ( i=0; i&lt;N*2; i++ )
        for ( j=N*2; j&gt;i; j-- )
            A += B;
}
</code></pre>
<p>这段代码时间复杂度为<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<h3 id="推导大o阶方法"><a class="header" href="#推导大o阶方法">推导大O阶方法</a></h3>
<p>（1）用常数1取代运行时间中的所有加法常数。</p>
<p>（2）在修改后的运行次数函数中，只保留最高阶项。</p>
<p>（3）如果最高阶项存在且其系数不是1，则去除与这个项相乘的系数。得到的结果就是大O阶。</p>
<h3 id="常数阶o1"><a class="header" href="#常数阶o1">常数阶O(1)</a></h3>
<p>不管算法运行次数常数是多少，我们都记作O(1)，而不能是O(3)、O(12)等其他任何数字。</p>
<h3 id="线性阶on"><a class="header" href="#线性阶on">线性阶O(n)</a></h3>
<p>要分析算法的复杂度，关键就是要分析循环结构的运行情况。</p>
<pre><code class="language-c">int i,sum;
sum=0;
for(i=0;i&lt;n;i++)
	sum+=i;
</code></pre>
<h3 id="对数阶ologn"><a class="header" href="#对数阶ologn">对数阶O(logn)</a></h3>
<pre><code class="language-c">int count=1;
while(count&lt;n)
	count=count*2;
</code></pre>
<h3 id="平方阶on2"><a class="header" href="#平方阶on2">平方阶O(n^2)</a></h3>
<p>循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数。</p>
<p>下面这个程序的时间复杂度为<code>O(m*n)</code></p>
<pre><code class="language-c">int i,j;
for(i=0;i&lt;m;i++)
{
	for(j=0;j&lt;n;j++)
	{
		/*时间复杂度为O(1)的程序步骤序列*/
	}
}
</code></pre>
<p>下面这个程序的时间复杂度为<code>O(n^2)</code></p>
<pre><code class="language-c">int i,j;
for(i=0;i&lt;n;i++)
{
	for(j=i;j&lt;n;j++)
	{
		/*时间复杂度为O(1)的程序步骤序列*/
	}
}
</code></pre>
<h2 id="常见的时间复杂度"><a class="header" href="#常见的时间复杂度">常见的时间复杂度</a></h2>
<p>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309291237243.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309291237024.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309291240341.png" alt="" /></p>
<h2 id="最坏情况和平均情况"><a class="header" href="#最坏情况和平均情况">最坏情况和平均情况</a></h2>
<p>平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。也就是说，我们运行一段程序代码时，是希望看到平均运行时间的。可现实中，平均运行时间很难通过分析得到，一般都是通过一定数量的实验数据后估算出来的。</p>
<p>对于算法的分析，一种方法是计算所有情况的平均值，这种时间复杂度的计算方法被称为平均时间复杂度。另一种方法是计算最坏情况下的时间复杂度，这种方法被称为最坏时间复杂度。一般在没有特殊说明的情况下，都是指最坏时间复杂度。</p>
<h2 id="算法空间复杂度"><a class="header" href="#算法空间复杂度">算法空间复杂度</a></h2>
<p>算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n)=O(f(n))，其中n为问题的规模，f(n)为语句关于n所占存储空间的函数。</p>
<h1 id="数据结构和算法的联系"><a class="header" href="#数据结构和算法的联系">数据结构和算法的联系</a></h1>
<p>由放书问题得出了下面的结论：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309290959246.png" alt="" /></p>
<p>打印1-N这N个数的循环写法和递归写法运行结果不同，得出了下面的结论：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309290958683.png" alt="" /></p>
<p>计算多项式，普通写法和秦久韶算法有着明显的区别。</p>
<p>计时的基本程序如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

clock_t start,stop;
//clock_t是clock()函数返回的变量类型
double duration;
//记录被调函数运行时间——以秒为单位
void MyFunction()
{

}
int main()
{
    printf(&quot;%d\n&quot;,CLK_TCK);//本机每秒所走的时钟打点数为1000
    start = clock();
    MyFunction();
    stop = clock();
    duration = ((double)(stop-start))/CLK_TCK;
    printf(&quot;%f\n&quot;,duration);
}
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309291049929.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;time.h&gt;

clock_t start,stop;
//clock_t是clock()函数返回的变量类型
double duration;
//记录被调函数运行时间——以秒为单位

#define MAXN 10    //多项式最大项数，即多项式阶数+1
double f1(int n,double a[],double x);
double f2(int n,double a[],double x);

int main()
{
    int i;
    double a[MAXN];    //存储多项式的系数
    for(i=0;i&lt;MAXN;i++) a[i] = double(i);
    return 0;
}
</code></pre>
<p>这个程序第18行为何会报错<code>error: expected expression before 'double'</code>？</p>
<p>double(i)应该写成(double)i。。。。。</p>
<p>此外在C语言中，<code>CLK_TCK</code> 是一个过时的宏定义，代表每秒的时钟计时单元数。在新的标准中，该宏定义已被废弃。可以直接使用 <code>CLOCKS_PER_SEC</code> 来代替 <code>CLK_TCK</code>。</p>
<p>所以，将计算duration的代码修改为以下形式：</p>
<pre><code class="language-c">duration = ((double)(stop - start))/CLOCKS_PER_SEC;
</code></pre>
<p>单次运行代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;time.h&gt;

clock_t start,stop;
//clock_t是clock()函数返回的变量类型
double duration;
//记录被调函数运行时间——以秒为单位

#define MAXN 10    //多项式最大项数，即多项式阶数+1
double f1(int n,double a[],double x);
double f2(int n,double a[],double x);

int main()
{
    int i;
    double a[MAXN];    //存储多项式的系数
    for(i=0;i&lt;MAXN;i++)
        a[i] = (double)i;

    start = clock();
    f1(MAXN,a,1.1);
    stop = clock();
    //duration = ((double)(stop-start))/CLK_TCK;
    duration = ((double)(stop - start))/CLOCKS_PER_SEC;
    printf(&quot;ticks1 = %f\n&quot;,(double)(stop - start));
    printf(&quot;duration1 = %6.2e\n&quot;, duration);

    start = clock();
    f2(MAXN,a,1.1);
    stop = clock();
    duration = ((double)(stop - start))/CLOCKS_PER_SEC;
    //duration = ((double)(stop-start))/CLK_TCK;
    printf(&quot;ticks1 = %f\n&quot;,(double)(stop - start));
    printf(&quot;duration1 = %6.2e\n&quot;, duration);

    return 0;
}

double f1(int n,double a[], double x)
{
    int i;
    double p = a[0];
    for(i=1;i&lt;=n;i++)
        p+=(a[i]*pow(x,i));
    return p;
}

double f2(int n,double a[], double x)
{
    int i;
    double p = a[n];
    for(i=n;i&gt;0;i--)
        p+=(a[i-1]+x*p);
    return p;
}
</code></pre>
<pre><code>ticks1 = 0.000000
duration1 = 0.00e+000
ticks1 = 0.000000
duration1 = 0.00e+000
</code></pre>
<p>多项式阶数太低，两个程序运行时间都不到一个tick，几乎没有差别。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309291116395.png" alt="" /></p>
<p>多次重复运行代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;time.h&gt;

clock_t start,stop;
//clock_t是clock()函数返回的变量类型
double duration;
//记录被调函数运行时间——以秒为单位

#define MAXN 10    //多项式最大项数，即多项式阶数+1
#define MAXK 1e7  //被测函数最大重复调用次数
double f1(int n,double a[],double x);
double f2(int n,double a[],double x);

int main()
{
    int i;
    double a[MAXN];    //存储多项式的系数
    for(i=0;i&lt;MAXN;i++)
        a[i] = (double)i;

    start = clock();
    for(i=1;i&lt;MAXK;i++)       //重复调用函数以获得充分多的时钟打点数
        f1(MAXN,a,1.1);
    stop = clock();
    //duration = ((double)(stop-start))/CLK_TCK;
    duration = ((double)(stop - start))/CLOCKS_PER_SEC/MAXK;    //计算函数单次运行的时间
    printf(&quot;ticks1 = %f\n&quot;,(double)(stop - start));
    printf(&quot;duration1 = %6.2e\n&quot;, duration);

    start = clock();
    for(i=1;i&lt;MAXK;i++)       //重复调用函数以获得充分多的时钟打点数
        f2(MAXN,a,1.1);
    stop = clock();
    //duration = ((double)(stop-start))/CLK_TCK;
    duration = ((double)(stop - start))/CLOCKS_PER_SEC/MAXK;    //计算函数单次运行的时间
    printf(&quot;ticks1 = %f\n&quot;,(double)(stop - start));
    printf(&quot;duration1 = %6.2e\n&quot;, duration);


    return 0;
}

double f1(int n,double a[], double x)
{
    int i;
    double p = a[0];
    for(i=1;i&lt;=n;i++)
        p+=(a[i]*pow(x,i));
    return p;
}

double f2(int n,double a[], double x)
{
    int i;
    double p = a[n];
    for(i=n;i&gt;0;i--)
        p+=(a[i-1]+x*p);
    return p;
}
</code></pre>
<pre><code>ticks1 = 2092.000000
duration1 = 2.09e-007
ticks1 = 443.000000
duration1 = 4.43e-008
</code></pre>
<p>两个程序运行时间差了一个数量级！由此可见：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309291128636.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="mooc-pta复杂度题目"><a class="header" href="#mooc-pta复杂度题目">MOOC-PTA复杂度题目</a></h1>
<ul>
<li><a href="MOOC-PTA%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%A2%98%E7%9B%AE.html#pta-01-%E5%A4%8D%E6%9D%82%E5%BA%A61-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98">PTA 01-复杂度1 最大子列和问题</a>
<ul>
<li><a href="MOOC-PTA%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%A2%98%E7%9B%AE.html#%E4%B8%89%E9%87%8D%E5%BE%AA%E7%8E%AF%E6%B1%82%E8%A7%A3">三重循环求解</a></li>
<li><a href="MOOC-PTA%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%A2%98%E7%9B%AE.html#%E4%BA%8C%E9%87%8D%E5%BE%AA%E7%8E%AF%E6%B1%82%E8%A7%A3">二重循环求解</a></li>
<li><a href="MOOC-PTA%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%A2%98%E7%9B%AE.html#%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95">分治算法</a></li>
<li><a href="MOOC-PTA%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%A2%98%E7%9B%AE.html#%E5%9C%A8%E7%BA%BF%E5%A4%84%E7%90%86%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">在线处理（动态规划）</a></li>
</ul>
</li>
<li><a href="MOOC-PTA%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%A2%98%E7%9B%AE.html#pta-01-%E5%A4%8D%E6%9D%82%E5%BA%A62-maximum-subsequence-sum">PTA 01-复杂度2 Maximum Subsequence Sum</a></li>
<li><a href="MOOC-PTA%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%A2%98%E7%9B%AE.html#pta-01-%E5%A4%8D%E6%9D%82%E5%BA%A63-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">PTA 01-复杂度3 二分查找</a></li>
</ul>
<h2 id="pta-01-复杂度1-最大子列和问题"><a class="header" href="#pta-01-复杂度1-最大子列和问题">PTA 01-复杂度1 最大子列和问题</a></h2>
<p>给定K个整数组成的序列{ N1​, N2​, ..., NK​ }，“连续子列”被定义为{ Ni​, Ni+1​, ..., Nj​ }，其中 1≤i≤j≤K。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。</p>
<p>本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下：</p>
<ul>
<li>数据1：与样例等价，测试基本正确性；</li>
<li>数据2：102个随机整数；</li>
<li>数据3：103个随机整数；</li>
<li>数据4：104个随机整数；</li>
<li>数据5：105个随机整数；</li>
</ul>
<p>输入格式:</p>
<p>输入第1行给出正整数K (≤100000)；第2行给出K个整数，其间以空格分隔。</p>
<p>输出格式:</p>
<p>在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。</p>
<p>输入样例:</p>
<pre><code class="language-in">6
-2 11 -4 13 -5 -2
</code></pre>
<p>输出样例:</p>
<pre><code class="language-out">20
</code></pre>
<h3 id="三重循环求解"><a class="header" href="#三重循环求解">三重循环求解</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202310081535329.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int MaxSubSeq(int A[], int N)
{
    int ThisSum = 0,MaxSum = 0;
    for(int i=0;i &lt; N;i++)
    {
        for(int j = i;j &lt; N;j++)
        {
            ThisSum = 0;
            for(int k=i;k&lt;=j;k++)
                ThisSum += A[k];
            if(ThisSum&gt;MaxSum)
                MaxSum = ThisSum;
        }
    }
    return MaxSum;
}

int main()
{
    int arr[100];
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=0;i&lt;n;i++)
        scanf(&quot;%d&quot;,&amp;arr[i]);
    printf(&quot;%d&quot;,MaxSubSeq(arr,n));
    return 0;
}
</code></pre>
<h3 id="二重循环求解"><a class="header" href="#二重循环求解">二重循环求解</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202310081535616.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int MaxSubSeq(int A[], int N)
{
    int ThisSum = 0,MaxSum = 0;
    for(int i=0;i &lt; N;i++)
    {
        ThisSum = 0;
        for(int j = i;j &lt; N;j++)
        {
            ThisSum += A[j];
            if(ThisSum&gt;MaxSum)
                MaxSum = ThisSum;
        }
    }
    return MaxSum;
}

int main()
{
    int arr[100];
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=0;i&lt;n;i++)
        scanf(&quot;%d&quot;,&amp;arr[i]);
    printf(&quot;%d&quot;,MaxSubSeq(arr,n));
    return 0;
}
</code></pre>
<h3 id="分治算法"><a class="header" href="#分治算法">分治算法</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202310081546769.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int Max3( int A, int B, int C )
{ /* 返回3个整数中的最大值 */
    return A &gt; B ? A &gt; C ? A : C : B &gt; C ? B : C;
}

int DivideAndConquer( int List[], int left, int right )
{ /* 分治法求List[left]到List[right]的最大子列和 */
    int MaxLeftSum, MaxRightSum; /* 存放左右子问题的解 */
    int MaxLeftBorderSum, MaxRightBorderSum; /*存放跨分界线的结果*/

    int LeftBorderSum, RightBorderSum;
    int center, i;

    if( left == right )  { /* 递归的终止条件，子列只有1个数字 */
        if( List[left] &gt; 0 )  return List[left];
        else return 0;
    }

    /* 下面是&quot;分&quot;的过程 */
    center = ( left + right ) / 2; /* 找到中分点 */
    /* 递归求得两边子列的最大和 */
    MaxLeftSum = DivideAndConquer( List, left, center );
    MaxRightSum = DivideAndConquer( List, center+1, right );

    /* 下面求跨分界线的最大子列和 */
    MaxLeftBorderSum = 0; LeftBorderSum = 0;
    for( i=center; i&gt;=left; i-- ) { /* 从中线向左扫描 */
        LeftBorderSum += List[i];
        if( LeftBorderSum &gt; MaxLeftBorderSum )
            MaxLeftBorderSum = LeftBorderSum;
    } /* 左边扫描结束 */

    MaxRightBorderSum = 0; RightBorderSum = 0;
    for( i=center+1; i&lt;=right; i++ ) { /* 从中线向右扫描 */
        RightBorderSum += List[i];
        if( RightBorderSum &gt; MaxRightBorderSum )
            MaxRightBorderSum = RightBorderSum;
    } /* 右边扫描结束 */

    /* 下面返回&quot;治&quot;的结果 */
    return Max3( MaxLeftSum, MaxRightSum, MaxLeftBorderSum + MaxRightBorderSum );
}

int MaxSubseqSum3( int List[], int N )
{ /* 保持与前2种算法相同的函数接口 */
    return DivideAndConquer( List, 0, N-1 );
}

int main()
{
    int arr[100];
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=0;i&lt;n;i++)
        scanf(&quot;%d&quot;,&amp;arr[i]);
    printf(&quot;%d&quot;,MaxSubseqSum3(arr,n));
    return 0;
}
</code></pre>
<h3 id="在线处理动态规划"><a class="header" href="#在线处理动态规划">在线处理（动态规划）</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202310081549404.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int MaxSubSeq(int A[], int N)
{
    int i;
    int ThisSum,MaxSum;
    ThisSum = 0,MaxSum = 0;
    for(i=0;i &lt; N;i++)
    {
        ThisSum += A[i];
        if(ThisSum &gt; MaxSum)
            MaxSum = ThisSum;
        else if(ThisSum &lt; 0)
            ThisSum = 0;
    }
    return MaxSum;
}

int main()
{
    int arr[100];
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=0;i&lt;n;i++)
        scanf(&quot;%d&quot;,&amp;arr[i]);
    printf(&quot;%d&quot;,MaxSubSeq(arr,n));
    return 0;
}
</code></pre>
<h2 id="pta-01-复杂度2-maximum-subsequence-sum"><a class="header" href="#pta-01-复杂度2-maximum-subsequence-sum">PTA 01-复杂度2 Maximum Subsequence Sum</a></h2>
<p>Given a sequence of K integers { N1​, N2​, ..., NK​ }. A continuous subsequence is defined to be { Ni​, Ni+1​, ..., Nj​ } where 1≤i≤j≤K. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.</p>
<p>Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer K (≤10000). The second line contains K numbers, separated by a space.</p>
<p>Output Specification:</p>
<p>For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.</p>
<p>Sample Input:</p>
<pre><code class="language-in">10
-10 1 2 3 4 -5 -23 3 7 -21
</code></pre>
<p>Sample Output:</p>
<pre><code class="language-out">10 1 4
</code></pre>
<p>注意：这里需特别注意输出部分，因为题目中说“<em>If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.</em>”（当输入的这K个数全为负时，输出的最大子列和应为0，并输出整个输入序列的首尾两个数）。那就需要对应MaxSum &gt;= 0和MaxSum &lt; 0的情况，之所以要把 = 0的情况放到前者，是因为 = 0可能是输入序列中有0有负的结果，比如输入6个数-2，0，-1，0，0，0。那最大子列和也是0但是显然不应输出题意要求的全为负情况下的首末两个数（-2和0）而是输出正常比较后的0和0（对应下标都为1）。</p>
<p>这也涉及到和前一题不同的MaxSum初值问题，因为输入全为负的情况下，累加时ThisSum不断重置为0，MaxSum保持不变，最后直接进入输出的else情况，符合题意。</p>
<pre><code>6
-2 0 -1 0 0 0
ThisSum=0, MaxSum=-1, MaxIndex=0, MinIndex=0, tmpMinIndex=1
ThisSum=0, MaxSum=0, MaxIndex=1, MinIndex=1, tmpMinIndex=1
ThisSum=0, MaxSum=0, MaxIndex=1, MinIndex=1, tmpMinIndex=3
ThisSum=0, MaxSum=0, MaxIndex=1, MinIndex=1, tmpMinIndex=3
ThisSum=0, MaxSum=0, MaxIndex=1, MinIndex=1, tmpMinIndex=3
ThisSum=0, MaxSum=0, MaxIndex=1, MinIndex=1, tmpMinIndex=3
0 0 0
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void MaxSubSumWithIndex(int List[], int K)
{
    int i;
    int MaxIndex = 0, MinIndex = 0, tmpMinIndex = 0;
    int ThisSum = 0, MaxSum = -1;    //这里MaxSum不能改成0
    for(i = 0; i &lt; K; i++)
    {
        ThisSum += List[i];
        if (ThisSum &gt; MaxSum)
        {
            MaxSum = ThisSum;
            MaxIndex = i;
            MinIndex = tmpMinIndex;
        }else if(ThisSum &lt; 0)
        {
            ThisSum = 0;
            tmpMinIndex = i + 1;
        }
        printf(&quot;ThisSum=%d, MaxSum=%d, MaxIndex=%d, MinIndex=%d, tmpMinIndex=%d\n&quot;,ThisSum, MaxSum, MaxIndex, MinIndex, tmpMinIndex);
    }
    if(MaxSum &gt;= 0)
      printf(&quot;%d %d %d\n&quot;, MaxSum, List[MinIndex], List[MaxIndex]);
    else
      printf(&quot;0 %d %d\n&quot;, List[0], List[K - 1]);
}

int main()
{
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    int arr[n];
    for(int i = 0; i&lt;n; i++)
        scanf(&quot;%d&quot;,&amp;arr[i]);
    MaxSubSumWithIndex(arr, n);
    return 0;
}
</code></pre>
<h2 id="pta-01-复杂度3-二分查找"><a class="header" href="#pta-01-复杂度3-二分查找">PTA 01-复杂度3 二分查找</a></h2>
<p>本题要求实现二分查找算法。</p>
<p>函数接口定义：</p>
<pre><code class="language-c++">Position BinarySearch( List L, ElementType X );
</code></pre>
<p>其中<code>List</code>结构定义如下：</p>
<pre><code class="language-c">typedef int Position;
typedef struct LNode *List;
struct LNode {
    ElementType Data[MAXSIZE];
    Position Last; /* 保存线性表中最后一个元素的位置 */
};
</code></pre>
<p><code>L</code>是用户传入的一个线性表，其中<code>ElementType</code>元素可以通过&gt;、<code>==</code>、&lt;进行比较，并且题目保证传入的数据是递增有序的。函数<code>BinarySearch</code>要查找<code>X</code>在<code>Data</code>中的位置，即数组下标（注意：元素从下标1开始存储）。找到则返回下标，否则返回一个特殊的失败标记<code>NotFound</code>。</p>
<p>裁判测试程序样例：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MAXSIZE 10
#define NotFound 0
typedef int ElementType;

typedef int Position;
typedef struct LNode *List;
struct LNode {
    ElementType Data[MAXSIZE];
    Position Last; /* 保存线性表中最后一个元素的位置 */
};

List ReadInput(); /* 裁判实现，细节不表。元素从下标1开始存储 */
Position BinarySearch( List L, ElementType X );

int main()
{
    List L;
    ElementType X;
    Position P;

    L = ReadInput();
    scanf(&quot;%d&quot;, &amp;X);
    P = BinarySearch( L, X );
    printf(&quot;%d\n&quot;, P);

    return 0;
}

/* 你的代码将被嵌在这里 */
</code></pre>
<p>\输入样例1：</p>
<pre><code>5
12 31 55 89 101
31
</code></pre>
<p>输出样例1：</p>
<pre><code>2
</code></pre>
<p>输入样例2：</p>
<pre><code>3
26 78 233
31
</code></pre>
<p>输出样例2：</p>
<pre><code>0
</code></pre>
<pre><code class="language-c">Position BinarySearch( List L, ElementType X )
{
    Position left = 1;
    Position right = L-&gt;Last;
    Position mid;
    while(left &lt;= right)
    {
        mid = (left + right) / 2;
        if(L-&gt;Data[mid] &lt; X)
            left = mid + 1;
        else if(L-&gt;Data[mid] &gt; X)
            right = mid - 1;
        else
            return mid;
    }
    return NotFound;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="线性结构"><a class="header" href="#线性结构">线性结构</a></h1>
<ul>
<li><a href="%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.html#%E9%93%BE%E8%A1%A8">链表</a>
<ul>
<li><a href="%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.html#%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%E8%AF%A6%E7%BB%86%E7%89%88">单链表功能实现详细版</a>
<ul>
<li><a href="%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.html#%E5%88%9B%E5%BB%BA%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4">创建、插入、删除</a></li>
<li><a href="%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.html#%E5%90%88%E5%B9%B6%E5%8F%8D%E8%BD%AC">合并、反转</a></li>
<li><a href="%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.html#%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8">有序链表</a></li>
<li><a href="%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.html#%E6%97%A0%E5%A4%B4%E5%8D%95%E9%93%BE%E8%A1%A8">无头单链表</a></li>
</ul>
</li>
<li><a href="%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.html#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8">双向链表</a>
<ul>
<li><a href="%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.html#%E6%99%AE%E9%80%9A%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8">普通双向链表</a></li>
<li><a href="%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.html#%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8">双向循环链表</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.html#%E5%8D%95%E9%93%BE%E8%A1%A8%E9%A2%98%E7%9B%AE">单链表题目</a>
<ul>
<li><a href="%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.html#pta6-1-%E5%8D%95%E9%93%BE%E8%A1%A8%E9%80%86%E8%BD%AC">PTA6-1 单链表逆转</a></li>
<li><a href="%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.html#pta-6-2-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%93%8D%E4%BD%9C%E9%9B%86">PTA 6-2 顺序表操作集</a></li>
<li><a href="%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.html#pta-6-3-%E6%B1%82%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%9A%84%E8%A1%A8%E9%95%BF">PTA 6-3 求链式表的表长</a></li>
<li><a href="%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.html#pta-6-4-%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%9A%84%E6%8C%89%E5%BA%8F%E5%8F%B7%E6%9F%A5%E6%89%BE">PTA 6-4 链式表的按序号查找</a></li>
<li><a href="%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.html#pta-6-5-%E9%93%BE%E5%BC%8F%E8%A1%A8%E6%93%8D%E4%BD%9C%E9%9B%86">PTA 6-5 链式表操作集</a></li>
</ul>
</li>
</ul>
<p>线性结构主要包括线性表、栈和队列。</p>
<p>线性表可以分成由数组实现的顺序表和由指针实现的链式表。</p>
<ul>
<li><strong>线性表：</strong> 逻辑结构， 就是对外暴露数据之间的关系，不关心底层如何实现，数据结构的逻辑结构大分类就是线性结构和非线性结构而顺序表、链表都是一种线性表。</li>
<li><strong>顺序表、链表：</strong> 物理结构，他是实现一个结构实际物理地址上的结构。比如顺序表就是用<strong>数组</strong>实现。而链表用<strong>指针</strong>完成主要工作。不同的结构在不同的场景有不同的区别。</li>
</ul>
<h1 id="链表"><a class="header" href="#链表">链表</a></h1>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311121348370.png" alt="" /></p>
<h2 id="单链表功能实现详细版"><a class="header" href="#单链表功能实现详细版">单链表功能实现详细版</a></h2>
<h3 id="创建插入删除"><a class="header" href="#创建插入删除">创建、插入、删除</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

typedef int ElementType;

typedef struct Node
{
    ElementType Data;
    struct Node *Next;
}NODE,*LIST,*LPNODE;

LIST createHead();
LPNODE createNode(ElementType X);
void insertByHead(LIST headNode, ElementType X);
void insertByBack(LIST headNode, ElementType X);
void insertByAppoin(LIST headNode, ElementType X, int posData);

void deleteByHead(LIST headNode);
void deleteByBack(LIST headNode);
void deleteByAppoin(LIST headNode, int posData);

void printList(LIST headNode);
void freeList(LIST* headNode);


LIST createHead()
{
    LIST headNode = (LIST)malloc(sizeof(struct Node));
    assert(headNode);
    headNode-&gt;Next = NULL;
    return headNode;
}

LPNODE createNode(ElementType X)
{
    LPNODE newNode = (LPNODE)malloc(sizeof(NODE));
    assert(newNode);
    newNode-&gt;Data = X;
    newNode-&gt;Next = NULL;
    return newNode;
}

void InsertByHead(LIST headNode, ElementType X)
{
    LPNODE newNode = createNode(X);
    newNode-&gt;Next = headNode-&gt;Next;
    headNode-&gt;Next = newNode;

}


void insertByBack(LIST headNode, ElementType X)
{
    LPNODE pMove = headNode;
    while(pMove-&gt;Next)
        pMove = pMove-&gt;Next;
    LPNODE newNode = createNode(X);
    pMove-&gt;Next = newNode;
}

void insertByAppoin(LIST headNode, ElementType X, int posData)
{
    LPNODE posLeftNode = headNode;
    LPNODE posNode = headNode-&gt;Next;
    while(posNode != NULL &amp;&amp; posData != posNode-&gt;Data)
    {
        posLeftNode = posNode;
        posNode = posNode-&gt;Next;
    }
    if(!posNode)
        printf(&quot;未找到，无法做指定数据所在的位置插入！\n&quot;);
    else
    {
        LPNODE newNode = createNode(X);
        newNode-&gt;Next = posNode;
        posLeftNode-&gt;Next = newNode;
        //这里可以不考虑顺序
    }
}

void deleteByHead(LIST headNode)
{
    LPNODE temp = headNode-&gt;Next;
    if(!temp)
        printf(&quot;链表为空，无法删除！\n&quot;);
    else
    {
        headNode-&gt;Next = temp-&gt;Next;
        free(temp);
    }
}
void deleteByBack(LIST headNode)
{
    LPNODE pTailLeft = headNode;
    LPNODE pTail = headNode-&gt;Next;
    while(pTail != NULL &amp;&amp; pTail-&gt;Next != NULL)
    {
        pTailLeft = pTail;
        pTail = pTail-&gt;Next;
    }
    if(pTail == NULL)
        printf(&quot;链表为空，无法删除！\n&quot;);
    else
    {
        free(pTail);
        pTailLeft-&gt;Next = NULL;
    }
}
void deleteByAppoin(LIST headNode, int posData)
{
    LPNODE posLeftNode = headNode;
    LPNODE posNode = headNode-&gt;Next;
    while(posNode &amp;&amp; posNode-&gt;Data != posData)
    {
        posLeftNode = posNode;
        posNode = posNode-&gt;Next;
    }
    if(!posNode)
        printf(&quot;无法删除指定数据！\n&quot;);
    else
    {
        posLeftNode-&gt;Next = posNode-&gt;Next;
        free(posNode);
        posNode = NULL;
    }
}

void printList(LIST headNode)
{
    if(headNode == NULL)
    {
        printf(&quot;无法打印链表，链表为空！\n&quot;);
        return;
    }
    LPNODE pMove = headNode-&gt;Next;
    while(pMove != NULL)
    {
        printf(&quot;%d &quot;,pMove-&gt;Data);
        pMove = pMove-&gt;Next;
    }
    printf(&quot;\n&quot;);
}
void freeList(LIST* headNode)
{
    if(headNode == NULL)  //写成if((*headNode) == NULL)也行
        return;
    LPNODE nextNode = NULL;
    while((*headNode) != NULL)
    {
        nextNode = (*headNode)-&gt;Next;
        free(*headNode);
        *headNode = nextNode;
    }
}

int main()
{
    LIST list = createHead();
    InsertByHead(list,1);
    InsertByHead(list,2);
    InsertByHead(list,3);
    InsertByHead(list,4);
    InsertByHead(list,5);
    printList(list);
    insertByBack(list,5);
    insertByBack(list,4);
    insertByBack(list,3);
    printList(list);
    insertByAppoin(list,6,2);
    insertByAppoin(list,7,2);
    printList(list);
    deleteByHead(list);
    deleteByBack(list);
    deleteByAppoin(list,2);
    printList(list);
    freeList(&amp;list);
    printList(list);

    return 0;
}
</code></pre>
<pre><code>5 4 3 2 1
5 4 3 2 1 5 4 3
5 4 3 6 7 2 1 5 4 3
4 3 6 7 1 5 4
无法打印链表，链表为空！
</code></pre>
<h3 id="合并反转"><a class="header" href="#合并反转">合并、反转</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

typedef int ElementType;

typedef struct Node
{
    ElementType Data;
    struct Node *Next;
}NODE,*LIST,*LPNODE;

LIST createHead();
LPNODE createNode(ElementType X);
void insertByHead(LIST headNode, ElementType X);
void insertByBack(LIST headNode, ElementType X);

void printList(LIST headNode);


LIST createHead()
{
    LIST headNode = (LIST)malloc(sizeof(struct Node));
    assert(headNode);
    headNode-&gt;Next = NULL;
    return headNode;
}

LPNODE createNode(ElementType X)
{
    LPNODE newNode = (LPNODE)malloc(sizeof(NODE));
    assert(newNode);
    newNode-&gt;Data = X;
    newNode-&gt;Next = NULL;
    return newNode;
}

void InsertByHead(LIST headNode, ElementType X)
{
    LPNODE newNode = createNode(X);
    newNode-&gt;Next = headNode-&gt;Next;
    headNode-&gt;Next = newNode;

}


void insertByBack(LIST headNode, ElementType X)
{
    LPNODE pMove = headNode;
    while(pMove-&gt;Next)
        pMove = pMove-&gt;Next;
    LPNODE newNode = createNode(X);
    pMove-&gt;Next = newNode;
}

void printList(LIST headNode)
{
    if(headNode == NULL)
    {
        printf(&quot;无法打印链表，链表为空！\n&quot;);
        return;
    }
    LPNODE pMove = headNode-&gt;Next;
    while(pMove != NULL)
    {
        printf(&quot;%d &quot;,pMove-&gt;Data);
        pMove = pMove-&gt;Next;
    }
    printf(&quot;\n&quot;);
}

void freeList(LIST* headNode)
{
    if(headNode == NULL)  //写成if((*headNode) == NULL)也行
        return;
    LPNODE nextNode = NULL;
    while((*headNode) != NULL)
    {
        nextNode = (*headNode)-&gt;Next;
        free(*headNode);
        *headNode = nextNode;
    }
}

LIST listCat(LIST list1, LIST list2)   //把list2加到list1的末尾。
{
    if(list1-&gt;Next == NULL || list2-&gt;Next == NULL)
        return (list1-&gt;Next == NULL) ? list2 : list1;
    LPNODE pMove = list1;
    while(pMove-&gt;Next)
    {
        pMove = pMove-&gt;Next;
    }
    pMove-&gt;Next = list2-&gt;Next;
    return list1;
}

LIST listCatByBack(LIST list1, LIST list2)   //把list2加到list1的末尾。这里使用尾插法
{

    LPNODE pMove = list2-&gt;Next;
    while(pMove != NULL)
    {
        insertByBack(list1,pMove-&gt;Data);
        pMove = pMove-&gt;Next;
    }
    return list1;
}

LIST listCatByValue(LIST list1, LIST list2)
{
    LIST list3 = createHead();
    LPNODE pFirst = list1-&gt;Next;

    while(pFirst)
    {
        LPNODE pSecond = list2-&gt;Next;
        while(pSecond)
        {
            if(pFirst-&gt;Data == pSecond-&gt;Data)
            {
                insertByBack(list3,pFirst-&gt;Data);
                break;
            }
            pSecond = pSecond-&gt;Next;
        }
        pFirst = pFirst-&gt;Next;

    }
    return list3;
}

void ListReverseFirst(LIST* list)
{
    LIST new_list = createHead();
    LPNODE pMove = (*list)-&gt;Next;
    while(pMove)
    {
        InsertByHead(new_list, pMove-&gt;Data);
        pMove = pMove-&gt;Next;
    }
    freeList(list);
    *list = new_list;
}

LIST ListReverse1(LIST list)
{
    LIST new_list = createHead();
    LPNODE pMove = list-&gt;Next;
    while(pMove)
    {
        InsertByHead(new_list, pMove-&gt;Data);
        pMove = pMove-&gt;Next;
    }
    return new_list;
}

void ListReverse2(LIST list)
{
    LPNODE pre = NULL;
    LPNODE cur = list-&gt;Next;
    LPNODE nextNode = list-&gt;Next;
    while(cur)
    {
        //先存储下一个，再反转
        nextNode = cur-&gt;Next;
        cur-&gt;Next = pre;
        pre = cur;
        cur = nextNode;
    }
    list-&gt;Next = pre;
}



int main()
{
    LIST list1 = createHead();
    InsertByHead(list1,4);
    InsertByHead(list1,2);
    InsertByHead(list1,1);
    printList(list1);
    LIST list2 =createHead();
    InsertByHead(list2,4);
    InsertByHead(list2,2);
    printList(list2);
    //LIST list3 = listCat(list1,list2);
    //printList(list3);
    //ListReverseFirst(&amp;list1);
    //printList(list1);
    ListReverse2(list1);
    printList(list1);
    return 0;
}

</code></pre>
<pre><code>1 2 4
2 4
4 2 1
</code></pre>
<h3 id="有序链表"><a class="header" href="#有序链表">有序链表</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

typedef int ElementType;

typedef struct Node
{
    ElementType Data;
    struct Node *Next;
}NODE,*LIST,*LPNODE;

LIST createHead()
{
    LIST headNode = (LIST)malloc(sizeof(struct Node));
    assert(headNode);
    headNode-&gt;Next = NULL;
    return headNode;
}

LPNODE createNode(ElementType X)
{
    LPNODE newNode = (LPNODE)malloc(sizeof(NODE));
    assert(newNode);
    newNode-&gt;Data = X;
    newNode-&gt;Next = NULL;
    return newNode;
}


void InsertBySort(LIST headNode, ElementType X)
{
    LPNODE newNode = createNode(X);
    LPNODE preNode = headNode;
    LPNODE posNode = headNode-&gt;Next;
    while(posNode != NULL &amp;&amp; posNode-&gt;Data &lt; X)
    {
        preNode = posNode;
        posNode = posNode-&gt;Next;
    }
    if(posNode == NULL)
    {
        preNode-&gt;Next = newNode;
    }
    else
    {
        preNode-&gt;Next = newNode;
        newNode-&gt;Next = posNode;
    }
}

void printList(LIST headNode)
{
    if(headNode == NULL)
    {
        printf(&quot;无法打印链表，链表为空！\n&quot;);
        return;
    }
    LPNODE pMove = headNode-&gt;Next;
    while(pMove != NULL)
    {
        printf(&quot;%d &quot;,pMove-&gt;Data);
        pMove = pMove-&gt;Next;
    }
    printf(&quot;\n&quot;);
}


int main()
{
    LIST list3 = createHead();
    InsertBySort(list3,4);
    InsertBySort(list3,5);
    InsertBySort(list3,1);
    InsertBySort(list3,40);
    InsertBySort(list3,53);
    InsertBySort(list3,12);
    InsertBySort(list3,49);
    InsertBySort(list3,25);
    InsertBySort(list3,19);
    printList(list3);
    return 0;
}
</code></pre>
<pre><code>1 2 4
2 4
1 4 5 12 19 25 40 49 53
</code></pre>
<h3 id="无头单链表"><a class="header" href="#无头单链表">无头单链表</a></h3>
<p>核心在于表头的处理，插入操作需要使用二级指针来修改头指针。要考虑链表为空的状态。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

typedef int ElementType;

struct Node
{
    ElementType Data;
    struct Node *Next;
};

struct Node* createNode(ElementType X)
{
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    assert(newNode);
    newNode-&gt;Data = X;
    newNode-&gt;Next = NULL;
    return newNode;
}

void InsertByHead(struct Node** headNode, ElementType X)
{
    struct Node* newNode = createNode(X);
    newNode-&gt;Next = *headNode;
    *headNode = newNode;
}

void InsertByBack(struct Node** headNode, ElementType X)
{
    if(headNode == NULL)
    {
        InsertByHead(headNode,X);
    }
    else
    {
        struct Node* pMove = *headNode;
        while(pMove-&gt;Next)
        {
            pMove = pMove-&gt;Next;
        }
        struct Node* newNode = createNode(X);
        pMove-&gt;Next = newNode;
    }
}

void printList(struct Node* headNode)
{
    struct Node* pMove = headNode;
    while(pMove != NULL)
    {
        printf(&quot;%d &quot;,pMove-&gt;Data);
        pMove = pMove-&gt;Next;
    }
    printf(&quot;\n&quot;);
}


int main()
{
    struct Node* list3 = NULL;
    InsertByHead(&amp;list3,4);
    InsertByHead(&amp;list3,5);
    InsertByHead(&amp;list3,1);
    InsertByHead(&amp;list3,40);
    printList(list3);
    printf(&quot;\n&quot;);
    InsertByBack(&amp;list3,53);
    InsertByBack(&amp;list3,12);
    InsertByBack(&amp;list3,49);
    InsertByBack(&amp;list3,25);
    InsertByBack(&amp;list3,19);
    printList(list3);
    return 0;
}
</code></pre>
<pre><code>40 1 5 4

40 1 5 4 53 12 49 25 19
</code></pre>
<h2 id="双向链表"><a class="header" href="#双向链表">双向链表</a></h2>
<h3 id="普通双向链表"><a class="header" href="#普通双向链表">普通双向链表</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

typedef struct Node *LPNODE;
typedef int ElementType;

struct Node
{
    LPNODE prev;
    LPNODE next;
    ElementType data;
};

LPNODE createNode(ElementType data)
{
    LPNODE newNode = (LPNODE)malloc((sizeof(struct Node)));
    assert(newNode);
    newNode-&gt;prev = NULL;
    newNode-&gt;next = NULL;
    newNode-&gt;data = data;
    return newNode;
}

//再封装的方式描述链表特性
struct List
{
    LPNODE firstNode;
    LPNODE lastNode;
    int listSize;
};
//创建链表，描述链表的初始状态
struct List* creatList()
{
    struct List* list = (struct List*)malloc(sizeof(struct List));
    //assert(list);
    //这里也可以写成if语句形式
    if(list == NULL)
        return NULL;
    list-&gt;firstNode = NULL;
    list-&gt;lastNode = NULL;
    list-&gt;listSize = 0;
    return list;
}
//表头插入
void InsertByHead(struct List* list, ElementType data)
{
    LPNODE newNode = createNode(data);
    if(list-&gt;listSize == 0)
    {
	    //第一次插入
        list-&gt;firstNode = newNode;
        list-&gt;lastNode = newNode;
        list-&gt;listSize++;
    }
    else
    {
        newNode-&gt;next = list-&gt;firstNode;
        list-&gt;firstNode-&gt;prev = newNode;
        list-&gt;firstNode = newNode;
        list-&gt;listSize++;
    }
}

void printListByHead(struct List* list)
{
    LPNODE pMove = list-&gt;firstNode;
    while(pMove)
    {
        printf(&quot;%d\t&quot;,pMove-&gt;data);
        pMove = pMove-&gt;next;
    }
    printf(&quot;\n&quot;);
}

void printListByRear(struct List* list)
{
    LPNODE pMove = list-&gt;lastNode;
    while(pMove)
    {
        printf(&quot;%d\t&quot;,pMove-&gt;data);
        pMove = pMove-&gt;prev;
    }
    printf(&quot;\n&quot;);
}

int main()
{
    struct List* list = creatList();
    for(int i=0; i&lt;5; i++)
        InsertByHead(list, i);
    printListByHead(list);
    printListByRear(list);
}
</code></pre>
<pre><code>4       3       2       1       0
0       1       2       3       4
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

typedef struct Node *LPNODE;
typedef int ElementType;

struct Node
{
    LPNODE prev;
    LPNODE next;
    ElementType data;
};

LPNODE createNode(ElementType data)
{
    LPNODE newNode = (LPNODE)malloc((sizeof(struct Node)));
    assert(newNode);
    newNode-&gt;prev = NULL;
    newNode-&gt;next = NULL;
    newNode-&gt;data = data;
    return newNode;
}

//再封装的方式描述链表特性
struct List
{
    LPNODE firstNode;
    LPNODE lastNode;
    int listSize;
};
//创建链表，描述链表的初始状态
struct List* creatList()
{
    struct List* list = (struct List*)malloc(sizeof(struct List));
    //assert(list);
    //这里也可以写成if语句形式
    if(list == NULL)
        return NULL;
    list-&gt;firstNode = NULL;
    list-&gt;lastNode = NULL;
    list-&gt;listSize = 0;
    return list;
}
//表头插入
void InsertByHead(struct List* list, ElementType data)
{
    LPNODE newNode = createNode(data);
    if(list-&gt;listSize == 0)
    {
        list-&gt;firstNode = newNode;
        list-&gt;lastNode = newNode;
        list-&gt;listSize++;
    }
    else
    {
        newNode-&gt;next = list-&gt;firstNode;
        list-&gt;firstNode-&gt;prev = newNode;
        list-&gt;firstNode = newNode;
        list-&gt;listSize++;
    }
}

//表尾插入
void InsertByTail(struct List* list, ElementType data)
{
    LPNODE newNode = createNode(data);
    if(list-&gt;listSize == 0)
    {
        list-&gt;firstNode = newNode;
        list-&gt;lastNode = newNode;
        list-&gt;listSize++;
    }
    else
    {
        newNode-&gt;prev = list-&gt;lastNode;
        list-&gt;lastNode-&gt;next = newNode;
        list-&gt;lastNode = newNode;
        list-&gt;listSize++;
    }
}

//指定数据处插入方式1
void InsertByAppointment(struct List* list, ElementType data, ElementType posData)
{
    LPNODE pos = list-&gt;firstNode;
    LPNODE preNode = NULL;
    while(pos != NULL &amp;&amp; pos-&gt;data != posData)
    {
        preNode = pos;
        pos = pos-&gt;next;
    }
    if(pos == NULL)
    {
        printf(&quot;Failed! There is no posData in this linked list!\n&quot;);
    }
    else if(pos == list-&gt;firstNode)
    {
        //指定位置为第一个结点，这时使用头插法
        InsertByHead(list,data);
    }
    else
    {
        LPNODE newNode = createNode(data);
        preNode-&gt;next = newNode;
        newNode-&gt;prev = preNode;
        newNode-&gt;next = pos;
        pos-&gt;prev = newNode;
        list-&gt;listSize++;
    }
}

void DeleteByHead(struct List* list)
{
    if(list-&gt;listSize == 0)
    {
        printf(&quot;The linked list is empty!\n&quot;);
        return;
    }
    LPNODE nextNode = list-&gt;firstNode-&gt;next;
    free(list-&gt;firstNode);
    list-&gt;firstNode = nextNode;
    if(list-&gt;listSize == 1)
        list-&gt;lastNode = NULL;
    else
        nextNode-&gt;prev = NULL;
    list-&gt;listSize--;
}

void DeleteByTail(struct List* list)
{
    if(list-&gt;listSize == 0)
    {
        printf(&quot;The linked list is empty!\n&quot;);
        return;
    }
    LPNODE prevNode = list-&gt;lastNode-&gt;prev;
    free(list-&gt;lastNode);
    list-&gt;lastNode = prevNode;
    if(list-&gt;listSize == 1)
        list-&gt;firstNode = NULL;
    else
        prevNode-&gt;next = NULL;
    list-&gt;listSize--;
}

int IsEmpty(struct List* list)
{
    return list-&gt;listSize == 0;
}

void printListByHead(struct List* list)
{
    LPNODE pMove = list-&gt;firstNode;
    while(pMove)
    {
        printf(&quot;%d\t&quot;,pMove-&gt;data);
        pMove = pMove-&gt;next;
    }
    printf(&quot;\n&quot;);
}

void printListByRear(struct List* list)
{
    LPNODE pMove = list-&gt;lastNode;
    while(pMove)
    {
        printf(&quot;%d\t&quot;,pMove-&gt;data);
        pMove = pMove-&gt;prev;
    }
    printf(&quot;\n&quot;);
}

int main()
{
    struct List* list = creatList();
    for(int i=0; i&lt;5; i++)
        InsertByHead(list, i);
    printListByHead(list);
    printListByRear(list);
    DeleteByHead(list);
    printListByHead(list);
    printListByRear(list);
    for(int i=0; i&lt;5; i++)
        InsertByTail(list, i);
    printListByHead(list);
    printListByRear(list);
    InsertByAppointment(list,100,4);
    printListByRear(list);
    InsertByAppointment(list,100,2);
    InsertByTail(list,30);
    printListByRear(list);
    InsertByAppointment(list,200,30);
    printListByHead(list);
    printListByRear(list);
    while(!IsEmpty(list))
    {
        DeleteByTail(list);
        printListByHead(list);
        printListByRear(list);
    }
}
</code></pre>
<pre><code>4       3       2       1       0
0       1       2       3       4
3       2       1       0
0       1       2       3
3       2       1       0       0       1       2       3       4
4       3       2       1       0       0       1       2       3
4       100     3       2       1       0       0       1       2       3
30      4       100     3       2       1       0       0       1       2       100     3
3       100     2       1       0       0       1       2       3       100     4       200     30
30      200     4       100     3       2       1       0       0       1       2       100     3
3       100     2       1       0       0       1       2       3       100     4       200
200     4       100     3       2       1       0       0       1       2       100     3
3       100     2       1       0       0       1       2       3       100     4
4       100     3       2       1       0       0       1       2       100     3
3       100     2       1       0       0       1       2       3       100
100     3       2       1       0       0       1       2       100     3
3       100     2       1       0       0       1       2       3
3       2       1       0       0       1       2       100     3
3       100     2       1       0       0       1       2
2       1       0       0       1       2       100     3
3       100     2       1       0       0       1
1       0       0       1       2       100     3
3       100     2       1       0       0
0       0       1       2       100     3
3       100     2       1       0
0       1       2       100     3
3       100     2       1
1       2       100     3
3       100     2
2       100     3
3       100
100     3
3
3
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202311261330779.png" alt="" /></p>
<p>指定位置删除需要特殊处理头和尾。。。</p>
<h3 id="双向循环链表"><a class="header" href="#双向循环链表">双向循环链表</a></h3>
<p>注意：这里最好写有头（头节点不存数据即可）的双向循环链表。。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202311261348761.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

typedef struct Node *LPNODE;
typedef int ElementType;

struct Node
{
    LPNODE prev;
    LPNODE next;
    ElementType data;
};

LPNODE createNode(ElementType data)
{
    //新节点不需要是环形
    LPNODE newNode = (LPNODE)malloc((sizeof(struct Node)));
    assert(newNode);
    newNode-&gt;prev = NULL;
    newNode-&gt;next = NULL;
    newNode-&gt;data = data;
    return newNode;
}

//创建链表，描述链表的初始状态
struct Node* creatList()
{
    //单个节点指向自身，形成环形
    struct Node* headNode = (struct Node*)malloc(sizeof(struct Node));
    //assert(list);
    //这里也可以写成if语句形式
    if(headNode == NULL)
        return NULL;
    headNode-&gt;prev = headNode;
    headNode-&gt;next = headNode;
    return headNode;
}

//表尾插入
void InsertByTail(struct Node* headNode, ElementType data)
{
    LPNODE newNode = createNode(data);
    LPNODE temp = headNode-&gt;prev;
    //headNode-&gt;prev是最后一个结点
    newNode-&gt;next = headNode;
    headNode-&gt;prev = newNode;
    temp-&gt;next = newNode;
    newNode-&gt;prev = temp;
}

void InsertByAppointment(struct Node* headNode, ElementType data, ElementType posData)
{
    LPNODE preNode = headNode;
    LPNODE posNode = headNode-&gt;next;
    while(headNode != posNode &amp;&amp; posData != posNode-&gt;data)
    {
        preNode = posNode;
        posNode = posNode-&gt;next;
    }
    if(headNode == posNode)
    {
        printf(&quot;The posData is not in this linked list!\n&quot;);
        return;
    }
    else
    {
        LPNODE newNode = createNode(data);
        newNode-&gt;next = posNode;
        posNode-&gt;prev = newNode;
        preNode-&gt;next = newNode;
        newNode-&gt;prev = preNode;
    }
}

void printListByHead(struct Node* headNode)
{
    LPNODE pMove = headNode-&gt;next;
    while(pMove != headNode)
    {
        printf(&quot;%d\t&quot;,pMove-&gt;data);
        pMove = pMove-&gt;next;
    }
    printf(&quot;\n&quot;);
}

void printListByTail(struct Node* headNode)
{
    LPNODE pMove = headNode-&gt;prev;
    while(pMove != headNode)
    {
        printf(&quot;%d\t&quot;,pMove-&gt;data);
        pMove = pMove-&gt;prev;
    }
    printf(&quot;\n&quot;);
}


int main()
{
    struct Node* list = creatList();
    for(int i=0; i&lt;5; i++)
        InsertByTail(list, i);
    printListByHead(list);
    printListByTail(list);
    InsertByAppointment(list, 100, 2);
    printListByHead(list);
    printListByTail(list);
    return 0;
}
</code></pre>
<pre><code>0       1       2       3       4
4       3       2       1       0
0       1       100     2       3       4
4       3       2       100     1       0
</code></pre>
<h1 id="单链表题目"><a class="header" href="#单链表题目">单链表题目</a></h1>
<h2 id="pta6-1-单链表逆转"><a class="header" href="#pta6-1-单链表逆转">PTA6-1 单链表逆转</a></h2>
<p>本题要求实现一个函数，将给定的单链表逆转。</p>
<p>函数接口定义：</p>
<pre><code class="language-c">List Reverse( List L );
</code></pre>
<p>其中<code>List</code>结构定义如下：</p>
<pre><code class="language-c">typedef struct Node *PtrToNode;
struct Node {
    ElementType Data; /* 存储结点数据 */
    PtrToNode   Next; /* 指向下一个结点的指针 */
};
typedef PtrToNode List; /* 定义单链表类型 */
</code></pre>
<p><code>L</code>是给定单链表，函数<code>Reverse</code>要返回被逆转后的链表。</p>
<p>裁判测试程序样例：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef int ElementType;
typedef struct Node *PtrToNode;
struct Node {
    ElementType Data;
    PtrToNode   Next;
};
typedef PtrToNode List;

List Read(); /* 细节在此不表 */
void Print( List L ); /* 细节在此不表 */

List Reverse( List L );

int main()
{
    List L1, L2;
    L1 = Read();
    L2 = Reverse(L1);
    Print(L1);
    Print(L2);
    return 0;
}

/* 你的代码将被嵌在这里 */
</code></pre>
<p>输入样例：</p>
<pre><code>5
1 3 4 5 2
</code></pre>
<p>输出样例：</p>
<pre><code>1
2 5 4 3 1
</code></pre>
<p>双指针解法：</p>
<pre><code class="language-c">List Reverse( List L )
{
    List cur = L;
    List pre = NULL;
    while(cur!=NULL)
    {
        List temp = cur-&gt;Next;
        cur-&gt;Next = pre;
        pre = cur;
        cur = temp;
    }
    return pre;
}
</code></pre>
<p>递归解法：</p>
<pre><code class="language-c">List Reverse( List L )
{
    if(L==NULL||L-&gt;Next==NULL)
        return L;
    List cur = Reverse(L-&gt;Next);
    L-&gt;Next-&gt;Next=L;
    L-&gt;Next=NULL;
    
    return cur;
    
}
</code></pre>
<h2 id="pta-6-2-顺序表操作集"><a class="header" href="#pta-6-2-顺序表操作集">PTA 6-2 顺序表操作集</a></h2>
<p>本题要求实现顺序表的操作集。</p>
<p>函数接口定义：</p>
<pre><code class="language-c">List MakeEmpty(); 
Position Find( List L, ElementType X );
bool Insert( List L, ElementType X, Position P );
bool Delete( List L, Position P );
</code></pre>
<p>其中<code>List</code>结构定义如下：</p>
<pre><code class="language-c">typedef int Position;
typedef struct LNode *List;
struct LNode {
    ElementType Data[MAXSIZE];
    Position Last; /* 保存线性表中最后一个元素的位置 */
};
</code></pre>
<p>各个操作函数的定义为：</p>
<p><code>List MakeEmpty()</code>：创建并返回一个空的线性表；</p>
<p><code>Position Find( List L, ElementType X )</code>：返回线性表中X的位置。若找不到则返回ERROR；</p>
<p><code>bool Insert( List L, ElementType X, Position P )</code>：将X插入在位置P并返回true。若空间已满，则打印“FULL”并返回false；如果参数P指向非法位置，则打印“ILLEGAL POSITION”并返回false；</p>
<p><code>bool Delete( List L, Position P )</code>：将位置P的元素删除并返回true。若参数P指向非法位置，则打印“POSITION P EMPTY”（其中P是参数值）并返回false。</p>
<p>裁判测试程序样例：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MAXSIZE 5
#define ERROR -1
typedef enum {false, true} bool;
typedef int ElementType;
typedef int Position;
typedef struct LNode *List;
struct LNode {
    ElementType Data[MAXSIZE];
    Position Last; /* 保存线性表中最后一个元素的位置 */
};

List MakeEmpty(); 
Position Find( List L, ElementType X );
bool Insert( List L, ElementType X, Position P );
bool Delete( List L, Position P );

int main()
{
    List L;
    ElementType X;
    Position P;
    int N;

    L = MakeEmpty();
    scanf(&quot;%d&quot;, &amp;N);
    while ( N-- ) {
        scanf(&quot;%d&quot;, &amp;X);
        if ( Insert(L, X, 0)==false )
            printf(&quot; Insertion Error: %d is not in.\n&quot;, X);
    }
    scanf(&quot;%d&quot;, &amp;N);
    while ( N-- ) {
        scanf(&quot;%d&quot;, &amp;X);
        P = Find(L, X);
        if ( P == ERROR )
            printf(&quot;Finding Error: %d is not in.\n&quot;, X);
        else
            printf(&quot;%d is at position %d.\n&quot;, X, P);
    }
    scanf(&quot;%d&quot;, &amp;N);
    while ( N-- ) {
        scanf(&quot;%d&quot;, &amp;P);
        if ( Delete(L, P)==false )
            printf(&quot; Deletion Error.\n&quot;);
        if ( Insert(L, 0, P)==false )
            printf(&quot; Insertion Error: 0 is not in.\n&quot;);
    }
    return 0;
}

/* 你的代码将被嵌在这里 */
</code></pre>
<p>输入样例：</p>
<pre><code class="language-in">6
1 2 3 4 5 6
3
6 5 1
2
-1 6
</code></pre>
<p>输出样例：</p>
<pre><code class="language-out">FULL Insertion Error: 6 is not in.
Finding Error: 6 is not in.
5 is at position 0.
1 is at position 4.
POSITION -1 EMPTY Deletion Error.
FULL Insertion Error: 0 is not in.
POSITION 6 EMPTY Deletion Error.
FULL Insertion Error: 0 is not in.
</code></pre>
<pre><code class="language-c">List MakeEmpty()
{
    List PtrL;
    PtrL=(List)malloc(sizeof(struct LNode));
    PtrL-&gt;Last=-1;
    return PtrL;
}
Position Find( List L, ElementType X )
{
    for(Position i=0;i&lt;=L-&gt;Last+1;i++)
    {
        if(L-&gt;Data[i]==X)
            return i;
    }
    return ERROR;
    /*int i=0;
    while(i&lt;L-&gt;Last&amp;&amp;L-&gt;Data[i]!=X)
        i++;
    if(i&gt;L-&gt;Last) return ERROR;//如果没找到，返回ERROR
    else return i;//找到后返回的是存储位置*/
}
bool Insert( List L, ElementType X, Position P )
{
    if(L-&gt;Last==MAXSIZE-1)
    {
        printf(&quot;FULL&quot;);
        return false;
    }
    if(P&lt;0||P&gt;L-&gt;Last+1||P&gt;=MAXSIZE)
    {
        printf(&quot;ILLEGAL POSITION&quot;);
        return false;
    }
    for(int j=L-&gt;Last;j&gt;=P;j--)
    {
        L-&gt;Data[j+1]=L-&gt;Data[j];
    }
    L-&gt;Data[P]=X;
    L-&gt;Last++;
    return true;

}
bool Delete( List L, Position P )
{
    if(P&lt;0||P&gt;L-&gt;Last)
    {
        printf(&quot;POSITION %d EMPTY&quot;,P);
        return false;
    }
    if(P!=L-&gt;Last)
    {
        for(int j=P;j&lt;L-&gt;Last;j++)
            L-&gt;Data[j]=L-&gt;Data[j+1];
    }
    L-&gt;Last--;
    return true;
}
</code></pre>
<h2 id="pta-6-3-求链式表的表长"><a class="header" href="#pta-6-3-求链式表的表长">PTA 6-3 求链式表的表长</a></h2>
<p>本题要求实现一个函数，求链式表的表长。</p>
<p>函数接口定义：</p>
<pre><code class="language-c">int Length( List L );
</code></pre>
<p>其中<code>List</code>结构定义如下：</p>
<pre><code class="language-c">typedef struct LNode *PtrToLNode;
struct LNode {
    ElementType Data;
    PtrToLNode Next;
};
typedef PtrToLNode List;
</code></pre>
<p><code>L</code>是给定单链表，函数<code>Length</code>要返回链式表的长度。</p>
<p>裁判测试程序样例：</p>
<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef int ElementType;
typedef struct LNode *PtrToLNode;
struct LNode {
    ElementType Data;
    PtrToLNode Next;
};
typedef PtrToLNode List;

List Read(); /* 细节在此不表 */

int Length( List L );

int main()
{
    List L = Read();
    printf(&quot;%d\n&quot;, Length(L));
    return 0;
}

/* 你的代码将被嵌在这里 */
</code></pre>
<p>输入样例：</p>
<pre><code>1 3 4 5 2 -1
</code></pre>
<p>输出样例：</p>
<pre><code>5
</code></pre>
<pre><code class="language-c">int Length( List L )
{
    List head=L;
    int length=0;
    while(head!=NULL)
    {
        length++;
        head=head-&gt;Next;
    }
    return length;
}
</code></pre>
<h2 id="pta-6-4-链式表的按序号查找"><a class="header" href="#pta-6-4-链式表的按序号查找">PTA 6-4 链式表的按序号查找</a></h2>
<p>本题要求实现一个函数，找到并返回链式表的第K个元素。</p>
<p>函数接口定义：</p>
<pre><code class="language-c">ElementType FindKth( List L, int K );
</code></pre>
<p>其中<code>List</code>结构定义如下：</p>
<pre><code class="language-c">typedef struct LNode *PtrToLNode;
struct LNode {
    ElementType Data;
    PtrToLNode Next;
};
typedef PtrToLNode List;
</code></pre>
<p><code>L</code>是给定单链表，函数<code>FindKth</code>要返回链式表的第<code>K</code>个元素。如果该元素不存在，则返回<code>ERROR</code>。</p>
<p>裁判测试程序样例：</p>
<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define ERROR -1
typedef int ElementType;
typedef struct LNode *PtrToLNode;
struct LNode {
    ElementType Data;
    PtrToLNode Next;
};
typedef PtrToLNode List;

List Read(); /* 细节在此不表 */

ElementType FindKth( List L, int K );

int main()
{
    int N, K;
    ElementType X;
    List L = Read();
    scanf(&quot;%d&quot;, &amp;N);
    while ( N-- ) {
        scanf(&quot;%d&quot;, &amp;K);
        X = FindKth(L, K);
        if ( X!= ERROR )
            printf(&quot;%d &quot;, X);
        else
            printf(&quot;NA &quot;);
    }
    return 0;
}

/* 你的代码将被嵌在这里 */
</code></pre>
<p>输入样例：</p>
<pre><code class="language-in">1 3 4 5 2 -1
6
3 6 1 5 4 2
</code></pre>
<p>输出样例：</p>
<pre><code class="language-out">4 NA 1 2 5 3 
</code></pre>
<pre><code class="language-C">ElementType FindKth( List L, int K )
{
    List p = L;
    if(p==NULL)
        return ERROR;
    int i = 1;
    while(p!=NULL &amp;&amp; i&lt;K)
    {
        p=p-&gt;Next;
        i++;
    }
    if(i==K)
        return p-&gt;Data;
    else return ERROR; 
    
}
</code></pre>
<p>这样写会在测试题中数据时报错<code>段错误</code>，这是<code>if(i==K)</code>这个判断条件不严谨导致的。</p>
<p>设想一下K=2; L的长度仅为1，这个程序会进入while循环，然后i=2，但此时p结点对应的Data不存在。这时输出会报错<code>段错误</code>。修改后能AC的代码如下：</p>
<pre><code class="language-c">ElementType FindKth( List L, int K )
{
    List p = L;
    int i = 1;
    if(p==NULL)
        return ERROR;
    else
    {
        while(p!=NULL &amp;&amp; i&lt;K)
        {
            p=p-&gt;Next;
            i++;
        }
        if(p!=NULL &amp;&amp; i==K)
            return p-&gt;Data;
        else return ERROR; 
    }
    
}
</code></pre>
<p>下面是另一种能AC的代码：</p>
<pre><code class="language-c">ElementType FindKth( List L, int K )
{
    int i = 1;
    while(L)
    {
        if(i==K)
            return L-&gt;Data;
        i++;
        L=L-&gt;Next;
    }
    return ERROR;
    
}
</code></pre>
<p>这里的if语句要放在链表后移操作之前，因为要判断当前结点是否满足条件，如果放在后面就会漏掉第一个值。</p>
<p>若能找到符合要求的值，则在while循环中就会返回内容；如果while循环结束也没找到，程序会直接返回ERROR。</p>
<p>补全的<code>Read()</code>函数代码如下：</p>
<pre><code class="language-c">List Read()
{
    List L,p,r;
    int num = 0;
    L = (List)malloc(sizeof(List));
    r = L;
    do
    {
        scanf(&quot;%d&quot;,&amp;num);
        p=(List)malloc(sizeof(List));
        p-&gt;Data = num;
        r-&gt;Next = p;
        r = p;
    }while(getchar()!='\n');

    r-&gt;Next = NULL;
    return L-&gt;Next;
}
</code></pre>
<h2 id="pta-6-5-链式表操作集"><a class="header" href="#pta-6-5-链式表操作集">PTA 6-5 链式表操作集</a></h2>
<p>本题要求实现链式表的操作集。</p>
<p>函数接口定义：</p>
<pre><code class="language-c">Position Find( List L, ElementType X );
List Insert( List L, ElementType X, Position P );
List Delete( List L, Position P );
</code></pre>
<p>其中<code>List</code>结构定义如下：</p>
<pre><code class="language-c">typedef struct LNode *PtrToLNode;
struct LNode {
    ElementType Data;
    PtrToLNode Next;
};
typedef PtrToLNode Position;
typedef PtrToLNode List;
</code></pre>
<p>各个操作函数的定义为：</p>
<p><code>Position Find( List L, ElementType X )</code>：返回线性表中首次出现X的位置。若找不到则返回ERROR；</p>
<p><code>List Insert( List L, ElementType X, Position P )</code>：将X插入在位置P指向的结点之前，返回链表的表头。如果参数P指向非法位置，则打印“Wrong Position for Insertion”，返回ERROR；</p>
<p><code>List Delete( List L, Position P )</code>：将位置P的元素删除并返回链表的表头。若参数P指向非法位置，则打印“Wrong Position for Deletion”并返回ERROR。</p>
<p>裁判测试程序样例：</p>
<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define ERROR NULL
typedef int ElementType;
typedef struct LNode *PtrToLNode;
struct LNode {
    ElementType Data;
    PtrToLNode Next;
};
typedef PtrToLNode Position;
typedef PtrToLNode List;

Position Find( List L, ElementType X );
List Insert( List L, ElementType X, Position P );
List Delete( List L, Position P );

int main()
{
    List L;
    ElementType X;
    Position P, tmp;
    int N;

    L = NULL;
    scanf(&quot;%d&quot;, &amp;N);
    while ( N-- ) {
        scanf(&quot;%d&quot;, &amp;X);
        L = Insert(L, X, L);
        if ( L==ERROR ) printf(&quot;Wrong Answer\n&quot;);
    }
    scanf(&quot;%d&quot;, &amp;N);
    while ( N-- ) {
        scanf(&quot;%d&quot;, &amp;X);
        P = Find(L, X);
        if ( P == ERROR )
            printf(&quot;Finding Error: %d is not in.\n&quot;, X);
        else {
            L = Delete(L, P);
            printf(&quot;%d is found and deleted.\n&quot;, X);
            if ( L==ERROR )
                printf(&quot;Wrong Answer or Empty List.\n&quot;);
        }
    }
    L = Insert(L, X, NULL);
    if ( L==ERROR ) printf(&quot;Wrong Answer\n&quot;);
    else
        printf(&quot;%d is inserted as the last element.\n&quot;, X);
    P = (Position)malloc(sizeof(struct LNode));
    tmp = Insert(L, X, P);
    if ( tmp!=ERROR ) printf(&quot;Wrong Answer\n&quot;);
    tmp = Delete(L, P);
    if ( tmp!=ERROR ) printf(&quot;Wrong Answer\n&quot;);
    for ( P=L; P; P = P-&gt;Next ) printf(&quot;%d &quot;, P-&gt;Data);
    return 0;
}

/* 你的代码将被嵌在这里 */
</code></pre>
<p>输入样例：</p>
<pre><code class="language-in">6
12 2 4 87 10 2
4
2 12 87 5
</code></pre>
<p>输出样例：</p>
<pre><code class="language-out">2 is found and deleted.
12 is found and deleted.
87 is found and deleted.
Finding Error: 5 is not in.
5 is inserted as the last element.
Wrong Position for Insertion
Wrong Position for Deletion
10 4 2 5 
</code></pre>
<p>根据课堂代码改写的代码如下：</p>
<pre><code class="language-c">Position Find( List L, ElementType X )
{
    List p = L;
    while(p!=NULL &amp;&amp; p-&gt;Data!=X)
        p=p-&gt;Next;
    return p;
}
</code></pre>
<p>另一种能AC的代码如下：</p>
<pre><code class="language-c">
Position Find( List L, ElementType X )
{
    while(L)
    {
        if(L-&gt;Data==X)
            return L;
        L = L-&gt;Next;
    }
    return ERROR;
}
List Insert( List L, ElementType X, Position P )
{
    List head = L;
    List p = (List)malloc(sizeof(List));
    p-&gt;Data = X;
    p-&gt;Next = NULL;
    if(L==P)
    {
        p-&gt;Next = L;
        return p;
    }
    while(L)
    {
        if(P==L-&gt;Next)
        {
            p-&gt;Next = L-&gt;Next;
            L-&gt;Next = p;
            return head;
        }
        L=L-&gt;Next;
    }
    printf(&quot;Wrong Position for Insertion\n&quot;);
    return ERROR;


}
List Delete( List L, Position P )
{
    if(L==P)
    {
        L = L-&gt;Next;
        return L;
    }
    List head = L;
    while(L)
    {
        if(L-&gt;Next==P)
        {
            L-&gt;Next=P-&gt;Next;
            return head;
        }
        L=L-&gt;Next;
    }
    printf(&quot;Wrong Position for Deletion\n&quot;);
    return ERROR;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="线性表linear-list"><a class="header" href="#线性表linear-list">线性表Linear List</a></h1>
<ul>
<li><a href="%E7%BA%BF%E6%80%A7%E8%A1%A8.html#%E5%BC%95%E5%AD%90%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%A1%A8%E7%A4%BA">引子：多项式表示</a></li>
<li><a href="%E7%BA%BF%E6%80%A7%E8%A1%A8.html#%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%AE%9A%E4%B9%89">线性表定义</a>
<ul>
<li><a href="%E7%BA%BF%E6%80%A7%E8%A1%A8.html#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89">线性表的抽象数据类型定义</a></li>
<li><a href="%E7%BA%BF%E6%80%A7%E8%A1%A8.html#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0">线性表的顺序存储实现</a></li>
<li><a href="%E7%BA%BF%E6%80%A7%E8%A1%A8.html#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0">线性表的链式存储实现</a></li>
<li><a href="%E7%BA%BF%E6%80%A7%E8%A1%A8.html#%E5%B9%BF%E4%B9%89%E8%A1%A8%E5%92%8C%E5%A4%9A%E9%87%8D%E9%93%BE%E8%A1%A8">广义表和多重链表</a></li>
</ul>
</li>
</ul>
<h2 id="引子多项式表示"><a class="header" href="#引子多项式表示">引子：多项式表示</a></h2>
<p>一元多项式及其运算：<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8144em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></p>
<p>主要运算：多项式相加、相减、相乘等</p>
<p>分析：如何表示多项式？</p>
<p>（1）顺序存储结构直接表示</p>
<p>数组各分量对应多项式各项，<code>a[i]</code>：项<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的系数<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>两个多项式相加：两个数组对应分量相加</p>
<p>问题：如何表示多项式<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">3</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2000</span></span></span></span></span></span></span></span></span></span></span></span>？</p>
<p>空间利用率较低</p>
<p>（2）顺序存储结构表示非零项</p>
<p>每个非零项<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9747em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span>涉及两个信息：系数<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和指数i</p>
<p>可以将一个多项式看成是一个<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span>二元组的集合。</p>
<p>用结构数组表示：数组分量是由系数<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、指数i组成的结构，对应一个非零项</p>
<p>例如：<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">9</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">15</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">3</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>       <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">26</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">19</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">13</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">82</span></span></span></span></p>
<p>为了方便相加可以<strong>按指数大小存储</strong>！</p>
<p>相加过程：从头开始，比较两个多项式当前对应项的指数</p>
<p>（3）链表结构存储非零项</p>
<p>链表中每个节点存储多项式中的一个非零项，包括系数和指数两个数据域以及一个指针域</p>
<div class="table-wrapper"><table><thead><tr><th>coef</th><th>expon</th><th>link</th></tr></thead><tbody>
</tbody></table>
</div>
<pre><code class="language-c">typedef struct PolyNode *Polynomial;

struct PolyNode
{
    int coef;
    int expon;
    Polynomial link;
};
</code></pre>
<h2 id="线性表定义"><a class="header" href="#线性表定义">线性表定义</a></h2>
<p>多项式表示问题的启示：</p>
<p>1.同一个问题可以有不同的表示（存储）方法</p>
<p>2.有一类共性问题：有序线性序列的组织和管理</p>
<p>线性表：0个或多个同类型数据元素的<font color="red">有限序列</font>。</p>
<p>班级同学的花名册是线性表，因为这是有限序列。在较复杂的线性表中，一个数据元素可以由若干个数据项组成。</p>
<h3 id="线性表的抽象数据类型定义"><a class="header" href="#线性表的抽象数据类型定义">线性表的抽象数据类型定义</a></h3>
<p>线性表的抽象数据类型定义如下：</p>
<pre><code>ADT 线性表(List)
Data
	线性表的数据对象集合为{a1,a2,...,an}，每个元素的类型均为DataType。其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。
Operation
	InitList(*L):初始化操作，建立一个空的线性表L。
	ListEmpty(L):若线性表为空，返回true，否则返回false。
	ClearList(*L)：将线性表清空。
	GetElem(L,i,*e)：将线性表L中的第i个未知元素值返回给e。
	LocateElem(L,e)：在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回0表示失败。
	ListInsert(*L,i,e)：在线性表L中的第i个位置插入新元素e。
	ListDelete(*L,i,*e)：删除线性表L中第i个位置元素，并用e返回其值。
	ListLength(L)：返回线性表L的元素个数。
endADT
</code></pre>
<h3 id="线性表的顺序存储实现"><a class="header" href="#线性表的顺序存储实现">线性表的顺序存储实现</a></h3>
<p>利用数组的连续存储空间顺序存放线性表的各元素</p>
<pre><code class="language-c">typedef struct LNode* List;

struct LNode
{
    ElementType Data[MAXSIZE];
    int Last;//记录最后一位有效位
};
struct LNode L;
List PtrL;
</code></pre>
<p>访问下标为i的元素：<code>L.Data[i]</code>或<code>PtrL-&gt;Data[i]</code></p>
<p>线性表的长度：<code>L.Last+1</code>或<code>PtrL-&gt;Last+1</code></p>
<p>陈越姥姥《数据结构》课程实现版本：</p>
<pre><code class="language-c">#define MAXSIZE 20 /*存储空间初始分配量*/

typedef struct LNode* List;

struct LNode
{
    ElementType Data[MAXSIZE];
    int Last;//记录最后一位有效位
};
struct LNode L;
List PtrL;

List MakeEmpty()
{
    List PtrL;
    PtrL=(List)malloc(sizeof(struct LNode));
    PtrL-&gt;Last=-1;
    return PtrL;
}
int Find(ElementType X,List PtrL)
{
    int i=0;
    while(i&lt;=PtrL-&gt;Last&amp;&amp;PtrL-&gt;Data[i]!=X)
        i++;
    if(i&gt;PtrL-&gt;Last) return -1;//如果没找到，返回-1
    else return i;//找到后返回的是存储位置（下标）
}

/*插入（第i（1&lt;=i&lt;=n+1）个位置上插入一个值为X的新元素*/

void Insert(ElementType X,int i,List PtrL)       /*i是序数，为下标+1，不是下标*/
{
    int j;
    if(PtrL-&gt;Last==MAXSIZE-1) /*表空间已满，不能插入*/
    {
        printf(&quot;表满&quot;);
        return;
    }
    if(i&lt;1||i&gt;PtrL-&gt;Last+2)    /*检查插入位置的合法性*/
    {
        printf(&quot;位置不合法&quot;);
        return;
    }
    for(j=PtrL-&gt;Last;j&gt;=i-1;j--)
        PtrL-&gt;Data[j+1]=PtrL-&gt;Data[j];    /*将ai~an倒序向后移动*/
    PtrL-&gt;Data[i-1]=X;       /*新元素插入*/
    PtrL-&gt;Last++;        /*Last仍指向最后一个元素*/
    return;
}

/*删除：删除表的第i（1&lt;=i&lt;=n）个位置上的元素*/

void Delete(int i,List PtrL)
{
    int j;
    if(i&lt;1||i&gt;PtrL-&gt;Last+1)    /*检查是否为空表及删除位置的合法性*/
    {
        printf(&quot;不存在第%d个元素&quot;,i);
        return;
    }
    for(j=i;j&lt;=PtrL-&gt;Last;j++)
        PtrL-&gt;Data[j-1]=PtrL-&gt;Data[j];     /*将a(i+1)~an顺序向前移动*/
    PtrL-&gt;Last--;         /*Last仍指向最后一个元素*/
    return;
}
</code></pre>
<p>《大话数据结构》给出的顺序存储的链表实例：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

#define MAXSIZE 100
#define OK 1
#define ERROR 0
#define OVERFLOW -2             //这样就为 `OVERFLOW` 定义了一个值为 `-2` 的常量。

typedef int ElemType;
typedef int Status;

typedef struct
{
    ElemType *elem;
    int length;
}SqList;

//线性表的初始化
Status InitList(SqList &amp;L)
{
    L.elem=new ElemType[MAXSIZE];
    if(!L.elem)
        exit(OVERFLOW);
    L.length=0;
    return OK;
}
//线性表的取值
Status GetElem(SqList L,int i,ElemType &amp;e)
{
    if(i&lt;1||i&gt;L.length)
        return ERROR;
    e=L.elem[i-1];
    return OK;
}
//查找元素
int LocateElem(SqList L,ElemType e)
{
    for(int i=0;i&lt;L.length;i++)
    {
        if(L.elem[i]==e)
            return i+1;
    }
    return 0;
}
//线性表插入元素
Status ListInsert(SqList &amp;L,int i,ElemType e)
{
    if(i&lt;1||i&gt;L.length+1)
        return ERROR;
    if(L.length==MAXSIZE)
        return ERROR;
    for(int j=L.length-1;j&gt;=i-1;j--)
    {
        L.elem[j+1]=L.elem[j];
    }
    L.elem[i-1]=e;
    L.length++;
    return OK;
}
//线性表删除元素
Status ListDelete(SqList &amp;L,int i)
{
    if(i&lt;1||i&gt;L.length)
        return ERROR;
    for(int j=i;j&lt;=L.length-1;j++)
        L.elem[j-1]=L.elem[j];
    L.length--;
    return OK;
}
//打印线性表
Status Display(SqList &amp;L)
{
    for(int i=0;i&lt;L.length;i++)
        printf(&quot;%d &quot;,L.elem[i]);
    printf(&quot;\n&quot;);
    return 0;
}

int main()
{
    SqList L;
    int v,k,opt;
    InitList(L);
    printf(&quot;1：在线性表中存入5个值\n&quot;);
    printf(&quot;2：查找线性表中的元素\n&quot;);
    printf(&quot;3：向线性表中插入一个元素\n&quot;);
    printf(&quot;4：从线性表中删除一个元素\n&quot;);
    printf(&quot;5：退出\n&quot;);
    while(1)
    {
        printf(&quot;输入你的选择：&quot;);
        cin&gt;&gt;opt;
        if(opt==1)
        {
            printf(&quot;请输入要插入的5个值：&quot;);
            for(int i=1;i&lt;=5;i++)
            {
                cin&gt;&gt;v;
                ListInsert(L,i,v);
            }
            printf(&quot;当前线性表为：&quot;);
            Display(L);
        }
        else if(opt==2)
        {
            printf(&quot;请输入要查找的元素：&quot;);
            cin&gt;&gt;v;
            k=LocateElem(L,v);
            printf(&quot;要查找的元素的所在的位置为：%d\n&quot;,k);
        }
        else if(opt==3)
        {
            printf(&quot;请输入要插入的元素及插入的位置：&quot;);
            cin&gt;&gt;v&gt;&gt;k;
            ListInsert(L,k,v);
            printf(&quot;插入元素后的线性表为：&quot;);
            Display(L);
        }
        else if(opt==4)
        {
            printf(&quot;输入要删除的元素的序数：&quot;);
            cin&gt;&gt;v;
            ListDelete(L,v);
            printf(&quot;删除后的线性表为：&quot;);
            Display(L);
        }
        else if(opt==5)
        {
            printf(&quot;退出成功！&quot;);
            break;
        }
    }
    return 0;

}
</code></pre>
<pre><code>1：在线性表中存入5个值
2：查找线性表中的元素
3：向线性表中插入一个元素
4：从线性表中删除一个元素
5：退出
输入你的选择：1
请输入要插入的5个值：9 4 2 1 0
当前线性表为：9 4 2 1 0
输入你的选择：2
请输入要查找的元素：4
要查找的元素的所在的位置为：2
输入你的选择：3
请输入要插入的元素及插入的位置：5 3
插入元素后的线性表为：9 4 5 2 1 0
输入你的选择：4
输入要删除的元素的序数：6
删除后的线性表为：9 4 5 2 1
输入你的选择：5
退出成功！
</code></pre>
<h3 id="线性表的链式存储实现"><a class="header" href="#线性表的链式存储实现">线性表的链式存储实现</a></h3>
<p>不要求逻辑上相邻的两个元素物理上也相邻；通过”链“建立起数据元素之间的逻辑关系。</p>
<p>插入、删除元素不需要移动数据元素，只需要修改”链“。</p>
<p>如果只知道链表头，该怎么访问序号为i的元素？以及怎么求线性表的长度？</p>
<p>建立结构体和结构体指针：</p>
<pre><code class="language-c">typedef struct LNode *List;

struct LNode
{
    ElementType Data;
    List Next;
};
struct LNode L;
List PtrL;
</code></pre>
<p>展示链表结构：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
struct  list_node
{
	int data ;
	struct list_node *next ;
};

typedef struct list_node list_single ;
list_single *create_list_node(int data)
{
	list_single *node = NULL ;
	node = (list_single *)malloc(sizeof(list_single));
	if(node == NULL){
		printf(&quot;malloc fair!\n&quot;);
	}
	memset(node,0,sizeof(list_single));
	node-&gt;data = data;
	node-&gt;next = NULL ;
	return node ;
}
int main(void)
{
	int data = 100 ;
	list_single *node_ptr = create_list_node(data); //创建一个节点
	printf(&quot;node_ptr-&gt;data=%d\n&quot;,node_ptr-&gt;data);   //打印节点里的数据
	printf(&quot;node_ptr-&gt;next=%d\n&quot;,node_ptr-&gt;next);
	free(node_ptr);
	return 0 ;
}
</code></pre>
<pre><code>node_ptr-&gt;data=100
node_ptr-&gt;next=0
</code></pre>
<p>1.求链表的长度</p>
<pre><code class="language-c">int Length(List Ptrl)
{
    List p=Ptrl;     //p指向表的第一个结点
    int j=0;
    while(p)
    {
        p=p-&gt;Next;     
        j++;        //当前p指向的是第j个结点
    }
    return j;
}
</code></pre>
<p>2.查找（1）按序号（不是下标）查找：<code>FindKth</code></p>
<pre><code class="language-c">List FindKth(int K,List PtrL)
{
    List p=PtrL;
    int i=1;
    while(p!=NULL&amp;&amp;i&lt;K)
    {
        p=p-&gt;Next;
        i++;
    }
    if(i==K)
        return p;     //找到第K个，返回指针
    else
        return NULL;  //否则返回空
}
</code></pre>
<p>（2）按值查找</p>
<pre><code class="language-c">List Find(ElementType X,List PtrL)
{
    List p=PtrL;
    while(p!=NULL &amp;&amp; p-&gt;Data!=X)
    {
        p=p-&gt;Next;
    }
    return p;
}
</code></pre>
<p>3.插入（在<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mord cjk_fallback">（</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord cjk_fallback">）</span></span></span></span>个结点后插入一个值为X的新结点</p>
<p>这个结点是第i个结点。</p>
<p>步骤（1）先构造一个新结点，用s指向；（2）再找到链表的第i-1个结点，用p指向；（3）然后修改指针，插入结点（p之后插入的新结点是s）。</p>
<p><strong>链表要先断再接，顺序不能更改！！</strong></p>
<p><strong>链表要先断再接，顺序不能更改！！</strong></p>
<p><strong>链表要先断再接，顺序不能更改！！</strong></p>
<pre><code class="language-c">List Insert(ElementType X,int i,List PtrL) 
{
    List p,s;
    if(i==1)           //新节点插在表头
    {
        s=(List)malloc(sizeof(struct LNode));     //申请、填装结点
        s-&gt;Data=X;
        s-&gt;Next=Ptrl;
        return s;           //返回新表头指针
    }
    p=FindKth(i-1;PtrL);       //查找第i-1个结点
    if(p==NULL)        //第i-1个不存在，不能插入
    {
        printf(&quot;参数i错&quot;);
        return NULL;
    }
    else
    {
        s=(List)malloc(sizeof(struct LNode));      //申请、填装结点
        s.Data=X;
        s-&gt;Next=p-&gt;Next;         //新节点插在第i-1个结点的后面
        p-&gt;Next=s;
        return PtrL;
    }
}
</code></pre>
<p>4.删除（删除链表的<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord cjk_fallback">第</span><span class="mord mathnormal">i</span><span class="mord cjk_fallback">个（</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">n</span><span class="mord cjk_fallback">）</span></span></span></span>个位置上的的结点</p>
<p>步骤：（1）先找到链表的第i-1个结点，用p指向；（2）再用指针s指向要被删除的结点（p的下一个结点）；（3）然后修改指针，删除s所指结点；（4）最后释放s所指结点的空间。</p>
<p>步骤不能更改！！！</p>
<p>步骤不能更改！！！</p>
<p>步骤不能更改！！！</p>
<pre><code class="language-c">List Delete(int i,List PtrL) 
{
    List p,s;
    if(i==1)           //若要删除的是表的第一个结点
    {
        s=PtrL;         //s指向第一个结点
        if(PtrL!=NULL)
            PtrL=PtrL-&gt;Next;   //从链表中删除
        else
            return NULL;
        free(s);             //释放被删除结点
        return PtrL;           //返回新表头指针
    }
    p=FindKth(i-1;PtrL);       //查找第i-1个结点
    if(p==NULL)        
    {
        printf(&quot;第%d个结点不存在&quot;,i-1);
        return NULL;
    }
    else if(p-&gt;Next==NULL)        
    {
        printf(&quot;第%d个结点不存在&quot;,i);
        return NULL;
    }
    else
    {
        s=p-&gt;Next;               //s指向第i个结点
        p-&gt;Next=s-&gt;Next;         //从链表中删除
        free(s);           //释放被删除结点
        return PtrL;
    }
}
</code></pre>
<p>陈越姥姥《数据结构》课程给出的完整代码如下：</p>
<pre><code class="language-c">typedef struct LNode *List;

struct LNode
{
    ElementType Data;
    List Next;
};
struct LNode L;
List PtrL;

int Length(List Ptrl)
{
    List p=Ptrl;     //p指向表的第一个结点
    int j=0;
    while(p)
    {
        p=p-&gt;Next;     
        j++;        //当前p指向的是第j个结点
    }
    return j;
}

List FindKth(int K,List PtrL)
{
    List p=PtrL;
    int i=1;
    while(p!=NULL&amp;&amp;i&lt;K)
    {
        p=p-&gt;Next;
        i++;
    }
    if(i==K)
        return p;     //找到第K个，返回指针
    else
        return NULL;  //否则返回空
}

List Find(ElementType X,List PtrL)
{
    List p=PtrL;
    while(p!=NULL &amp;&amp; p-&gt;Data!=X)
    {
        p=p-&gt;Next;
    }
    return p;
}

List Insert(ElementType X,int i,List PtrL) 
{
    List p,s;
    if(i==1)           //新节点插在表头
    {
        s=(List)malloc(sizeof(struct LNode));     //申请、填装结点
        s-&gt;Data=X;
        s-&gt;Next=Ptrl;
        return s;           //返回新表头指针
    }
    p=FindKth(i-1;PtrL);       //查找第i-1个结点
    if(p==NULL)        //第i-1个不存在，不能插入
    {
        printf(&quot;参数i错&quot;);
        return NULL;
    }
    else
    {
        s=(List)malloc(sizeof(struct LNode));      //申请、填装结点
        s.Data=X;
        s-&gt;Next=p-&gt;Next;         //新节点插在第i-1个结点的后面
        p-&gt;Next=s;
        return PtrL;
    }
}

List Delete(int i,List PtrL) 
{
    List p,s;
    if(i==1)           //若要删除的是表的第一个结点
    {
        s=PtrL;         //s指向第一个结点
        if(PtrL!=NULL)
            PtrL=PtrL-&gt;Next;   //从链表中删除
        else
            return NULL;
        free(s);             //释放被删除结点
        return PtrL;           //返回新表头指针
    }
    p=FindKth(i-1;PtrL);       //查找第i-1个结点
    if(p==NULL)        
    {
        printf(&quot;第%d个结点不存在&quot;,i-1);
        return NULL;
    }
    else if(p-&gt;Next==NULL)        
    {
        printf(&quot;第%d个结点不存在&quot;,i);
        return NULL;
    }
    else
    {
        s=p-&gt;Next;               //s指向第i个结点
        p-&gt;Next=s-&gt;Next;         //从链表中删除
        free(s);           //释放被删除结点
        return PtrL;
    }
}
</code></pre>
<p>《大话数据结构》中链式存储的链表实例：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define ERROR 0
#define OK 1
typedef int Status;
typedef int ElementType;

typedef struct LNode *List;

struct LNode
{
    ElementType Data;
    List Next;
};
struct LNode L;
List PtrL;

//表的创建（头插法）

void CreateListHead(List *L,int m[],int n)
{
    List p;
    int i;
    *L=(List)malloc(sizeof(struct LNode));
    (*L)-&gt;Next=NULL;
    for(i=0;i&lt;n;i++)
    {
        p=(List)malloc(sizeof(struct LNode));
        p-&gt;Data=m[i];
        p-&gt;Next=(*L)-&gt;Next;
        (*L)-&gt;Next=p;
    }
}

//表的创建（尾插法）
void CreateListTail(List *L,int m[],int n)
{
    List p,r;
    int i;
    *L=(List)malloc(sizeof(struct LNode));
    r=*L;
    for(i=0;i&lt;n;i++)
    {
        p=(List)malloc(sizeof(struct LNode));
        p-&gt;Data=m[i];
        r-&gt;Next=p;
        r=p;
    }
    r-&gt;Next=NULL;
}

Status GetElem(List L,int i,ElementType *e)
{
    int j;
    List p;
    p=L-&gt;Next;
    j=1;
    while(p&amp;&amp;j&lt;i)
    {
        p=p-&gt;Next;
        j++;
    }
    if(!p||j&gt;i)
        return ERROR;
    *e=p-&gt;Data;
    return OK;
}
Status ListInsert(List *L,int i,ElementType e)
{
    int j;
    List p,s;
    p=*L;
    j=1;
    while(p&amp;&amp;j&lt;i)
    {
        p=p-&gt;Next;
        j++;
    }
    if(!p||j&gt;i)
        return ERROR;
    s=(List)malloc(sizeof(struct LNode));
    s-&gt;Data=e;
    s-&gt;Next=p-&gt;Next;
    p-&gt;Next=s;
    return OK;
}

Status ListDelete(List *L,int i)
{
    int j;
    List p,q;
    p=*L;
    j=1;
    while(p-&gt;Next&amp;&amp;j&lt;i)
    {
        p=p-&gt;Next;
        j++;
    }
    if(!(p-&gt;Next)||j&gt;i)
        return ERROR;

    q=p-&gt;Next;
    p-&gt;Next=q-&gt;Next;
    free(q);
    return OK;
}
Status Output(List L)
{
    List p;
    p=L-&gt;Next;
    while(p)
    {
        printf(&quot;%d&quot;,p-&gt;Data);
        p=p-&gt;Next;
    }
    printf(&quot;\n&quot;);
}

int main()
{
    List L;
    int i,j,k,n,e,m[100];
    printf(&quot;请输入要存储元素的总个数：&quot;);
    scanf(&quot;%d&quot;,&amp;n);
    printf(&quot;请输入各个元素的值：&quot;);
    for(i=0;i&lt;n;i++)
        scanf(&quot;%d&quot;,&amp;m[i]);

    CreateListHead(&amp;L,m,n);
    printf(&quot;此时链表的元素如下所示：\n&quot;);
    Output(L);
    printf(&quot;请输入要获取的第j个元素并返回到e值中（输入j的值）：&quot;);
    scanf(&quot;%d&quot;,&amp;j);
    GetElem(L,j,&amp;e);
    printf(&quot;此时e的值为第j个元素值：%d\n&quot;,e);
    printf(&quot;请输入在第k个元素前插入一个元素e1：&quot;);
    int e1;
    scanf(&quot;%d%d&quot;,&amp;k,&amp;e1);
    ListInsert(&amp;L,k,e1);
    printf(&quot;此时链表的个元素如下：\n&quot;);
    Output(L);
    printf(&quot;请输入要删除元素的序号：&quot;);
    int l;
    scanf(&quot;%d&quot;,&amp;l);
    ListDelete(&amp;L,l);
    printf(&quot;此时链表的各元素如下：\n&quot;);
    Output(L);
    return 0;

}
</code></pre>
<pre><code>请输入要存储元素的总个数：5
请输入各个元素的值：1 2 3 4 5
此时链表的元素如下所示：
54321
请输入要获取的第j个元素并返回到e值中（输入j的值）：2
此时e的值为第j个元素值：4
请输入在第k个元素前插入一个元素e1：1 2
此时链表的个元素如下：
254321
请输入要删除元素的序号：2
此时链表的各元素如下：
24321
</code></pre>
<h3 id="广义表和多重链表"><a class="header" href="#广义表和多重链表">广义表和多重链表</a></h3>
<p>我们知道了一元多项式的表示，那么二元多项式又该如何表示呢？比如给定二元多项式：<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord">9</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord">15</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">3</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309231015068.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309231016967.png" alt="" /></p>
<p>广义表（Generalized List）</p>
<ul>
<li>广义表是线性表的推广；</li>
<li>对于线性表而言，n个元素都是基本的单元素；</li>
<li>广义表中，这些元素不仅可以是单元素也可以是另一个广义表。</li>
</ul>
<pre><code class="language-c">typedef struct GNode *Glist;
struct GNode
{
    int Tag;    //标志域：0表示结点是单元素，1表示结点是广义表
    union
    {
        ElementType Data;    //子表指针域SubList与单元素数据域Data复用，即共用存储空间
        GList SubList;
    }URegion;
    GList Next;      //指向后继结点
};
</code></pre>
<p>多重链表：链表中的结点可能同时隶属于多个链</p>
<ul>
<li>多重链表中结点的指针域会有多个，如前面例子包含了Next和SubList两个指针域</li>
<li>但包含两个指针域的链表并不一定是多重链表，比如双向链表不是多重链表</li>
</ul>
<p>多重链表有广泛的用途：基本上如树、图这样相对复杂的数据结构都可以采用多重链表的方式存储。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309231035479.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309231037452.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202309231038863.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="栈stack"><a class="header" href="#栈stack">栈Stack</a></h1>
<ul>
<li><a href="%E6%A0%88.html#%E5%AE%9A%E4%B9%89">定义</a></li>
<li><a href="%E6%A0%88.html#%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0">栈的顺序存储实现</a></li>
<li><a href="%E6%A0%88.html#%E5%AE%9E%E4%BE%8Bpta6-7-%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E5%A0%86%E6%A0%88">实例PTA6-7 在一个数组中实现两个堆栈</a></li>
<li><a href="%E6%A0%88.html#%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0">栈的链式存储实现</a></li>
<li><a href="%E6%A0%88.html#%E6%A0%88%E5%BA%94%E7%94%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC">栈应用：表达式求值</a></li>
</ul>
<h2 id="定义"><a class="header" href="#定义">定义</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021433761.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021436202.png" alt="" /></p>
<p>还有一种表达式叫“前缀表达式”，即运算符号位于运算数之前,比如<code>a+b*c</code>的前缀表达式是<code>+a*bc</code>。</p>
<p>你能写出<code>a+b*c-d/e</code>的前缀表达式吗？<code>-+a*bc/de</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021437861.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021443709.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021447134.png" alt="" /></p>
<h2 id="栈的顺序存储实现"><a class="header" href="#栈的顺序存储实现">栈的顺序存储实现</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021455386.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021459833.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021504952.png" alt="" /></p>
<p>根据刚才讲的方法，用一个数组来表示双堆栈，如果这两个堆栈的栈顶位置分别是top1和top2，那么可以用<code>top1+top2==MaxSize(数组大小）</code>来判别堆栈是否满？</p>
<p><font color="red">不可以！！！</font></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021508548.png" alt="" /></p>
<p>《数据结构》课程给出的代码如下：</p>
<pre><code class="language-c">typedef int Position;
struct SNode {
    ElementType *Data; /* 存储元素的数组 */
    Position Top;      /* 栈顶指针 */
    int MaxSize;       /* 堆栈最大容量 */
};
typedef struct SNode *Stack;

Stack CreateStack( int MaxSize )
{
    Stack S = (Stack)malloc(sizeof(struct SNode));
    S-&gt;Data = (ElementType *)malloc(MaxSize * sizeof(ElementType));
    S-&gt;Top = -1;
    S-&gt;MaxSize = MaxSize;
    return S;
}

bool IsFull( Stack S )
{
    return (S-&gt;Top == S-&gt;MaxSize-1);
}

bool Push( Stack S, ElementType X )
{
    if ( IsFull(S) ) {
        printf(&quot;堆栈满&quot;);
        return false;
    }
    else {
        S-&gt;Data[++(S-&gt;Top)] = X;
        return true;
    }
}

bool IsEmpty( Stack S )
{
    return (S-&gt;Top == -1);
}

ElementType Pop( Stack S )
{
    if ( IsEmpty(S) ) {
        printf(&quot;堆栈空&quot;);
        return ERROR; /* ERROR是ElementType的特殊值，标志错误 */
    }
    else 
        return ( S-&gt;Data[(S-&gt;Top)--] );
}
</code></pre>
<p>测试程序如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

#define ElementType int
#define ERROR -1
#define OK 0

typedef int Position;
typedef struct SNode *Stack;

struct SNode
{
    ElementType *Data;
    Position Top;
    int MaxSize;
};

Stack CreateStack(int MaxSize)
{
    Stack S = (Stack)malloc(sizeof(struct SNode));
    S-&gt;Data = (ElementType*)malloc(MaxSize * sizeof(ElementType));
    S-&gt;Top = -1;
    S-&gt;MaxSize = MaxSize;
    return S;
}
bool IsFull(Stack S)
{
    return (S-&gt;Top == S-&gt;MaxSize-1);
}
bool Push(Stack PtrS,ElementType X)
{
    if(IsFull(PtrS))
        return false;
    else
    {
        PtrS-&gt;Data[++(PtrS-&gt;Top)] = X;
        return true;
    }
}

bool IsEmpty(Stack S)
{
    return (S-&gt;Top == -1);
}

ElementType Pop(Stack PtrS)
{

    if(IsEmpty(PtrS))
    {
        printf(&quot;栈已空！&quot;);
        return ERROR;
    }
    else
    {
        return (PtrS-&gt;Data[(PtrS-&gt;Top)--]);
    }
}

int main()
{
    Stack S = CreateStack(10);
    int choice;
    while(1)
    {
        printf(&quot;（1）进栈 （2）出栈 （3）读栈顶 （4）退出\n&quot;);
        scanf(&quot;%d&quot;,&amp;choice);
        if(choice == 1)
        {
            ElementType X;
            printf(&quot;输入进栈元素：&quot;);
            scanf(&quot;%d&quot;,&amp;X);
            if(Push(S,X))
                printf(&quot;\n元素进栈成功！\n&quot;);
        }
        else if(choice == 2)
        {
            ElementType X;
            X = Pop(S);
            if(X != ERROR)
                printf(&quot;出栈元素为%d\n&quot;,X);
        }
        else
            return 0;
    }
}
</code></pre>
<pre><code>（1）进栈 （2）出栈 （3）读栈顶 （4）退出
1
输入进栈元素：2

元素进栈成功！
（1）进栈 （2）出栈 （3）读栈顶 （4）退出
1
输入进栈元素：4

元素进栈成功！
（1）进栈 （2）出栈 （3）读栈顶 （4）退出
1
输入进栈元素：1

元素进栈成功！
（1）进栈 （2）出栈 （3）读栈顶 （4）退出
2
出栈元素为1
（1）进栈 （2）出栈 （3）读栈顶 （4）退出
2
出栈元素为4
（1）进栈 （2）出栈 （3）读栈顶 （4）退出
2
出栈元素为2
（1）进栈 （2）出栈 （3）读栈顶 （4）退出
2
栈已空！（1）进栈 （2）出栈 （3）读栈顶 （4）退出
4

Process returned 0 (0x0)   execution time : 18.576 s
Press any key to continue.
</code></pre>
<h2 id="实例pta6-7-在一个数组中实现两个堆栈"><a class="header" href="#实例pta6-7-在一个数组中实现两个堆栈">实例PTA6-7 在一个数组中实现两个堆栈</a></h2>
<p>本题要求在一个数组中实现两个堆栈。</p>
<p>函数接口定义：</p>
<pre><code class="language-c">Stack CreateStack( int MaxSize );
bool Push( Stack S, ElementType X, int Tag );
ElementType Pop( Stack S, int Tag );
</code></pre>
<p>其中<code>Tag</code>是堆栈编号，取1或2；<code>MaxSize</code>堆栈数组的规模；<code>Stack</code>结构定义如下：</p>
<pre><code class="language-c">typedef int Position;
struct SNode {
    ElementType *Data;
    Position Top1, Top2;
    int MaxSize;
};
typedef struct SNode *Stack;
</code></pre>
<p>注意：如果堆栈已满，<code>Push</code>函数必须输出“Stack Full”并且返回false；如果某堆栈是空的，则<code>Pop</code>函数必须输出“Stack Tag Empty”（其中Tag是该堆栈的编号），并且返回ERROR。</p>
<p>裁判测试程序样例：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define ERROR 1e8
typedef int ElementType;
typedef enum { push, pop, end } Operation;
typedef enum { false, true } bool;
typedef int Position;
struct SNode {
    ElementType *Data;
    Position Top1, Top2;
    int MaxSize;
};
typedef struct SNode *Stack;

Stack CreateStack( int MaxSize );
bool Push( Stack S, ElementType X, int Tag );
ElementType Pop( Stack S, int Tag );

Operation GetOp();  /* details omitted */
void PrintStack( Stack S, int Tag ); /* details omitted */

int main()
{
    int N, Tag, X;
    Stack S;
    int done = 0;

    scanf(&quot;%d&quot;, &amp;N);
    S = CreateStack(N);
    while ( !done ) {
        switch( GetOp() ) {
        case push: 
            scanf(&quot;%d %d&quot;, &amp;Tag, &amp;X);
            if (!Push(S, X, Tag)) printf(&quot;Stack %d is Full!\n&quot;, Tag);
            break;
        case pop:
            scanf(&quot;%d&quot;, &amp;Tag);
            X = Pop(S, Tag);
            if ( X==ERROR ) printf(&quot;Stack %d is Empty!\n&quot;, Tag);
            break;
        case end:
            PrintStack(S, 1);
            PrintStack(S, 2);
            done = 1;
            break;
        }
    }
    return 0;
}

/* 你的代码将被嵌在这里 */
</code></pre>
<p>输入样例：</p>
<pre><code class="language-in">5
Push 1 1
Pop 2
Push 2 11
Push 1 2
Push 2 12
Pop 1
Push 2 13
Push 2 14
Push 1 3
Pop 2
End
</code></pre>
<p>输出样例：</p>
<pre><code class="language-out">Stack 2 Empty
Stack 2 is Empty!
Stack Full
Stack 1 is Full!
Pop from Stack 1: 1
Pop from Stack 2: 13 12 11
</code></pre>
<p>能AC的代码如下：</p>
<pre><code class="language-c">Stack CreateStack( int MaxSize )
{
    Stack S = (Stack)malloc(sizeof(struct SNode));
    S-&gt;Data = (ElementType*)malloc(sizeof(ElementType)*MaxSize);
    S-&gt;Top1 = -1;
    S-&gt;Top2 = MaxSize;
    S-&gt;MaxSize = MaxSize;
    return S;
    
}
bool Push( Stack S, ElementType X, int Tag )
{
    if(S-&gt;Top1 + 1 == S-&gt;Top2)
    {
        printf(&quot;Stack Full\n&quot;);
        return false;
    }
    if(Tag == 1)
    {
        S-&gt;Data[++(S-&gt;Top1)] = X;
        return true;
    }
    else
    {
        S-&gt;Data[--(S-&gt;Top2)] = X;
        return true;
    }
    
}
ElementType Pop( Stack S, int Tag )
{
    if(Tag == 1)
    {
        if(S-&gt;Top1 == -1)
        {
            printf(&quot;Stack %d Empty\n&quot;,Tag);
            return ERROR;
        }
        else
            return (S-&gt;Data[(S-&gt;Top1)--]);
    }
    else
    {
        if(S-&gt;Top2 == S-&gt;MaxSize)
        {
            printf(&quot;Stack %d Empty\n&quot;,Tag);
            return ERROR;
        }
        else
            return (S-&gt;Data[(S-&gt;Top2)++]);
    }
}
</code></pre>
<h2 id="栈的链式存储实现"><a class="header" href="#栈的链式存储实现">栈的链式存储实现</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021510144.png" alt="" /></p>
<p>若用单向链表实现一个堆栈，只有<strong>链表的头可以作为top</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021547969.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021513985.png" alt="" /></p>
<p>《数据结构》课程给出的代码如下：</p>
<pre><code class="language-c">typedef struct SNode *PtrToSNode;
struct SNode {
    ElementType Data;
    PtrToSNode Next;
};
typedef PtrToSNode Stack;

Stack CreateStack( ) 
{ /* 构建一个堆栈的头结点，返回该结点指针 */
    Stack S;

    S = (Stack)malloc(sizeof(struct SNode));
    S-&gt;Next = NULL;
    return S;
}

bool IsEmpty ( Stack S )
{ /* 判断堆栈S是否为空，若是返回true；否则返回false */
    return ( S-&gt;Next == NULL );
}

bool Push( Stack S, ElementType X )
{ /* 将元素X压入堆栈S */
    PtrToSNode TmpCell;

    TmpCell = (PtrToSNode)malloc(sizeof(struct SNode));
    TmpCell-&gt;Data = X;
    TmpCell-&gt;Next = S-&gt;Next;
    S-&gt;Next = TmpCell;
    return true;
}

ElementType Pop( Stack S )  
{ /* 删除并返回堆栈S的栈顶元素 */
    PtrToSNode FirstCell;
    ElementType TopElem;

    if( IsEmpty(S) ) {
        printf(&quot;堆栈空&quot;); 
        return ERROR;
    }
    else {
        FirstCell = S-&gt;Next; 
        TopElem = FirstCell-&gt;Data;
        S-&gt;Next = FirstCell-&gt;Next;
        free(FirstCell);
        return TopElem;
    }
}
</code></pre>
<p>测试程序如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

#define ElementType int
#define ERROR -1
#define OK 0

typedef int Position;
typedef struct SNode *Stack;

struct SNode
{
    ElementType Data;
    Stack Next;
};

Stack CreateStack()
{
    Stack S = (Stack)malloc(sizeof(struct SNode));
    S-&gt;Next = NULL;
    return S;
}

bool Push(Stack PtrS,ElementType X)
{
    Stack TempCell = (Stack)malloc(sizeof(struct SNode));
    TempCell-&gt;Data = X;
    TempCell-&gt;Next = PtrS-&gt;Next;
    PtrS-&gt;Next = TempCell;
    return true;
}

bool IsEmpty(Stack S)
{
    return (S-&gt;Next == NULL);
}

ElementType Pop(Stack PtrS)
{
    Stack FirstCell;
    ElementType TopElem;

    if(IsEmpty(PtrS))
    {
        printf(&quot;栈已空！&quot;);
        return ERROR;
    }
    else
    {
        FirstCell = PtrS-&gt;Next;
        TopElem = FirstCell-&gt;Data;
        PtrS-&gt;Next = FirstCell-&gt;Next;
        free(FirstCell);
        return TopElem;
    }
}

int main()
{
    Stack S = CreateStack();
    int choice;
    while(1)
    {
        printf(&quot;（1）进栈 （2）出栈 （3）读栈顶 （4）退出\n&quot;);
        scanf(&quot;%d&quot;,&amp;choice);
        if(choice == 1)
        {
            ElementType X;
            printf(&quot;输入进栈元素：&quot;);
            scanf(&quot;%d&quot;,&amp;X);
            if(Push(S,X))
                printf(&quot;\n元素进栈成功！\n&quot;);
        }
        else if(choice == 2)
        {
            ElementType X;
            X = Pop(S);
            if(X != ERROR)
                printf(&quot;出栈元素为%d\n&quot;,X);
        }
        else
            return 0;
    }
}
</code></pre>
<pre><code>（1）进栈 （2）出栈 （3）读栈顶 （4）退出
1
输入进栈元素：2

元素进栈成功！
（1）进栈 （2）出栈 （3）读栈顶 （4）退出
1
输入进栈元素：3

元素进栈成功！
（1）进栈 （2）出栈 （3）读栈顶 （4）退出
1
输入进栈元素：1

元素进栈成功！
（1）进栈 （2）出栈 （3）读栈顶 （4）退出
2
出栈元素为1
（1）进栈 （2）出栈 （3）读栈顶 （4）退出
2
出栈元素为3
（1）进栈 （2）出栈 （3）读栈顶 （4）退出
2
出栈元素为2
（1）进栈 （2）出栈 （3）读栈顶 （4）退出
2
栈已空！（1）进栈 （2）出栈 （3）读栈顶 （4）退出
4

Process returned 0 (0x0)   execution time : 28.401 s
Press any key to continue.
</code></pre>
<h2 id="栈应用表达式求值"><a class="header" href="#栈应用表达式求值">栈应用：表达式求值</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021513692.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021514596.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021514830.png" alt="" /></p>
<p>左括号一旦放到堆栈中优先级就变为最低。碰到右括号（右括号不入栈）就把栈顶元素抛出，直到抛出左括号为止。<strong>注：括号是不会出现在后缀表达式或前缀表达式中的</strong></p>
<p>请试试应用堆栈将中缀表达式2*(6/3+4)-5转换为后缀表达式。在这个转换过程中，堆栈元素最多时元素个数是3。</p>
<p>借助堆栈将中缀表达式<code>A-(B-C/D)*E</code>转换为后缀表达式，则该堆栈的大小至少为：4</p>
<p>如果一堆栈的输入序列是aAbBc，输出为 abcBA，那么该堆栈所进行的操作序列是什么？ 设P代表入栈，O代表出栈。  POPPOPPOOO</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021514497.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021515284.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021515815.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311021515575.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="队列queue"><a class="header" href="#队列queue">队列Queue</a></h1>
<ul>
<li><a href="%E9%98%9F%E5%88%97.html#%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0">队列的顺序存储实现</a></li>
<li><a href="%E9%98%9F%E5%88%97.html#%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0">队列的链式存储实现</a></li>
<li><a href="%E9%98%9F%E5%88%97.html#%E5%A6%82%E4%BD%95%E7%94%A8%E4%B8%A4%E4%B8%AA%E5%A0%86%E6%A0%88%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97">如何用两个堆栈模拟实现一个队列?</a></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311051520569.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311051522166.png" alt="" /></p>
<h2 id="队列的顺序存储实现"><a class="header" href="#队列的顺序存储实现">队列的顺序存储实现</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311051600042.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311051600901.png" alt="" /></p>
<p>这里对rear和front位置无要求。</p>
<p>如果空队列开始时front和rear值都是-1，当插入4个元素并删除2个元素后，front和rear值分别是多少？1和3</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311051601299.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311071815252.png" alt="" /></p>
<p>现采用大小为10的数组实现一个循环队列。设在某一时刻，队列为空且此时front和rear值均为5。经过若干操作后，front为8，rear为2，问：此时队列中有4个元素。</p>
<p>通用的队列长度计算公式：队列长度=（rear - front + MaxSize) % MaxSize</p>
<p>解释：front、rear方向一致，front指向实际存在的结点的前一个结点，rear指向实际存在的最后一个结点，此时队列中有9、0、1、2四个位置上的元素。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311051602307.png" alt="" /></p>
<p>《数据结构》课程给出的队列顺序存储实现方式如下：</p>
<pre><code class="language-c">typedef int Position;
struct QNode {
    ElementType *Data;     /* 存储元素的数组 */
    Position Front, Rear;  /* 队列的头、尾指针 */
    int MaxSize;           /* 队列最大容量 */
};
typedef struct QNode *Queue;

Queue CreateQueue( int MaxSize )
{
    Queue Q = (Queue)malloc(sizeof(struct QNode));
    Q-&gt;Data = (ElementType *)malloc(MaxSize * sizeof(ElementType));
    Q-&gt;Front = Q-&gt;Rear = 0;
    Q-&gt;MaxSize = MaxSize;
    return Q;
}

bool IsFull( Queue Q )
{
    return ((Q-&gt;Rear+1)%Q-&gt;MaxSize == Q-&gt;Front);
}

bool AddQ( Queue Q, ElementType X )
{
    if ( IsFull(Q) ) {
        printf(&quot;队列满&quot;);
        return false;
    }
    else {
        Q-&gt;Rear = (Q-&gt;Rear+1)%Q-&gt;MaxSize;
        Q-&gt;Data[Q-&gt;Rear] = X;
        return true;
    }
}

bool IsEmpty( Queue Q )
{
    return (Q-&gt;Front == Q-&gt;Rear);
}

ElementType DeleteQ( Queue Q )
{
    if ( IsEmpty(Q) ) { 
        printf(&quot;队列空&quot;);
        return ERROR;
    }
    else  {
        Q-&gt;Front =(Q-&gt;Front+1)%Q-&gt;MaxSize;
        return  Q-&gt;Data[Q-&gt;Front];
    }
}
</code></pre>
<p>测试程序如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

#define ERROR 0

typedef int ElementType;

typedef struct QNode *Queue;

struct QNode
{
    ElementType *Data;
    int MaxSize;
    int front;
    int rear;
};

Queue CreateQueue(int MaxSize)
{
    Queue q = (Queue)malloc(sizeof(struct QNode));
    q-&gt;Data = (ElementType*)malloc(sizeof(ElementType)*MaxSize);
    q-&gt;front = 0;
    q-&gt;rear = 0;
    q-&gt;MaxSize = MaxSize;
    return q;
}

bool IsFullQ(Queue q)
{
    return (((q-&gt;rear+1)%q-&gt;MaxSize) == q-&gt;front);
}


bool AddQ(Queue q,ElementType item)
{
    if(IsFullQ(q))
    {
        printf(&quot;队列已满\n&quot;);
        return false;
    }
    else
    {
        q-&gt;rear = (q-&gt;rear+1)%(q-&gt;MaxSize);
        q-&gt;Data[q-&gt;rear] = item;
        return true;
    }
}

bool IsEmptyQ(Queue q)
{
    return (q-&gt;rear == q-&gt;front);
}

ElementType DeleteQ(Queue q)
{
    if(IsEmptyQ(q))
    {
        printf(&quot;队列为空\n&quot;);
        return ERROR;
    }
    else
    {
        q-&gt;front = (q-&gt;front+1)%(q-&gt;MaxSize);
        return (q-&gt;Data[q-&gt;front]);
    }
}

int main()
{
    Queue q = CreateQueue(10);
    int choice;

    while(1)
    {
        printf(&quot;输入1添加1个元素，输入2删除1个元素，输入0结束循环\n&quot;);
        scanf(&quot;%d&quot;,&amp;choice);
        if(choice == 1)
        {
            ElementType X;
            scanf(&quot;%d&quot;,&amp;X);
            AddQ(q,X);
        }
        else if(choice == 2)
        {
            ElementType X = DeleteQ(q);
            printf(&quot;%d\n&quot;,X);
        }
        else
            return 0;
    }

}
</code></pre>
<pre><code>输入1添加1个元素，输入2删除1个元素，输入0结束循环
1
2
输入1添加1个元素，输入2删除1个元素，输入0结束循环
1
3
输入1添加1个元素，输入2删除1个元素，输入0结束循环
1
1
输入1添加1个元素，输入2删除1个元素，输入0结束循环
1
4
输入1添加1个元素，输入2删除1个元素，输入0结束循环
1
5
输入1添加1个元素，输入2删除1个元素，输入0结束循环
1
6
输入1添加1个元素，输入2删除1个元素，输入0结束循环
2
2
输入1添加1个元素，输入2删除1个元素，输入0结束循环
2
3
输入1添加1个元素，输入2删除1个元素，输入0结束循环
2
1
输入1添加1个元素，输入2删除1个元素，输入0结束循环
2
4
输入1添加1个元素，输入2删除1个元素，输入0结束循环
2
5
输入1添加1个元素，输入2删除1个元素，输入0结束循环
2
6
输入1添加1个元素，输入2删除1个元素，输入0结束循环
2
队列为空
0
输入1添加1个元素，输入2删除1个元素，输入0结束循环
0

Process returned 0 (0x0)   execution time : 56.625 s
Press any key to continue.
</code></pre>
<h2 id="队列的链式存储实现"><a class="header" href="#队列的链式存储实现">队列的链式存储实现</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311051608152.png" alt="" /></p>
<p>队列的front只能设在链表头部。如果front放在链表尾部，删除当前结点后无法找到上一个结点。</p>
<p>在一个链表表示的队列中， f和r分别指向队列的头和尾。<code>r-&gt;next=s; r=s;</code>能正确地将s结点插入到队列中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311051608220.png" alt="" /></p>
<p>《数据结构》课程给出的队列链式存储实现方式如下：</p>
<pre><code class="language-c">typedef struct Node *PtrToNode;
struct Node { /* 队列中的结点 */
    ElementType Data;
    PtrToNode Next;
};
typedef PtrToNode Position;

struct QNode {
    Position Front, Rear;  /* 队列的头、尾指针 */
    int MaxSize;           /* 队列最大容量 */
};
typedef struct QNode *Queue;

bool IsEmpty( Queue Q )
{
    return ( Q-&gt;Front == NULL);
}

ElementType DeleteQ( Queue Q )
{
    Position FrontCell; 
    ElementType FrontElem;
    
    if  ( IsEmpty(Q) ) {
        printf(&quot;队列空&quot;);
        return ERROR;
    }
    else {
        FrontCell = Q-&gt;Front;
        if ( Q-&gt;Front == Q-&gt;Rear ) /* 若队列只有一个元素 */
            Q-&gt;Front = Q-&gt;Rear = NULL; /* 删除后队列置为空 */
        else                     
            Q-&gt;Front = Q-&gt;Front-&gt;Next;
        FrontElem = FrontCell-&gt;Data;

        free( FrontCell );  /* 释放被删除结点空间  */
        return  FrontElem;
    }
}
</code></pre>
<p>测试程序如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;assert.h&gt;
#define ERROR 0

typedef int ElementType;

typedef struct Node *PtrToNode;

struct Node
{
    ElementType Data;
    PtrToNode Next;
};

PtrToNode CreateNode(ElementType Data)
{
    PtrToNode newNode = (PtrToNode)malloc(sizeof(struct Node));
    assert(newNode);
    newNode-&gt;Data = Data;
    newNode-&gt;Next = NULL;
    return newNode;
}

typedef PtrToNode Position;

typedef struct QNode *Queue;

struct QNode
{
    PtrToNode Front,Rear;
    int curSize;
};

Queue CreateQueue()
{
    Queue q = (Queue)malloc(sizeof(struct QNode));
    assert(q);
    q-&gt;curSize = 0;
    q-&gt;Front = q-&gt;Rear = NULL;
    return q;
}

void AddQ(Queue q,ElementType item)
{
    //PtrToNode s = (PtrToNode)malloc(sizeof(struct Node));
    //s-&gt;Data = item;
    //s-&gt;Next = NULL;
    PtrToNode s = CreateNode(item);
    if(q-&gt;curSize == 0)
        q-&gt;Front = s;
    else
        q-&gt;Rear-&gt;Next = s;
    q-&gt;Rear = s;
    q-&gt;curSize++;
}
bool IsEmptyQ(Queue q)
{
    return (q-&gt;Front == NULL);
}

ElementType DeleteQ(Queue q)
{
    PtrToNode FrontCell;
    ElementType FrontElem;
    if(IsEmptyQ(q))
    {
        printf(&quot;队列空!\n&quot;);
        return ERROR;
    }
    else
    {
        FrontCell = q-&gt;Front;
        if(q-&gt;Front == q-&gt;Rear)
            q-&gt;Front = q-&gt;Rear = NULL;
        else
            q-&gt;Front = q-&gt;Front-&gt;Next;
        FrontElem = FrontCell-&gt;Data;
        free(FrontCell);
        q-&gt;curSize--;
        return FrontElem;
    }

}

int main()
{
    Queue q = CreateQueue();
    int choice;

    while(1)
    {
        printf(&quot;输入1添加1个元素，输入2删除1个元素，输入0结束循环\n&quot;);
        scanf(&quot;%d&quot;,&amp;choice);
        if(choice == 1)
        {
            ElementType X;
            scanf(&quot;%d&quot;,&amp;X);
            AddQ(q,X);
        }
        else if(choice == 2)
        {
            ElementType X = DeleteQ(q);
            printf(&quot;%d\n&quot;,X);
        }
        else
            return 0;
    }

}
</code></pre>
<pre><code>输入1添加1个元素，输入2删除1个元素，输入0结束循环
1
2
输入1添加1个元素，输入2删除1个元素，输入0结束循环
1
3
输入1添加1个元素，输入2删除1个元素，输入0结束循环
1
4
输入1添加1个元素，输入2删除1个元素，输入0结束循环
1
5
输入1添加1个元素，输入2删除1个元素，输入0结束循环
2
2
输入1添加1个元素，输入2删除1个元素，输入0结束循环
2
3
输入1添加1个元素，输入2删除1个元素，输入0结束循环
2
4
输入1添加1个元素，输入2删除1个元素，输入0结束循环
2
5
输入1添加1个元素，输入2删除1个元素，输入0结束循环
2
队列空!
0
输入1添加1个元素，输入2删除1个元素，输入0结束循环
0

Process returned 0 (0x0)   execution time : 22.052 s
Press any key to continue.
</code></pre>
<h2 id="如何用两个堆栈模拟实现一个队列"><a class="header" href="#如何用两个堆栈模拟实现一个队列">如何用两个堆栈模拟实现一个队列?</a></h2>
<p>如何用两个堆栈模拟实现一个队列?  如果这两个堆栈的容量分别是m和n（m&gt;n)，你的方法能保证的队列容量是多少？</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="mooc-pta线性结构题目"><a class="header" href="#mooc-pta线性结构题目">MOOC-PTA线性结构题目</a></h1>
<ul>
<li><a href="MOOC-PTA%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E9%A2%98%E7%9B%AE.html#pta-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%841-%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%BA%8F%E5%88%97%E7%9A%84%E5%90%88%E5%B9%B6">PTA 02-线性结构1 两个有序链表序列的合并</a></li>
<li><a href="MOOC-PTA%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E9%A2%98%E7%9B%AE.html#pta02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%842-%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E4%B9%98%E6%B3%95%E4%B8%8E%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97">PTA02-线性结构2 一元多项式的乘法与加法运算</a></li>
<li><a href="MOOC-PTA%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E9%A2%98%E7%9B%AE.html#pta-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%843-reversing-linked-list">PTA 02-线性结构3 Reversing Linked List</a></li>
<li><a href="MOOC-PTA%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E9%A2%98%E7%9B%AE.html#pta-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%844-pop-sequence">PTA 02-线性结构4 Pop Sequence</a></li>
</ul>
<h2 id="pta-02-线性结构1-两个有序链表序列的合并"><a class="header" href="#pta-02-线性结构1-两个有序链表序列的合并">PTA 02-线性结构1 两个有序链表序列的合并</a></h2>
<p>本题要求实现一个函数，将两个链表表示的递增整数序列合并为一个非递减的整数序列。</p>
<p>函数接口定义：</p>
<pre><code class="language-c">List Merge( List L1, List L2 );
</code></pre>
<p>其中<code>List</code>结构定义如下：</p>
<pre><code class="language-c">typedef struct Node *PtrToNode;
struct Node {
    ElementType Data; /* 存储结点数据 */
    PtrToNode   Next; /* 指向下一个结点的指针 */
};
typedef PtrToNode List; /* 定义单链表类型 */
</code></pre>
<p><code>L1</code>和<code>L2</code>是给定的带头结点的单链表，其结点存储的数据是递增有序的；函数<code>Merge</code>要将<code>L1</code>和<code>L2</code>合并为一个非递减的整数序列。应直接使用原序列中的结点，返回归并后的带头结点的链表头指针。</p>
<p>裁判测试程序样例：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef int ElementType;
typedef struct Node *PtrToNode;
struct Node {
    ElementType Data;
    PtrToNode   Next;
};
typedef PtrToNode List;

List Read(); /* 细节在此不表 */
void Print( List L ); /* 细节在此不表；空链表将输出NULL */

List Merge( List L1, List L2 );

int main()
{
    List L1, L2, L;
    L1 = Read();
    L2 = Read();
    L = Merge(L1, L2);
    Print(L);
    Print(L1);
    Print(L2);
    return 0;
}

/* 你的代码将被嵌在这里 */
</code></pre>
<p>输入样例：</p>
<pre><code>3
1 3 5
5
2 4 6 8 10
</code></pre>
<p>输出样例：</p>
<pre><code>1 2 3 4 5 6 8 10 
NULL
NULL
</code></pre>
<p>能AC的代码如下：</p>
<pre><code class="language-c">List Merge( List L1, List L2 )
{
    if(L1 == NULL || L2 == NULL)
        return (L1 == NULL)?L2:L1;
    List head = (List)malloc(sizeof(struct Node));
    List cur1 = L1-&gt;Next;
    List cur2 = L2-&gt;Next;
    List pre = head;
    while(cur1 != NULL &amp;&amp; cur2 != NULL)
    {
        if(cur1-&gt;Data &lt;= cur2-&gt;Data)
        {
            pre-&gt;Next = cur1;
            cur1 = cur1-&gt;Next;
        }
        else
        {
            pre-&gt;Next = cur2;
            cur2 = cur2-&gt;Next;
        }
        pre = pre-&gt;Next;
    }
    pre-&gt;Next = (cur1 != NULL)?cur1:cur2;
    L1-&gt;Next = NULL;
    L2-&gt;Next = NULL;
    return head;

}
</code></pre>
<h2 id="pta02-线性结构2-一元多项式的乘法与加法运算"><a class="header" href="#pta02-线性结构2-一元多项式的乘法与加法运算">PTA02-线性结构2 一元多项式的乘法与加法运算</a></h2>
<p>设计函数分别求两个一元多项式的乘积与和。</p>
<p>输入格式:</p>
<p>输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。</p>
<p>输出格式:</p>
<p>输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出<code>0 0</code>。</p>
<p>输入样例:</p>
<pre><code>4 3 4 -5 2  6 1  -2 0
3 5 20  -7 4  3 1
</code></pre>
<p>输出样例:</p>
<pre><code>15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 1
5 20 -4 4 -5 2 9 1 -2 0
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311042023348.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311042023470.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311042023690.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311042024293.png" alt="" /></p>
<p>如果当前p1指向项的（系数，指数）为（2，4），同时P2指向项为(2，6)，那么循环中的switch是执行case -1。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311042024746.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311091547345.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct PolyNode *Polynomial;
struct PolyNode
{
    int coef;
    int expon;
    Polynomial link;
};

Polynomial ReadPoly()
{
    Polynomial P,Rear,temp;
    int n,e,c;
    scanf(&quot;%d&quot;,&amp;n);
    P = (Polynomial)malloc(sizeof(struct PolyNode));
    P-&gt;link = NULL;
    Rear = P;
    while(n--)
    {
        scanf(&quot;%d %d&quot;,&amp;c,&amp;e);
        Attach(c,e,&amp;Rear);
    }
    temp = P;
    P = P-&gt;link;
    free(temp);
    return P;
}

void Attach(int c,int e,Polynomial *pRear)
{
    Polynomial P = (Polynomial)malloc(sizeof(struct PolyNode));
    P-&gt;coef = c;
    P-&gt;expon = e;
    P-&gt;link = NULL;
    (*pRear)-&gt;link = P;
    *pRear = P;
}

int Compare(int a,int b)
{
    if(a&gt;b)
        return 1;
    else if(a&lt;b)
        return -1;
    else
        return 0;
}
/*
Polynomial AddPoly(Polynomial P1,Polynomial P2)
{
    Polynomial front,rear,temp;
    int sum = 0;
    rear = (Polynomial)malloc(sizeof(struct PolyNode));
    front = rear;
    while(P1&amp;&amp;P2)
    {
        switch(Compare(P1-&gt;expon,P2-&gt;expon))
        {
        case 1:
            Attach(P1-&gt;coef,P1-&gt;expon,&amp;rear);
            P1 = P1-&gt;link;
            break;
        case -1:
            Attach(P2-&gt;coef,P2-&gt;expon,&amp;rear);
            P2 = P2-&gt;link;
            break;
        case 0:
            sum = P1-&gt;coef + P2-&gt;coef;
            if(sum)
                Attach(sum,P1-&gt;expon,&amp;rear);
            P1 = P1-&gt;link;
            P2 = P2-&gt;link;
            break;
        }
        for(;P1;P1 = P1-&gt;link)
            Attach(P1-&gt;coef,P1-&gt;expon,&amp;rear);
        for(;P2;P2 = P2-&gt;link)
            Attach(P2-&gt;coef,P2-&gt;expon,&amp;rear);
        rear-&gt;link = NULL;
        temp = front;
        front = front-&gt;link;
        free(temp);
        return front;

    }
}

*/


Polynomial AddPoly(Polynomial P1,Polynomial P2)
{
    Polynomial t1,t2,P,Rear,temp;
    int sum;
    t1 = P1;
    t2 = P2;
    P = (Polynomial)malloc(sizeof(struct PolyNode));
    P-&gt;link = NULL;
    Rear = P;
    while(t1&amp;&amp;t2)
    {
        if(t1-&gt;expon == t2-&gt;expon)
        {
            sum = t1-&gt;coef + t2-&gt;coef;
            if(sum)
                Attach(sum,t1-&gt;expon,&amp;Rear);
            t1 = t1-&gt;link;
            t2 = t2-&gt;link;
        }
        else if(t1-&gt;expon &gt; t2-&gt;expon)
        {
            Attach(t1-&gt;coef,t1-&gt;expon,&amp;Rear);
            t1 = t1-&gt;link;
        }
        else
        {
            Attach(t2-&gt;coef,t2-&gt;expon,&amp;Rear);
            t2 = t2-&gt;link;
        }
    }
    while(t1)
    {
        Attach(t1-&gt;coef,t1-&gt;expon,&amp;Rear);
        t1 = t1-&gt;link;
    }
    while(t2)
    {
        Attach(t2-&gt;coef,t2-&gt;expon,&amp;Rear);
        t2 = t2-&gt;link;
    }
    Rear-&gt;link = NULL;
    temp = P;
    P = P-&gt;link;
    free(temp);
    return P;
}

Polynomial MultPoly(Polynomial P1,Polynomial P2)
{
    Polynomial t1,t2,temp,P,Rear;
    int c,e;
    if(!P1 || !P2)
        return NULL;
    t1 = P1;
    t2 = P2;
    P = (Polynomial)malloc(sizeof(struct PolyNode));
    P-&gt;link = NULL;
    Rear = P;
    while(t2)
    {
        Attach(t1-&gt;coef * t2-&gt;coef,t1-&gt;expon + t2-&gt;expon,&amp;Rear);
        t2 = t2-&gt;link;
    }
    t1 = t1-&gt;link;
    while(t1)
    {
        t2 = P2;
        Rear = P;
        while(t2)
        {
            e = t1-&gt;expon + t2-&gt;expon;
            c = t1-&gt;coef * t2-&gt;coef;
            while(Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon &gt; e)
                Rear = Rear-&gt;link;
            if(Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon == e)
            {
                if(Rear-&gt;link-&gt;coef + c)
                    Rear-&gt;link-&gt;coef += c;
                else
                {
                    temp = Rear-&gt;link;
                    Rear-&gt;link = temp-&gt;link;
                    free(temp);
                }
            }
            else
            {
                temp = (Polynomial)malloc(sizeof(struct PolyNode));
                temp-&gt;coef = c;
                temp-&gt;expon = e;
                temp-&gt;link = Rear-&gt;link;
                Rear-&gt;link = temp;
                Rear = Rear-&gt;link;
            }
            t2 = t2-&gt;link;
        }
        t1 = t1-&gt;link;
    }
    t2 = P;
    P = P-&gt;link;
    free(t2);
    return P;

}

void PrintPoly(Polynomial P)
{
    int flag = 0;
    if(!P)
    {
        printf(&quot;0 0\n&quot;);
        return;
    }
    while(P)
    {
        if(!flag)
            flag = 1;
        else
            printf(&quot; &quot;);
        printf(&quot;%d %d&quot;,P-&gt;coef,P-&gt;expon);
        P = P-&gt;link;
    }
    printf(&quot;\n&quot;);
}

int main()
{
    Polynomial P1,P2,PP,PS;
    P1 = ReadPoly();
    P2 = ReadPoly();
    PP = MultPoly(P1,P2);
    PrintPoly(PP);
    PS = AddPoly(P1,P2);
    PrintPoly(PS);
    return 0;

}
</code></pre>
<h2 id="pta-02-线性结构3-reversing-linked-list"><a class="header" href="#pta-02-线性结构3-reversing-linked-list">PTA 02-线性结构3 Reversing Linked List</a></h2>
<p>Given a constant K and a singly linked list L, you are supposed to reverse the links of every K elements on L. For example, given L being 1→2→3→4→5→6, if K=3, then you must output 3→2→1→6→5→4; if K=4, you must output 4→3→2→1→5→6.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line contains the address of the first node, a positive N (≤105) which is the total number of nodes, and a positive K (≤N) which is the length of the sublist to be reversed. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1.</p>
<p>Then N lines follow, each describes a node in the format:</p>
<pre><code>Address Data Next
</code></pre>
<p>where <code>Address</code> is the position of the node, <code>Data</code> is an integer, and <code>Next</code> is the position of the next node.</p>
<p>Output Specification:</p>
<p>For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input.</p>
<p>Sample Input:</p>
<pre><code>00100 6 4
00000 4 99999
00100 1 12309
68237 6 -1
33218 3 00000
99999 5 68237
12309 2 33218
</code></pre>
<p>Sample Output:</p>
<pre><code>00000 4 33218
33218 3 12309
12309 2 00100
00100 1 99999
99999 5 68237
68237 6 -1
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312131450347.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312131451609.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312131451508.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef int Address;
typedef int Data;
typedef struct Node *Ptr;
#define MaxSize 100001

struct Node
{
    Data data;
    Address next;
}Nodes[MaxSize];

int List[MaxSize];

void Reverse(Address head, Address tail)
{
    int tempHead = head;
    int tempTail = tail;
    int list;
    while(tempTail &gt; tempHead)
    {
        list = List[tempHead];
        List[tempHead] = List[tempTail];
        List[tempTail] = list;
        tempHead++;
        tempTail--;
    }
}


int main()
{
    int n;
    Address root;
    int K;
    scanf(&quot;%d %d %d&quot;,&amp;root,&amp;n,&amp;K);
    Address address;
    Data data;
    Address next;
    for(int i=0; i&lt;n; i++)
    {
        scanf(&quot;%d %d %d&quot;, &amp;address,&amp;data,&amp;next);
        Nodes[address].data = data;
        Nodes[address].next = next;
    }
    int maxn = 0;
    int pMove = root;
    while(pMove != -1)
    {
        List[maxn++] = pMove;
        pMove = Nodes[pMove].next;
    }
    int i = 0;
    while(i + K &lt; maxn)
    {
        Reverse(i,i+K-1);
        i = i + K;
    }
    for(i=0;i&lt;maxn-1;i++)
        printf(&quot;%05d %d %05d\n&quot;,List[i],Nodes[List[i]].data,List[i+1]);
    printf(&quot;%05d %d -1\n&quot;,List[i],Nodes[List[i]].data);
    return 0;
}
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312131634780.png" alt="" /></p>
<p>使用C++的reverse函数解法如下：</p>
<pre><code class="language-c">#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;    ///使用到reverse 翻转函数
using namespace std;
 
#define MAXSIZE 1000010   ///最大为五位数的地址
 
struct node    ///使用顺序表存储data和下一地址next
{
   int data;   
   int next;
}node[MAXSIZE];
 
int List[MAXSIZE];   ///存储可以连接上的顺序表
int main()
{
    int First, n, k;  
    cin&gt;&gt;First&gt;&gt;n&gt;&gt;k;   ///输入头地址 和 n，k；
    int Address,Data,Next;
    for(int i=0;i&lt;n;i++)
    {
        cin&gt;&gt;Address&gt;&gt;Data&gt;&gt;Next;
        node[Address].data=Data;
        node[Address].next=Next;
    }
 
    int j=0;  ///j用来存储能够首尾相连的节点数
    int p=First;   ///p指示当前结点
    while(p!=-1)
    {
        List[j++]=p;
        p=node[p].next;
    }
    int i=0;
    while(i+k&lt;=j)   ///每k个节点做一次翻转
    {
        reverse(&amp;List[i],&amp;List[i+k]);
        i=i+k;
    }
    for(i=0;i&lt;j-1;i++)
        printf(&quot;%05d %d %05d\n&quot;,List[i],node[List[i]].data,List[i+1]);
    printf(&quot;%05d %d -1\n&quot;,List[i],node[List[i]].data);
    return 0;
}
</code></pre>
<h2 id="pta-02-线性结构4-pop-sequence"><a class="header" href="#pta-02-线性结构4-pop-sequence">PTA 02-线性结构4 Pop Sequence</a></h2>
<p>Given a stack which can keep M numbers at most. Push N numbers in the order of 1, 2, 3, ..., N and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if M is 5 and N is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): M (the maximum capacity of the stack), N (the length of push sequence), and K (the number of pop sequences to be checked). Then K lines follow, each contains a pop sequence of N numbers. All the numbers in a line are separated by a space.</p>
<p>Output Specification:</p>
<p>For each pop sequence, print in one line &quot;YES&quot; if it is indeed a possible pop sequence of the stack, or &quot;NO&quot; if not.</p>
<p>Sample Input:</p>
<p><code>5 7 5 1 2 3 4 5 6 7 3 2 1 7 5 6 4 7 6 5 4 3 2 1 5 6 4 3 7 2 1 1 7 6 5 4 3 2   </code></p>
<p>Sample Output:</p>
<pre><code class="language-out">YES
NO
NO
YES
NO
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define Maxsize 1000//最大容量
typedef struct Node
{
    int Top;//栈顶
    int Data[Maxsize];//元素
    int Capacity;//容量
}*Stack;

int Test(int Array[],int M,int N)
{
    int count = 0;
    Stack Pile = (Stack)malloc(sizeof(struct Node));//申请并初始化一个空栈
    Pile-&gt;Capacity = M;
    Pile-&gt;Top = -1;
    for(int i = 1;i &lt;= N;i++)
    {
        if(Pile-&gt;Capacity == Pile-&gt;Top+1)//栈满
            return 0;
        else
            Pile-&gt;Data[++Pile-&gt;Top] = i;//入栈
        while(Pile-&gt;Data[Pile-&gt;Top] == Array[count])
        {//比较栈顶是否与某数相等
            Pile-&gt;Top--;//出栈
            count++;//数组往后移位
        }
    }
    if(count == N)//全部找到并且输出时
        return 1;
    else
        return 0;
}

int main()
{
    int M,N,K;
    scanf(&quot;%d %d %d&quot;,&amp;M,&amp;N,&amp;K);
    int Array[N];
    for(int i=0; i&lt;K; i++)
    {
        for(int j=0; j&lt;N; j++)
        {
            scanf(&quot;%d&quot;,&amp;Array[j]);
        }
        if(Test(Array,M,N))
            printf(&quot;YES\n&quot;);
        else
            printf(&quot;NO\n&quot;);
    }
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<ul>
<li><a href="%E6%A0%91.html#%E5%BC%95%E5%AD%90%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">引子：二分查找</a></li>
<li><a href="%E6%A0%91.html#%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89">树的定义</a></li>
</ul>
<h2 id="引子二分查找"><a class="header" href="#引子二分查找">引子：二分查找</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311071516238.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311071517513.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311071517306.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311071518809.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311071518159.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311071520969.png" alt="" /></p>
<pre><code class="language-c">int BinarySearch(StaticTable *Tbl,ElementType K)
{
    int left,right,mid,NotFound = -1;
    left = 1;
    right = Tbl-&gt;Length;

    while(left &lt;= right)
    {
        mid = (left + right) / 2;
        if(K &gt; Tbl-&gt;Element[mid])
            left = mid + 1;
        else if(K &lt; Tbl-&gt;Element[mid])
            right = mid - 1;
        else
            return mid;
    }
    return NotFound;
}
</code></pre>
<p>在分量1~11的数组中按从小到大顺序存放11个元素，如果用顺序查找和二分查找分别查找这11个元素，哪个位置的元素在这两种方法的查找中总次数最少？1</p>
<p>在分量1~11的数组中按从小到大顺序存放11个元素，如果进行二分查找，查找次数最少的元素位于什么位置？6</p>
<p>测试程序如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int OrderSearch(int arr[],int n,int x)
{
    for(int i = 0 ; i &lt; n; i++)
    {
        if(x == arr[i])
            return i;
    }
    return -1;
}

int BinarySearch(int arr[],int n,int x)
{
    int left = 0;
    int right = n-1;
    int mid;
    while(left &lt;= right)
    {
        mid = (left + right) / 2;
        if(arr[mid] &lt; x)
            left = mid + 1;
        else if(arr[mid] &gt; x)
            right = mid - 1;
        else
            return mid;
    }
    return -1;
}

int main()
{
    int n = 10;
    int arr[10] = {1,2,3,4,5,6,7,8,9,10};
    int x = 3;
    printf(&quot;%d\n&quot;,BinarySearch(arr,n,x));
    printf(&quot;%d\n&quot;,OrderSearch(arr,n,x));
    return 0;
}
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311071525846.png" alt="" /></p>
<p>ASL：Average Search Length平均查找长度</p>
<h2 id="树的定义"><a class="header" href="#树的定义">树的定义</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311071534677.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311071534726.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311071535966.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311071535157.png" alt="" /></p>
<p>有一个m棵树的集合（也叫森林）共有k条边，问这m颗树共有多少个结点？k+m</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311071536714.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311071537314.png" alt="" /></p>
<p>在用“儿子-兄弟”法表示的树中，如果从根结点开始访问其“次子”的“次子”，所经过的结点数与从根结点开始访问其“长子”的“长子”的“长子”的“长子”一样。(注意:比较的是结点数,而不是路径)</p>
<p>一棵度为 m的树有n个节点。若每个节点直接用m个链指向相应的儿子，则表示这个树所需要的总空间是n*(m+1) (假定每个链以及表示节点的数据域都是一个单位空间).。当采用儿子/兄弟（First Child/Next Sibling）表示法时，所需的总空间是：3n</p>
<p>树的集合称为森林。是否也可以使用“儿子-兄弟”表示法存储森林？如何实现？</p>
<p>是的，可以使用&quot;儿子-兄弟&quot;表示法（又称作&quot;左孩子-右兄弟&quot;表示法或&quot;孩子兄弟链表&quot;）来存储森林，其中每个节点表示一棵树。这种表示法适用于多叉树和森林结构，它使用两个指针来表示树中的节点之间的关系：左孩子指针和右兄弟指针。左孩子指针指向当前节点的第一个子节点，而右兄弟指针指向当前节点的兄弟节点。</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="二叉树"><a class="header" href="#二叉树">二叉树</a></h1>
<ul>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89">二叉树的定义</a></li>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">二叉树的存储结构</a></li>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA">二叉树的创建</a>
<ul>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%9D%9E%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F">非递归方式</a></li>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F">递归方式</a></li>
</ul>
</li>
<li><a href="%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86">二叉树的遍历</a></li>
</ul>
<h2 id="二叉树的定义"><a class="header" href="#二叉树的定义">二叉树的定义</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311101639161.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311101640282.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311101640953.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311101641998.png" alt="" /></p>
<h2 id="二叉树的存储结构"><a class="header" href="#二叉树的存储结构">二叉树的存储结构</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311101641616.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311101642386.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311101642383.png" alt="" /></p>
<p>链表结构：</p>
<pre><code class="language-c">typedef struct TNode *Position;
typedef Position BinTree; /* 二叉树类型 */
struct TNode{ /* 树结点定义 */
    ElementType Data; /* 结点数据 */
    BinTree Left;     /* 指向左子树 */
    BinTree Right;    /* 指向右子树 */
};
</code></pre>
<p>包含较多别名的写法如下：</p>
<pre><code class="language-c">typedef struct treenode
{
    char data;
    struct treenode* LChild;
    struct treenode* RChild;
}NODE,*LPNODE,*LPTREE;

//struct treenode : NODE
//struct treenode* : LPNODE或LPTREE
NODE node1;
struct treenode* p = NULL;
LPNODE p1 = NULL;
</code></pre>
<h2 id="二叉树的创建"><a class="header" href="#二叉树的创建">二叉树的创建</a></h2>
<h3 id="非递归方式"><a class="header" href="#非递归方式">非递归方式</a></h3>
<p>实现代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct TreeNode *LPNODE;
typedef LPNODE BinTree;
typedef char ElementType;

struct TreeNode
{
    ElementType Data;
    BinTree Left;
    BinTree Right;
};

LPNODE CreateNode(ElementType Data)
{
    LPNODE newNode = (LPNODE)malloc(sizeof(struct TreeNode));
    newNode-&gt;Left = NULL;
    newNode-&gt;Right = NULL;
    newNode-&gt;Data = Data;
    return newNode;
}

/* 非递归创建树 */
void InsertNode(BinTree parent, LPNODE Left, LPNODE Right)
{
    parent-&gt;Left = Left;
    parent-&gt;Right = Right;
}

void PreOrderTraversal(BinTree BT)
{
    if(BT)
    {
        printf(&quot;%c &quot;,BT-&gt;Data);
        PreOrderTraversal(BT-&gt;Left);
        PreOrderTraversal(BT-&gt;Right);
    }
}

void InOrderTraversal(BinTree BT)
{
    if(BT)
    {
        InOrderTraversal(BT-&gt;Left);
        printf(&quot;%c &quot;,BT-&gt;Data);
        InOrderTraversal(BT-&gt;Right);
    }
}

void PostOrderTraversal(BinTree BT)
{
    if(BT)
    {
        PostOrderTraversal(BT-&gt;Left);
        PostOrderTraversal(BT-&gt;Right);
        printf(&quot;%c &quot;,BT-&gt;Data);
    }
}

int main()
{
    LPNODE A = CreateNode('A');
    LPNODE B = CreateNode('B');
    LPNODE C = CreateNode('C');
    LPNODE D = CreateNode('D');
    LPNODE E = CreateNode('E');
    LPNODE F = CreateNode('F');
    InsertNode(A,B,C);
    InsertNode(B,D,NULL);
    InsertNode(C,E,NULL);
    InsertNode(E,NULL,F);
    PreOrderTraversal(A);
    printf(&quot;\n&quot;);
    InOrderTraversal(A);
    printf(&quot;\n&quot;);
    PostOrderTraversal(A);
    printf(&quot;\n&quot;);
    return 0;
}
</code></pre>
<pre><code>A B D C E F
D B A E F C
D B F E C A
</code></pre>
<h3 id="递归方式"><a class="header" href="#递归方式">递归方式</a></h3>
<p>实现代码如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef char ElementType;

typedef struct TreeNode
{
    ElementType Data;
    struct TreeNode* Left;
    struct TreeNode* Right;
}NODE,*LPNODE,*LPTREE;

/* 递归创建树 */
void createTree(LPTREE* root)
{
    char userKey = '\0';
    scanf_s(&quot;%c&quot;,&amp;userKey,1);
    if(userKey == '#')
    {
        *root = NULL;
    }
    else
    {
        *root = (LPTREE)malloc(sizeof(struct TreeNode));
        (*root)-&gt;Data = userKey;
        createTree(&amp;(*root)-&gt;Left);
        createTree(&amp;(*root)-&gt;Right);
    }
}

void PreOrderTraversal(LPTREE BT)
{
    if(BT)
    {
        printf(&quot;%c &quot;,BT-&gt;Data);
        PreOrderTraversal(BT-&gt;Left);
        PreOrderTraversal(BT-&gt;Right);
    }
}

int main()
{
    LPTREE root = NULL;
    createTree(&amp;root);
    printf(&quot;PreOrderTraversal:\n&quot;);
    PreOrderTraversal(root);
    printf(&quot;\n&quot;);
    return 0;
}
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311111523681.png" alt="" /></p>
<pre><code>ABD###CE#F###
PreOrderTraversal:
A B D C E F
</code></pre>
<h2 id="二叉树的遍历"><a class="header" href="#二叉树的遍历">二叉树的遍历</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311101506933.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311101508256.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311101511971.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311101512108.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311101516043.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311101521105.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct TreeNode *LPNODE;
typedef LPNODE BinTree;
typedef char ElementType;

struct TreeNode
{
    ElementType Data;
    BinTree Left;
    BinTree Right;
};

LPNODE CreateNode(ElementType Data)
{
    LPNODE newNode = (LPNODE)malloc(sizeof(struct TreeNode));
    newNode-&gt;Left = NULL;
    newNode-&gt;Right = NULL;
    newNode-&gt;Data = Data;
    return newNode;
}

void InsertNode(BinTree parent, LPNODE Left, LPNODE Right)
{
    parent-&gt;Left = Left;
    parent-&gt;Right = Right;
}

void PreOrderTraversal(BinTree BT)
{
    if(BT)
    {
        printf(&quot;%c &quot;,BT-&gt;Data);
        PreOrderTraversal(BT-&gt;Left);
        PreOrderTraversal(BT-&gt;Right);
    }
}

void PreOrderTraversalByStack(BinTree BT)
{
    if(BT == NULL)
        return;
    LPNODE pMove = BT;
    LPNODE stack[100];
    int stackTop = -1;
    while(stackTop != -1 || pMove)
    {
        while(pMove)
        {
            printf(&quot;%c &quot;,pMove-&gt;Data);
            stack[++stackTop] = pMove;
            pMove = pMove-&gt;Left;
        }
        if(stackTop != -1)
        {
            pMove = stack[stackTop--];
            pMove = pMove-&gt;Right;
        }
    }

}

void InOrderTraversal(BinTree BT)
{
    if(BT)
    {
        InOrderTraversal(BT-&gt;Left);
        printf(&quot;%c &quot;,BT-&gt;Data);
        InOrderTraversal(BT-&gt;Right);
    }
}

void InOrderTraversalByStack(BinTree BT)
{
    if(BT == NULL)
        return;
    LPNODE pMove = BT;
    LPNODE stack[100];
    int stackTop = -1;
    while(stackTop != -1 || pMove)
    {
        while(pMove)
        {
            stack[++stackTop] = pMove;
            pMove = pMove-&gt;Left;
        }
        if(stackTop != -1)
        {
            pMove = stack[stackTop--];
            printf(&quot;%c &quot;,pMove-&gt;Data);
            pMove = pMove-&gt;Right;
        }
    }

}

void PostOrderTraversal(BinTree BT)
{
    if(BT)
    {
        PostOrderTraversal(BT-&gt;Left);
        PostOrderTraversal(BT-&gt;Right);
        printf(&quot;%c &quot;,BT-&gt;Data);
    }
}

void PostOrderTraversalByStack(BinTree BT)
{
    if(BT == NULL)
        return;
    LPNODE pMove = BT;
    LPNODE stack[100];
    int stackTop = -1;
    LPNODE placeVisited = NULL;

    while(pMove)
    {
        stack[++stackTop] = pMove;
        pMove = pMove-&gt;Left;
    }

    while(stackTop != -1)
    {
        pMove = stack[stackTop--];
        if(pMove-&gt;Right == NULL || pMove-&gt;Right == placeVisited)
        {
            printf(&quot;%c &quot;,pMove-&gt;Data);
            placeVisited = pMove;
        }
        else
        {
            stack[++stackTop] = pMove;
            pMove = pMove-&gt;Right;
            while(pMove)
            {
                stack[++stackTop] = pMove;
                pMove = pMove-&gt;Left;
            }
        }
    }

}

void LevelTraversal(BinTree BT)
{
    LPNODE pMove = BT;
    LPNODE queue[100];
    int front = 0;
    int tail = 0;
    queue[tail++] = pMove;
    printf(&quot;%c &quot;,pMove-&gt;Data);
    while(front != tail)
    {
        pMove = queue[front++];
        if(pMove-&gt;Left != NULL)
        {
            queue[tail++] = pMove-&gt;Left;
            printf(&quot;%c &quot;,pMove-&gt;Left-&gt;Data);
        }
        if(pMove-&gt;Right != NULL)
        {
            queue[tail++] = pMove-&gt;Right;
            printf(&quot;%c &quot;,pMove-&gt;Right-&gt;Data);
        }

    }

}

int main()
{
    LPNODE A = CreateNode('A');
    LPNODE B = CreateNode('B');
    LPNODE C = CreateNode('C');
    LPNODE D = CreateNode('D');
    LPNODE E = CreateNode('E');
    LPNODE F = CreateNode('F');
    InsertNode(A,B,C);
    InsertNode(B,D,NULL);
    InsertNode(C,E,NULL);
    InsertNode(E,NULL,F);
    printf(&quot;PreOrderTraversal:\n&quot;);
    PreOrderTraversal(A);
    printf(&quot;\nPreOrderTraversalByStack:\n&quot;);
    PreOrderTraversalByStack(A);
    printf(&quot;\nInOrderTraversal:\n&quot;);
    InOrderTraversal(A);
    printf(&quot;\nInOrderTraversalByStack:\n&quot;);
    InOrderTraversalByStack(A);
    printf(&quot;\nPostOrderTraversal:\n&quot;);
    PostOrderTraversal(A);
    printf(&quot;\nPostOrderTraversalByStack:\n&quot;);
    PostOrderTraversalByStack(A);
    printf(&quot;\nLevelTraversal:\n&quot;);
    LevelTraversal(A);
    printf(&quot;\n&quot;);
    return 0;
}
</code></pre>
<pre><code>PreOrderTraversal:
A B D C E F
PreOrderTraversalByStack:
A B D C E F
InOrderTraversal:
D B A E F C
InOrderTraversalByStack:
D B A E F C
PostOrderTraversal:
D B F E C A
PostOrderTraversalByStack:
D B F E C A
LevelTraversal:
A B C D E F
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312171447057.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312171447647.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312171447451.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312171448402.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312171448472.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312171449028.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312171450705.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312171450936.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312171450475.png" alt="" /></p>
<p>1.假定只有四个结点A、B、C、D的二叉树，其前序遍历序列为ABCD，则下面哪个序列是不可能的中序遍历序列？</p>
<p>A.ABCD</p>
<p>B.ACDB</p>
<p>C.DCBA</p>
<p>D.DABC</p>
<p>正确答案：D你选对了</p>
<p>2对于二叉树，如果其中序遍历结果与前序遍历结果一样，那么可以断定该二叉树________</p>
<p>A.是完全二叉树</p>
<p>B.所有结点都没有左儿子</p>
<p>C.所有结点都没有右儿子</p>
<p>D.这样的树不存在</p>
<p>正确答案：B你选对了</p>
<p>3已知一二叉树的后序和中序遍历的结果分别是FDEBGCA 和FDBEACG,那么该二叉树的前序遍历结果是什么？</p>
<p>A.ABDFECG</p>
<p>B.ABDEFCG</p>
<p>C.ABDFEGC</p>
<p>D.ABCDEFG</p>
<p>正确答案：A你选对了</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="二叉搜索树"><a class="header" href="#二叉搜索树">二叉搜索树</a></h1>
<p>查找分为静态查找和动态查找。静态查找可以使用二分查找方式。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311121615700.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311121616062.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311121616955.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311121623845.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311121623598.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311121624932.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311121624587.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311121624794.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311121625911.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311121625860.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311121625854.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311121626802.png" alt="" /></p>
<p>若一搜索树（查找树）是一个有n个结点的完全二叉树，则该树的最大值一定在叶结点上</p>
<p>错误</p>
<p>若一搜索树（查找树）是一个有n个结点的完全二叉树，则该树的最小值一定在叶结点上</p>
<p>正确</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311121626053.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef int ElementType;

typedef struct TreeNode *BinTree;

typedef BinTree Position;

typedef struct TreeNode
{
    ElementType Data;
    BinTree Left;
    BinTree Right;
}*LPNODE;

BinTree Insert(ElementType X,BinTree BST)
{
    if(!BST)
    {
        /*若原树为空，生成并返回一个结点的二叉搜索树*/
        BST = (BinTree)malloc(sizeof(struct TreeNode));
        BST-&gt;Data = X;
        BST-&gt;Left = NULL;
        BST-&gt;Right = NULL;
    }
    else   /*开始找要插入元素的位置*/
    {
        if(BST-&gt;Data &lt; X)
            BST-&gt;Right = Insert(X,BST-&gt;Right);
        else if(BST-&gt;Data &gt; X)
            BST-&gt;Left = Insert(X,BST-&gt;Left);
        /*else X已经存在，什么都不做 */
    }
    return BST;
}


/*尾递归方式查找*/
ElementType Find(ElementType X,BinTree BST)
{
    if(!BST)
        return NULL;
    if(BST-&gt;Data &lt; X)
        return Find(X,BST-&gt;Right);
    else if(BST-&gt;Data &gt; X)
        return Find(X,BST-&gt;Left);
    else       /*X == BST-&gt;Data*/
        return BST; /*查找成功，返回找到结点的地址*/
}

/*迭代、非递归方式*/
Position FindMax(BinTree BST)
{
    if(BST)
        while(BST-&gt;Right)
            BST = BST-&gt;Right;
    return BST;
}



Position FindMin(BinTree BST)
{
    if(!BST)
        return NULL;
    else if(!BST-&gt;Left)  /*有根结点，但没有左子树，直接返回根*/
            return BST;
    else
        return FindMin(BST-&gt;Left);
}

BinTree Delete(ElementType X,BinTree BST)
{
    Position Tmp;
    if(!BST)
        printf(&quot;找不到要删除的元素！\n&quot;);
    else if(X &lt; BST-&gt;Data)
        BST-&gt;Left = Delete(X,BST-&gt;Left);
    else if(X &gt; BST-&gt;Data)
        BST-&gt;Right = Delete(X,BST-&gt;Right);
    else
    {
        if(BST-&gt;Left &amp;&amp; BST-&gt;Right)
        {
            Tmp = FindMin(BST-&gt;Right);
            BST-&gt;Data = Tmp-&gt;Data;
            BST-&gt;Right = Delete(BST-&gt;Data,BST-&gt;Right);
        }
        else
        {
            Tmp = BST;
            if(!BST-&gt;Left)
                BST = BST-&gt;Right;
            else if(!BST-&gt;Right)
                BST = BST-&gt;Left;
            free(Tmp);
        }
    }
    return BST;

}

void PreOrderTraversalByStack(BinTree BST)
{
    if(!BST)
        return;
    BinTree pMove = BST;
    BinTree stack[100];
    int stackTop = -1;

    while(pMove || stackTop != -1 )
    {
        while(pMove)
        {
            printf(&quot;%d &quot;,pMove-&gt;Data);
            stack[++stackTop] = pMove;
            pMove = pMove-&gt;Left;
        }
        if(stackTop != -1)
        {
            pMove = stack[stackTop--];
            pMove = pMove-&gt;Right;
            while(pMove)
            {
                printf(&quot;%d &quot;,pMove-&gt;Data);
                stack[++stackTop] = pMove;
                pMove = pMove-&gt;Left;
            }
        }
    }
}

void InOrderTraversalByStack(BinTree BST)
{
    if(!BST)
        return;
    BinTree pMove = BST;
    BinTree stack[100];
    int stackTop = -1;

    while(pMove || stackTop != -1 )
    {
        while(pMove)
        {
            stack[++stackTop] = pMove;
            pMove = pMove-&gt;Left;
        }
        if(stackTop != -1)
        {
            pMove = stack[stackTop--];
            printf(&quot;%d &quot;,pMove-&gt;Data);
            pMove = pMove-&gt;Right;
            while(pMove)
            {
                stack[++stackTop] = pMove;
                pMove = pMove-&gt;Left;
            }
        }
    }
}


void LevelTraversal(BinTree BT)
{
    LPNODE pMove = BT;
    LPNODE queue[100];
    int front = 0;
    int tail = 0;
    queue[tail++] = pMove;
    printf(&quot;%d &quot;,pMove-&gt;Data);
    while(front != tail)
    {
        pMove = queue[front++];
        if(pMove-&gt;Left != NULL)
        {
            queue[tail++] = pMove-&gt;Left;
            printf(&quot;%d &quot;,pMove-&gt;Left-&gt;Data);
        }
        if(pMove-&gt;Right != NULL)
        {
            queue[tail++] = pMove-&gt;Right;
            printf(&quot;%d &quot;,pMove-&gt;Right-&gt;Data);
        }

    }

}

int main()
{
    BinTree BST = NULL;
    BST = Insert(5,BST);
    BST = Insert(3,BST);
    BST = Insert(4,BST);
    BST = Insert(9,BST);
    BST = Insert(20,BST);
    BST = Insert(30,BST);
    BST = Insert(40,BST);
    BST = Insert(43,BST);
    BST = Insert(34,BST);
    BST = Insert(6,BST);
    BST = Insert(7,BST);
    BST = Insert(8,BST);
    LevelTraversal(BST);
    printf(&quot;\n%d&quot;,FindMax(BST)-&gt;Data);
    printf(&quot;\n%d&quot;,FindMin(BST)-&gt;Data);
    BST = Delete(43,BST);
    BST = Delete(3,BST);
    printf(&quot;\n&quot;);
    LevelTraversal(BST);
    printf(&quot;\n%d&quot;,FindMax(BST)-&gt;Data);
    printf(&quot;\n%d&quot;,FindMin(BST)-&gt;Data);
    BinTree Tmp = Find(100,BST);
    if(!Tmp)
        printf(&quot;\nNULL\n&quot;);
    else
        printf(&quot;\n%d\n&quot;,Find(100,BST));
        //printf(&quot;\n%d\n&quot;,Tmp-&gt;Data);
    return 0;

}
</code></pre>
<pre><code>5 3 9 4 6 20 7 30 8 40 34 43
43
3
5 4 9 6 20 7 30 8 40 34
40
4
NULL
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="平衡二叉树"><a class="header" href="#平衡二叉树">平衡二叉树</a></h1>
<ul>
<li><a href="%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E5%AE%9A%E4%B9%89">定义</a></li>
<li><a href="%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%B0%83%E6%95%B4">平衡二叉树的调整</a></li>
<li><a href="%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E5%AE%9E%E4%BE%8B-pta-04-%E6%A0%915-root-of-avl-tree">实例 PTA 04-树5 Root of AVL Tree</a></li>
</ul>
<h2 id="定义-1"><a class="header" href="#定义-1">定义</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311141629827.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311141629969.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311141630904.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311141630738.png" alt="" /></p>
<p>1将1、2、3、4、5、6顺序插入初始为空的AVL树中，当完成这6个元素的插入后，该AVL树共有多少层？ 3</p>
<p>2若一AVL树的结点数是21，则该树的高度至多是多少？5</p>
<p>注：只有一个根节点的树高度为0</p>
<h2 id="平衡二叉树的调整"><a class="header" href="#平衡二叉树的调整">平衡二叉树的调整</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311141631370.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311141632853.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311141632264.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311141632633.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311141633646.png" alt="" /></p>
<p>《数据结构》课程给出的代码如下：</p>
<pre><code class="language-c">typedef struct AVLNode *Position;
typedef Position AVLTree; /* AVL树类型 */
struct AVLNode{
    ElementType Data; /* 结点数据 */
    AVLTree Left;     /* 指向左子树 */
    AVLTree Right;    /* 指向右子树 */
    int Height;       /* 树高 */
};

int Max ( int a, int b )
{
    return a &gt; b ? a : b;
}

AVLTree SingleLeftRotation ( AVLTree A )
{ /* 注意：A必须有一个左子结点B */
  /* 将A与B做左单旋，更新A与B的高度，返回新的根结点B */     

    AVLTree B = A-&gt;Left;
    A-&gt;Left = B-&gt;Right;
    B-&gt;Right = A;
    A-&gt;Height = Max( GetHeight(A-&gt;Left), GetHeight(A-&gt;Right) ) + 1;
    B-&gt;Height = Max( GetHeight(B-&gt;Left), A-&gt;Height ) + 1;
 
    return B;
}

AVLTree DoubleLeftRightRotation ( AVLTree A )
{ /* 注意：A必须有一个左子结点B，且B必须有一个右子结点C */
  /* 将A、B与C做两次单旋，返回新的根结点C */
    
    /* 将B与C做右单旋，C被返回 */
    A-&gt;Left = SingleRightRotation(A-&gt;Left);
    /* 将A与C做左单旋，C被返回 */
    return SingleLeftRotation(A);
}

/*************************************/
/* 对称的右单旋与右-左双旋请自己实现 */
/*************************************/

AVLTree Insert( AVLTree T, ElementType X )
{ /* 将X插入AVL树T中，并且返回调整后的AVL树 */
    if ( !T ) { /* 若插入空树，则新建包含一个结点的树 */
        T = (AVLTree)malloc(sizeof(struct AVLNode));
        T-&gt;Data = X;
        T-&gt;Height = 0;
        T-&gt;Left = T-&gt;Right = NULL;
    } /* if (插入空树) 结束 */

    else if ( X &lt; T-&gt;Data ) {
        /* 插入T的左子树 */
        T-&gt;Left = Insert( T-&gt;Left, X);
        /* 如果需要左旋 */
        if ( GetHeight(T-&gt;Left)-GetHeight(T-&gt;Right) == 2 )
            if ( X &lt; T-&gt;Left-&gt;Data ) 
               T = SingleLeftRotation(T);      /* 左单旋 */
            else 
               T = DoubleLeftRightRotation(T); /* 左-右双旋 */
    } /* else if (插入左子树) 结束 */
    
    else if ( X &gt; T-&gt;Data ) {
        /* 插入T的右子树 */
        T-&gt;Right = Insert( T-&gt;Right, X );
        /* 如果需要右旋 */
        if ( GetHeight(T-&gt;Left)-GetHeight(T-&gt;Right) == -2 )
            if ( X &gt; T-&gt;Right-&gt;Data ) 
               T = SingleRightRotation(T);     /* 右单旋 */
            else 
               T = DoubleRightLeftRotation(T); /* 右-左双旋 */
    } /* else if (插入右子树) 结束 */

    /* else X == T-&gt;Data，无须插入 */

    /* 别忘了更新树高 */
    T-&gt;Height = Max( GetHeight(T-&gt;Left), GetHeight(T-&gt;Right) ) + 1;
    
    return T;
}
</code></pre>
<h2 id="实例-pta-04-树5-root-of-avl-tree"><a class="header" href="#实例-pta-04-树5-root-of-avl-tree">实例 PTA 04-树5 Root of AVL Tree</a></h2>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;


typedef int ElementType;
typedef struct AVLNode *Position;
typedef Position AVLTree; /* AVL树类型 */
struct AVLNode{
    ElementType Data; /* 结点数据 */
    AVLTree Left;     /* 指向左子树 */
    AVLTree Right;    /* 指向右子树 */
    int Height;       /* 树高 */
};

int Max ( int a, int b )
{
    return a &gt; b ? a : b;
}

int GetHeight(AVLTree T)
{
    if (!T)
        return -1;
    else
        return T-&gt;Height;
}


AVLTree SingleLeftRotation ( AVLTree A )
{ /* 注意：A必须有一个左子结点B */
  /* 将A与B做左单旋，更新A与B的高度，返回新的根结点B */

    AVLTree B = A-&gt;Left;
    A-&gt;Left = B-&gt;Right;
    B-&gt;Right = A;
    A-&gt;Height = Max( GetHeight(A-&gt;Left), GetHeight(A-&gt;Right) ) + 1;
    B-&gt;Height = Max( GetHeight(B-&gt;Left), A-&gt;Height ) + 1;

    return B;
}

AVLTree SingleRightRotation(AVLTree A)//麻烦结点存在右子树的右边
{
    AVLTree B=A-&gt;Right;
    A-&gt;Right=B-&gt;Left;//右子树的左儿子赋给A的右子树
    B-&gt;Left=A;//B变成A的父结点
    A-&gt;Height=Max(GetHeight(A-&gt;Left),GetHeight(A-&gt;Right))+1;
    B-&gt;Height=Max(A-&gt;Height,GetHeight(B-&gt;Right))+1;
    return B;
}


AVLTree DoubleRightLeftRotation(AVLTree A)//麻烦结点存在右子树的左边
{
    A-&gt;Right=SingleLeftRotation(A-&gt;Right);
    return SingleRightRotation(A);
}

AVLTree DoubleLeftRightRotation ( AVLTree A )
{ /* 注意：A必须有一个左子结点B，且B必须有一个右子结点C */
  /* 将A、B与C做两次单旋，返回新的根结点C */

    /* 将B与C做右单旋，C被返回 */
    A-&gt;Left = SingleRightRotation(A-&gt;Left);
    /* 将A与C做左单旋，C被返回 */
    return SingleLeftRotation(A);
}


AVLTree Insert( AVLTree T, ElementType X )
{ /* 将X插入AVL树T中，并且返回调整后的AVL树 */
    if ( !T ) { /* 若插入空树，则新建包含一个结点的树 */
        T = (AVLTree)malloc(sizeof(struct AVLNode));
        T-&gt;Data = X;
        T-&gt;Height = 0;
        T-&gt;Left = T-&gt;Right = NULL;
    } /* if (插入空树) 结束 */

    else if ( X &lt; T-&gt;Data ) {
        /* 插入T的左子树 */
        T-&gt;Left = Insert( T-&gt;Left, X);
        /* 如果需要左旋 */
        if ( GetHeight(T-&gt;Left)-GetHeight(T-&gt;Right) == 2 )
            if ( X &lt; T-&gt;Left-&gt;Data )
               T = SingleLeftRotation(T);      /* 左单旋 */
            else
               T = DoubleLeftRightRotation(T); /* 左-右双旋 */
    } /* else if (插入左子树) 结束 */

    else if ( X &gt; T-&gt;Data ) {
        /* 插入T的右子树 */
        T-&gt;Right = Insert( T-&gt;Right, X );
        /* 如果需要右旋 */
        if ( GetHeight(T-&gt;Left)-GetHeight(T-&gt;Right) == -2 )
            if ( X &gt; T-&gt;Right-&gt;Data )
               T = SingleRightRotation(T);     /* 右单旋 */
            else
               T = DoubleRightLeftRotation(T); /* 右-左双旋 */
    } /* else if (插入右子树) 结束 */

    /* else X == T-&gt;Data，无须插入 */

    /* 别忘了更新树高 */
    T-&gt;Height = Max( GetHeight(T-&gt;Left), GetHeight(T-&gt;Right) ) + 1;

    return T;
}

int main()
{
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    ElementType X;
    AVLTree T = NULL;
    for(int i=0; i&lt;n; i++)
    {
        scanf(&quot;%d&quot;, &amp;X);
        T = Insert(T,X);
    }
    if(T)
        printf(&quot;%d&quot;,T-&gt;Data);
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="堆"><a class="header" href="#堆">堆</a></h1>
<ul>
<li><a href="%E5%A0%86.html#%E5%AE%9A%E4%B9%89">定义</a></li>
<li><a href="%E5%A0%86.html#%E6%9C%80%E5%A4%A7%E5%A0%86">最大堆</a></li>
<li><a href="%E5%A0%86.html#%E6%9C%80%E5%B0%8F%E5%A0%86">最小堆</a></li>
<li><a href="%E5%A0%86.html#%E5%AE%9E%E4%BE%8B-pta-05-%E6%A0%917-%E5%A0%86%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84">实例 PTA 05-树7 堆中的路径</a></li>
</ul>
<h2 id="定义-2"><a class="header" href="#定义-2">定义</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311161522460.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311161522058.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311161523874.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311161524907.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311161525913.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311161525582.png" alt="" /></p>
<p>堆的定义与操作代码：</p>
<pre><code class="language-c">typedef struct HNode *Heap; /* 堆的类型定义 */
struct HNode {
    ElementType *Data; /* 存储元素的数组 */
    int Size;          /* 堆中当前元素个数 */
    int Capacity;      /* 堆的最大容量 */
};
typedef Heap MaxHeap; /* 最大堆 */
typedef Heap MinHeap; /* 最小堆 */

#define MAXDATA 1000  /* 该值应根据具体情况定义为大于堆中所有可能元素的值 */

MaxHeap CreateHeap( int MaxSize )
{ /* 创建容量为MaxSize的空的最大堆 */

    MaxHeap H = (MaxHeap)malloc(sizeof(struct HNode));
    H-&gt;Data = (ElementType *)malloc((MaxSize+1)*sizeof(ElementType));
    H-&gt;Size = 0;
    H-&gt;Capacity = MaxSize;
    H-&gt;Data[0] = MAXDATA; /* 定义&quot;哨兵&quot;为大于堆中所有可能元素的值*/

    return H;
}

bool IsFull( MaxHeap H )
{
    return (H-&gt;Size == H-&gt;Capacity);
}

bool Insert( MaxHeap H, ElementType X )
{ /* 将元素X插入最大堆H，其中H-&gt;Data[0]已经定义为哨兵 */
    int i;
 
    if ( IsFull(H) ) { 
        printf(&quot;最大堆已满&quot;);
        return false;
    }
    i = ++H-&gt;Size; /* i指向插入后堆中的最后一个元素的位置 */
    for ( ; H-&gt;Data[i/2] &lt; X; i/=2 )
        H-&gt;Data[i] = H-&gt;Data[i/2]; /* 上滤X */
    H-&gt;Data[i] = X; /* 将X插入 */
    return true;
}

#define ERROR -1 /* 错误标识应根据具体情况定义为堆中不可能出现的元素值 */

bool IsEmpty( MaxHeap H )
{
    return (H-&gt;Size == 0);
}

ElementType DeleteMax( MaxHeap H )
{ /* 从最大堆H中取出键值为最大的元素，并删除一个结点 */
    int Parent, Child;
    ElementType MaxItem, X;

    if ( IsEmpty(H) ) {
        printf(&quot;最大堆已为空&quot;);
        return ERROR;
    }

    MaxItem = H-&gt;Data[1]; /* 取出根结点存放的最大值 */
    /* 用最大堆中最后一个元素从根结点开始向上过滤下层结点 */
    X = H-&gt;Data[H-&gt;Size--]; /* 注意当前堆的规模要减小 */
    for( Parent=1; Parent*2&lt;=H-&gt;Size; Parent=Child ) {
        Child = Parent * 2;
        if( (Child!=H-&gt;Size) &amp;&amp; (H-&gt;Data[Child]&lt;H-&gt;Data[Child+1]) )
            Child++;  /* Child指向左右子结点的较大者 */
        if( X &gt;= H-&gt;Data[Child] ) break; /* 找到了合适位置 */
        else  /* 下滤X */
            H-&gt;Data[Parent] = H-&gt;Data[Child];
    }
    H-&gt;Data[Parent] = X;

    return MaxItem;
} 

/*----------- 建造最大堆 -----------*/
void PercDown( MaxHeap H, int p )
{ /* 下滤：将H中以H-&gt;Data[p]为根的子堆调整为最大堆 */
    int Parent, Child;
    ElementType X;

    X = H-&gt;Data[p]; /* 取出根结点存放的值 */
    for( Parent=p; Parent*2&lt;=H-&gt;Size; Parent=Child ) {
        Child = Parent * 2;
        if( (Child!=H-&gt;Size) &amp;&amp; (H-&gt;Data[Child]&lt;H-&gt;Data[Child+1]) )
            Child++;  /* Child指向左右子结点的较大者 */
        if( X &gt;= H-&gt;Data[Child] ) break; /* 找到了合适位置 */
        else  /* 下滤X */
            H-&gt;Data[Parent] = H-&gt;Data[Child];
    }
    H-&gt;Data[Parent] = X;
}

void BuildHeap( MaxHeap H )
{ /* 调整H-&gt;Data[]中的元素，使满足最大堆的有序性  */
  /* 这里假设所有H-&gt;Size个元素已经存在H-&gt;Data[]中 */

    int i;

    /* 从最后一个结点的父节点开始，到根结点1 */
    for( i = H-&gt;Size/2; i&gt;0; i-- )
        PercDown( H, i );
}
</code></pre>
<h2 id="最大堆"><a class="header" href="#最大堆">最大堆</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311161526556.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311161527923.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311161527298.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311161528060.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311161528366.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311161529828.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311161529994.png" alt="" /></p>
<p>建堆时，最坏情况下需要挪动元素次数是等于树中各结点的高度和。问：对于元素个数为12的堆，其各结点的高度之和是多少？10</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311161530234.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311161530537.png" alt="" /></p>
<p>在最大堆 {97,76,65,50,49,13,27}中插入83后，该最大堆为： {97,83,65,76,49,13,27,50}</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

typedef int ElementType;
typedef struct HNode *Heap;

struct HNode
{
    ElementType *Data;  //存储元素的数组
    int Size;           //堆中当前元素个数
    int Capacity;       //堆的最大容量
};

typedef Heap MaxHeap;
typedef Heap MinHeap;

#define MAXDATA  1000  //该值应根据具体情况定义为大于堆中所有可能元素的值

MaxHeap CreateHeap(int MaxSize)  //创建容量为MaxSize的空的最大堆
{
    MaxHeap H = (Heap)malloc(sizeof(struct HNode));
    H-&gt;Data = (ElementType *)malloc(sizeof(ElementType) * (MaxSize+1));
    H-&gt;Capacity = MaxSize;
    H-&gt;Size = 0;
    H-&gt;Data[0] = MAXDATA;    //定义&quot;哨兵&quot;为大于堆中所有可能元素的值
    return H;
}

bool IsFull(MaxHeap H)
{
    return (H-&gt;Size == H-&gt;Capacity);
}

bool Insert(MaxHeap H, ElementType X)  //将元素X插入最大堆H，其中H-&gt;Data[0]已经定义为哨兵
{
    if(IsFull(H))
    {
        printf(&quot;The heap is full!\n&quot;);
        return false;
    }
    int i = ++H-&gt;Size;                  //i指向插入后堆中的最后一个元素的位置
    for(;H-&gt;Data[i/2] &lt; X;i/=2)
    {
        H-&gt;Data[i] = H-&gt;Data[i/2];       //上滤X
    }
    H-&gt;Data[i] = X;
    return true;
}

bool IsEmpty(MaxHeap H)
{
    return (H-&gt;Size == 0);
}

#define ERROR -1

ElementType Delete(MaxHeap H)   //从最大堆H中取出键值为最大的元素，并删除一个结点
{
    if(IsEmpty(H))
    {
        printf(&quot;The heap is empty!\n&quot;);
        return ERROR;
    }
    ElementType MaxItem = H-&gt;Data[1];  //取出根结点存放的最大值
    //用最大堆中最后一个元素从根结点开始向上过滤下层结点
    ElementType X = H-&gt;Data[H-&gt;Size--];  //注意当前堆的规模要减小
    int Parent, Child;
    for(Parent=1; Parent*2&lt;=H-&gt;Size; Parent=Child)
    {
        Child = Parent*2;
        if((Child!=H-&gt;Size)&amp;&amp;(H-&gt;Data[Child]&lt;H-&gt;Data[Child+1]))
            Child++;      //Child指向左右子结点的较大者
        if(X &gt; H-&gt;Data[Child])    //找到了合适位置
            break;
        else
            H-&gt;Data[Parent] = H-&gt;Data[Child]; //下滤X
    }
    H-&gt;Data[Parent] = X;
    return MaxItem;
}

int main()
{
    int MaxSize = 100;
    MaxHeap H = CreateHeap(MaxSize);
    Insert(H,97);
    Insert(H,76);
    Insert(H,65);
    Insert(H,50);
    Insert(H,49);
    Insert(H,13);
    Insert(H,27);
    Insert(H,83);
    for(int i=1; i&lt;=H-&gt;Size;i++)
        printf(&quot;%d &quot;,H-&gt;Data[i]);
    printf(&quot;\n&quot;);
    Delete(H);
    for(int i=1; i&lt;=H-&gt;Size;i++)
        printf(&quot;%d &quot;,H-&gt;Data[i]);
    printf(&quot;\n&quot;);
    Delete(H);
    for(int i=1; i&lt;=H-&gt;Size;i++)
        printf(&quot;%d &quot;,H-&gt;Data[i]);
    return 0;
}

</code></pre>
<pre><code>97 83 65 76 49 13 27 50
83 76 65 50 49 13 27
76 50 65 27 49 13
</code></pre>
<p>有个堆其元素在数组中的序列为：58，25，44，18，10，26，20，12。如果调用DeleteMax函数删除最大值元素，请猜猜看：程序中的for循环刚退出时变量parent的值是多少？6</p>
<h2 id="最小堆"><a class="header" href="#最小堆">最小堆</a></h2>
<p>对由同样的n个整数构成的二叉搜索树（查找树）和最小堆，下面说法中D是 <strong>不正确</strong> 的:</p>
<p>A.二叉搜索树（查找树）高度大于等于最小堆高度</p>
<p>B.对该二叉搜索树（查找树）进行中序遍历可得到从小到大的序列</p>
<p>C.从最小堆根节点到其任何叶结点的路径上的结点值构成从小到大的序列</p>
<p>D.对该最小堆进行按层序（level order）遍历可得到从小到大的序列</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

#define ERROR -1

typedef int ElementType;
typedef struct HNode *Heap;
typedef Heap MaxHeap;
typedef Heap MinHeap;

struct HNode
{
    ElementType *Data;
    int Size;
    int Capacity;
};

MinHeap CreateHeap(int MaxSize)
{
    MinHeap H = (MinHeap)malloc(sizeof(struct HNode));
    H-&gt;Data = (ElementType*)malloc(sizeof(ElementType)*MaxSize);
    H-&gt;Size = 0;
    H-&gt;Capacity = MaxSize;
    H-&gt;Data[0] = -100;
    return H;
}

bool IsFull(MinHeap H)
{
    return (H-&gt;Size == H-&gt;Capacity);
}

bool Insert(MinHeap H, ElementType X)
{
    if(IsFull(H))
    {
        printf(&quot;The heap is full!\n&quot;);
        return false;
    }
    int i = ++H-&gt;Size;
    for(; H-&gt;Data[i/2] &gt;= X; i /= 2)
    {
        H-&gt;Data[i] = H-&gt;Data[i/2];
    }
    H-&gt;Data[i] = X;
    return true;
}



bool IsEmpty(MinHeap H)
{
    return (H-&gt;Size == 0);
}



ElementType Delete(MinHeap H)
{
    if(IsEmpty(H))
    {
        printf(&quot;The heap is empty!\n&quot;);
        return ERROR;
    }
    int Parent, Child;
    ElementType MinItem,X;
    MinItem = H-&gt;Data[1];
    X = H-&gt;Data[H-&gt;Size--];
    for(Parent = 1; Parent * 2 &lt;= H-&gt;Size; Parent = Child)
    {
        Child = Parent * 2;
        if((Child!=H-&gt;Size)&amp;&amp;(H-&gt;Data[Child] &gt; H-&gt;Data[Child + 1]))
            Child++;
        if(X &lt; H-&gt;Data[Child])
            break;
        else
            H-&gt;Data[Parent] = H-&gt;Data[Child];
    }
    H-&gt;Data[Parent] = X;
    return MinItem;
}

int main()
{
    int MaxSize = 100;
    MinHeap H = CreateHeap(MaxSize);
    Insert(H,97);
    Insert(H,76);
    Insert(H,65);
    Insert(H,50);
    Insert(H,49);
    Insert(H,13);
    Insert(H,27);
    Insert(H,83);
    for(int i=1; i&lt;=H-&gt;Size;i++)
        printf(&quot;%d &quot;,H-&gt;Data[i]);
    printf(&quot;\n&quot;);
    Delete(H);
    for(int i=1; i&lt;=H-&gt;Size;i++)
        printf(&quot;%d &quot;,H-&gt;Data[i]);
    printf(&quot;\n&quot;);
    Delete(H);
    for(int i=1; i&lt;=H-&gt;Size;i++)
        printf(&quot;%d &quot;,H-&gt;Data[i]);
    return 0;
}
</code></pre>
<pre><code>13 50 27 83 65 76 49 97
27 50 49 83 65 76 97
49 50 76 83 65 97
</code></pre>
<h2 id="实例-pta-05-树7-堆中的路径"><a class="header" href="#实例-pta-05-树7-堆中的路径">实例 PTA 05-树7 堆中的路径</a></h2>
<p>将一系列给定数字依次插入一个初始为空的小顶堆<code>H[]</code>。随后对任意给定的下标<code>i</code>，打印从<code>H[i]</code>到根结点的路径。</p>
<p>输入格式:</p>
<p>每组测试第1行包含2个正整数N和M(≤1000)，分别是插入元素的个数、以及需要打印的路径条数。下一行给出区间<code>[-10000, 10000]</code>内的N个要被插入一个初始为空的小顶堆的整数。最后一行给出M个下标。</p>
<p>输出格式:</p>
<p>对输入中给出的每个下标<code>i</code>，在一行中输出从<code>H[i]</code>到根结点的路径上的数据。数字间以1个空格分隔，行末不得有多余空格。</p>
<p>输入样例:</p>
<pre><code>5 3
46 23 26 24 10
5 4 3
</code></pre>
<p>输出样例:</p>
<pre><code>24 23 10
46 23 10
26 10
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312171628565.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

#define ERROR -1

typedef int ElementType;
typedef struct HNode *Heap;
typedef Heap MaxHeap;
typedef Heap MinHeap;

struct HNode
{
    ElementType *Data;
    int Size;
    int Capacity;
};

MinHeap CreateHeap(int MaxSize)
{
    MinHeap H = (MinHeap)malloc(sizeof(struct HNode));
    H-&gt;Data = (ElementType*)malloc(sizeof(ElementType)*MaxSize);
    H-&gt;Size = 0;
    H-&gt;Capacity = MaxSize;
    H-&gt;Data[0] = -10001;
    return H;
}

bool IsFull(MinHeap H)
{
    return (H-&gt;Size == H-&gt;Capacity);
}

bool Insert(MinHeap H, ElementType X)
{
    if(IsFull(H))
    {
        printf(&quot;The heap is full!\n&quot;);
        return false;
    }
    int i = ++H-&gt;Size;
    for(; H-&gt;Data[i/2] &gt;= X; i /= 2)
    {
        H-&gt;Data[i] = H-&gt;Data[i/2];
    }
    H-&gt;Data[i] = X;
    return true;
}



bool IsEmpty(MinHeap H)
{
    return (H-&gt;Size == 0);
}



ElementType Delete(MinHeap H)
{
    if(IsEmpty(H))
    {
        printf(&quot;The heap is empty!\n&quot;);
        return ERROR;
    }
    int Parent, Child;
    ElementType MinItem,X;
    MinItem = H-&gt;Data[1];
    X = H-&gt;Data[H-&gt;Size--];
    for(Parent = 1; Parent * 2 &lt;= H-&gt;Size; Parent = Child)
    {
        Child = Parent * 2;
        if((Child!=H-&gt;Size)&amp;&amp;(H-&gt;Data[Child] &gt; H-&gt;Data[Child + 1]))
            Child++;
        if(X &lt; H-&gt;Data[Child])
            break;
        else
            H-&gt;Data[Parent] = H-&gt;Data[Child];
    }
    H-&gt;Data[Parent] = X;
    return MinItem;
}

int main()
{
    int MaxSize = 1001;
    MinHeap H = CreateHeap(MaxSize);
    int N,M;
    scanf(&quot;%d %d&quot;,&amp;N,&amp;M);
    for(int i=0; i&lt;N; i++)
    {
        int num;
        scanf(&quot;%d&quot;,&amp;num);
        Insert(H,num);
    }
    for(int i=0; i&lt;M; i++)
    {
        int idx;
        scanf(&quot;%d&quot;,&amp;idx);
        int Fisrt = 1;
        for(int j=idx; j&gt;=1; j/=2)
        {
            if(Fisrt)
            {
                printf(&quot;%d&quot;,H-&gt;Data[j]);
                Fisrt = 0;
            }
            else
            {
                printf(&quot; %d&quot;,H-&gt;Data[j]);
            }
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="哈夫曼树"><a class="header" href="#哈夫曼树">哈夫曼树</a></h1>
<ul>
<li><a href="%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91.html#%E5%AE%9A%E4%B9%89">定义</a></li>
<li><a href="%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91.html#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81">哈夫曼编码</a></li>
<li><a href="%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91.html#%E5%AE%9E%E4%BE%8Bpta-05-%E6%A0%919-huffman-codes">实例PTA 05-树9 Huffman Codes</a></li>
</ul>
<h2 id="定义-3"><a class="header" href="#定义-3">定义</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311171654836.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311171655899.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311171656737.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311171657186.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311171657329.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311171658700.png" alt="" /></p>
<p>如果哈夫曼树有67个结点，则可知叶结点总数为：34</p>
<h2 id="哈夫曼编码"><a class="header" href="#哈夫曼编码">哈夫曼编码</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311171700923.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311171701864.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311171705110.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311171706973.png" alt="" /></p>
<p>为五个使用频率不同的字符设计哈夫曼编码，下列方案中哪个不可能是哈夫曼编码？A</p>
<ul>
<li>
<p>A.00，100，101，110，111</p>
</li>
<li>
<p>B.000，001，01，10，11</p>
</li>
<li>
<p>C.0000，0001，001，01，1</p>
</li>
<li>
<p>D.000，001，010，011，1</p>
</li>
</ul>
<p>哈夫曼树的节点要么是叶子节点，要么是度为2的节点，不可能出现度为1的节点。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312171608381.png" alt="" /></p>
<p>一段文本中包含对象{a,b,c,d,e}，其出现次数相应为{3,2,4,2,1}，则经过哈夫曼编码后，该文本所占总位数为：27</p>
<p>每次把权值最小的两棵二叉树合并</p>
<p><img src="https://img-blog.csdnimg.cn/20200319165439920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW9fZ29k,size_16,color_FFFFFF,t_70" alt="" /></p>
<h2 id="实例pta-05-树9-huffman-codes"><a class="header" href="#实例pta-05-树9-huffman-codes">实例PTA 05-树9 Huffman Codes</a></h2>
<p>In 1953, David A. Huffman published his paper &quot;A Method for the Construction of Minimum-Redundancy Codes&quot;, and hence printed his name in the history of computer science. As a professor who gives the final exam problem on Huffman codes, I am encountering a big problem: the Huffman codes are NOT unique. For example, given a string &quot;aaaxuaxz&quot;, we can observe that the frequencies of the characters 'a', 'x', 'u' and 'z' are 4, 2, 1 and 1, respectively. We may either encode the symbols as {'a'=0, 'x'=10, 'u'=110, 'z'=111}, or in another way as {'a'=1, 'x'=01, 'u'=001, 'z'=000}, both compress the string into 14 bits. Another set of code can be given as {'a'=0, 'x'=11, 'u'=100, 'z'=101}, but {'a'=0, 'x'=01, 'u'=011, 'z'=001} is NOT correct since &quot;aaaxuaxz&quot; and &quot;aazuaxax&quot; can both be decoded from the code 00001011001001. The students are submitting all kinds of codes, and I need a computer program to help me determine which ones are correct and which ones are not.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line gives an integer N (2≤N≤63), then followed by a line that contains all the N distinct characters and their frequencies in the following format:</p>
<pre><code>c[1] f[1] c[2] f[2] ... c[N] f[N]
</code></pre>
<p>where <code>c[i]</code> is a character chosen from <code>{'0' - '9', 'a' - 'z', 'A' - 'Z', '_'}</code>, and <code>f[i]</code> is the frequency of <code>c[i]</code> and is an integer no more than 1000. The next line gives a positive integer M (≤1000), then followed by M student submissions. Each student submission consists of N lines, each in the format:</p>
<pre><code>c[i] code[i]
</code></pre>
<p>where <code>c[i]</code> is the <code>i</code>-th character and <code>code[i]</code> is an non-empty string of no more than 63 '0's and '1's.</p>
<p>Output Specification:</p>
<p>For each test case, print in each line either &quot;Yes&quot; if the student's submission is correct, or &quot;No&quot; if not.</p>
<p>Note: The optimal solution is not necessarily generated by Huffman algorithm. Any prefix code with code length being optimal is considered correct.</p>
<p>Sample Input:</p>
<pre><code>7
A 1 B 1 C 1 D 3 E 3 F 6 G 6
4
A 00000
B 00001
C 0001
D 001
E 01
F 10
G 11
A 01010
B 01011
C 0100
D 011
E 10
F 11
G 00
A 000
B 001
C 010
D 011
E 100
F 101
G 110
A 00000
B 00001
C 0001
D 001
E 00
F 10
G 11
</code></pre>
<p>Sample Output:</p>
<pre><code>Yes
Yes
No
No
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312121347197.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312121347500.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312121348847.png" alt="" /></p>
<p>最优编码不一定通过Huffman算法得到。给定4个字符及其出现频率：  A:1; B:1; C:2; D:2<br />
下面哪一套不是用Huffman算法得到的正确的编码？</p>
<p>A.A:000; B:001; C:01; D:1</p>
<p>B.A:10; B:11; C:00; D:01</p>
<p>C.A:00; B:10; C:01; D:11</p>
<p>D.A:111; B:001; C:10; D:1</p>
<p>正确答案：C你选对了</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312121349602.png" alt="" /></p>
<p>这道题主要利用哈夫曼编码的两个性质：</p>
<ul>
<li>哈夫曼编码可能不唯一，但是哈夫曼编码的长度是唯一的。字符串编码成01串后的长度实际上就是其以频率为权值所构成的任意一颗哈夫曼树的带权路径长度。</li>
<li>对于任何一个叶子结点，其编号一定不会成为其他任何一个结点编号的前缀—也就是说，题目中给出需要判断的的每个字符的编码，它不会是其他字符编码的前缀。</li>
</ul>
<p>C++实现代码如下：</p>
<pre><code class="language-c">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main(){
    int s = 0, n, m, x, a[100];
    char ch;
    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q; //优先队列
    cin&gt;&gt;n;getchar();
    for(int i = 0; i &lt; n; i++) {
        cin&gt;&gt;ch&gt;&gt;x;
        a[i] = x;
        q.push(x);
    }
    while(q.size() &gt; 1) {
        int x = q.top();
        q.pop();
        int y = q.top();
        q.pop();
        s = s + x + y;
        q.push(x + y);
    }
    cin&gt;&gt;m;
    while(m--) {
        int s1 = 0;
        string str[100];
        for(int i = 0; i &lt; n; i++) {
            cin&gt;&gt;ch&gt;&gt;str[i];
            s1 = s1 + str[i].size() * a[i];
        }
        if(s == s1) {
            bool jdg = true;
            for (int i = 0; i &lt; n-1; i++) {
                for (int j = i+1; j &lt; n; j++) {
                    int flag = 0;
                    int size = str[i].size() &gt; str[j].size() ? str[j].size() : str[i].size();
                    for(int k = 0; k &lt; size; k++)
                        if(str[i][k] != str[j][k])
                            flag = 1;
                    if (!flag)
                        jdg = false;
                }
            }
            if(jdg)
                cout&lt;&lt;&quot;Yes\n&quot;;
            else
                cout&lt;&lt;&quot;No\n&quot;;
        }
        else
            cout&lt;&lt;&quot;No\n&quot;;
    }
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="并查集"><a class="header" href="#并查集">并查集</a></h1>
<ul>
<li><a href="%E5%B9%B6%E6%9F%A5%E9%9B%86.html#%E9%9B%86%E5%90%88%E8%A1%A8%E7%A4%BA">集合表示</a></li>
<li><a href="%E5%B9%B6%E6%9F%A5%E9%9B%86.html#%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97">集合运算</a></li>
<li><a href="%E5%B9%B6%E6%9F%A5%E9%9B%86.html#%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%AE%9E%E4%BE%8Bpta-05-%E6%A0%918-file-transfer">并查集实例PTA 05-树8 File Transfer</a></li>
</ul>
<h2 id="集合表示"><a class="header" href="#集合表示">集合表示</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202311191703875.png" alt="" /></p>
<p>如果有10台电脑{1，2，3，4，...，9，10}，已知下列电脑之间实现了连接：1和2，2和4，3和5，4和7，5和8，6和9，6和10问：2和7，5和9之间是否可以连通？2和7是连通的，5和9不连通</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202311191704107.png" alt="" /></p>
<h2 id="集合运算"><a class="header" href="#集合运算">集合运算</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202311191705654.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202311191706537.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202311191706299.png" alt="" /></p>
<p>已知a、b两个元素均是所在集合的根结点，且分别位于数组分量3和2位置上，其parent值分别为-3,-2。问：将这两个集合按集合大小合并后，a和b的parent值分别是多少？-5，3</p>
<p>集合的定义与并查操作（已加入按秩归并方法）：</p>
<pre><code class="language-c">#define MAXN 1000                  /* 集合最大元素个数 */
typedef int ElementType;           /* 默认元素可以用非负整数表示 */
typedef int SetName;               /* 默认用根结点的下标作为集合名称 */
typedef ElementType SetType[MAXN]; /* 假设集合元素下标从0开始 */

void Union( SetType S, SetName Root1, SetName Root2 )
{ /* 这里默认Root1和Root2是不同集合的根结点 */
    /* 保证小集合并入大集合 */
    if ( S[Root2] &lt; S[Root1] ) { /* 如果集合2比较大 */
        S[Root2] += S[Root1];     /* 集合1并入集合2  */
        S[Root1] = Root2;
    }
    else {                         /* 如果集合1比较大 */
        S[Root1] += S[Root2];     /* 集合2并入集合1  */
        S[Root2] = Root1;
    }
}

SetName Find( SetType S, ElementType X )
{ /* 默认集合元素全部初始化为-1 */
    if ( S[X] &lt; 0 ) /* 找到集合的根 */
        return X;
    else
        return S[X] = Find( S, S[X] ); /* 路径压缩 */
}
</code></pre>
<h2 id="并查集实例pta-05-树8-file-transfer"><a class="header" href="#并查集实例pta-05-树8-file-transfer">并查集实例PTA 05-树8 File Transfer</a></h2>
<p>We have a network of computers and a list of bi-directional connections. Each of these connections allows a file transfer from one computer to another. Is it possible to send a file from any computer on the network to any other?</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each test case, the first line contains N (2≤N≤104), the total number of computers in a network. Each computer in the network is then represented by a positive integer between 1 and N. Then in the following lines, the input is given in the format:</p>
<pre><code>I c1 c2  
</code></pre>
<p>where <code>I</code> stands for inputting a connection between <code>c1</code> and <code>c2</code>; or</p>
<pre><code>C c1 c2    
</code></pre>
<p>where <code>C</code> stands for checking if it is possible to transfer files between <code>c1</code> and <code>c2</code>; or</p>
<pre><code>S
</code></pre>
<p>where <code>S</code> stands for stopping this case.</p>
<p>Output Specification:</p>
<p>For each <code>C</code> case, print in one line the word &quot;yes&quot; or &quot;no&quot; if it is possible or impossible to transfer files between <code>c1</code> and <code>c2</code>, respectively. At the end of each case, print in one line &quot;The network is connected.&quot; if there is a path between any pair of computers; or &quot;There are <code>k</code> components.&quot; where <code>k</code> is the number of connected components in this network.</p>
<p>Sample Input 1:</p>
<pre><code>5
C 3 2
I 3 2
C 1 5
I 4 5
I 2 4
C 3 5
S
</code></pre>
<p>Sample Output 1:</p>
<pre><code>no
no
yes
There are 2 components.
</code></pre>
<p>Sample Input 2:</p>
<pre><code>5
C 3 2
I 3 2
C 1 5
I 4 5
I 2 4
C 3 5
I 1 3
C 1 5
S
</code></pre>
<p>Sample Output 2:</p>
<pre><code>no
no
yes
yes
The network is connected.
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312111738691.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312111741751.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312111741962.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312111744126.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312111745199.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312111745441.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312111745862.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312111746817.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312111746736.png" alt="" /></p>
<p>这里代码是伪递归形式的，会被编译器优化成循环形式。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312111746575.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

#define MAXN 10001                  /* 集合最大元素个数 */
typedef int ElementType;           /* 默认元素可以用非负整数表示 */
typedef int SetName;               /* 默认用根结点的下标作为集合名称 */
typedef ElementType SetType[MAXN]; /* 假设集合元素下标从0开始 */

void Union( SetType S, SetName Root1, SetName Root2 )
{ /* 这里默认Root1和Root2是不同集合的根结点 */
    /* 保证小集合并入大集合 */
    if ( S[Root2] &lt; S[Root1] ) { /* 如果集合2比较大 */
        S[Root2] += S[Root1];     /* 集合1并入集合2  */
        S[Root1] = Root2;
    }
    else {                         /* 如果集合1比较大 */
        S[Root1] += S[Root2];     /* 集合2并入集合1  */
        S[Root2] = Root1;
    }
}

SetName Find( SetType S, ElementType X )
{ /* 默认集合元素全部初始化为-1 */
    if ( S[X] &lt; 0 ) /* 找到集合的根 */
        return X;
    else
        return S[X] = Find( S, S[X] ); /* 路径压缩 */
}

void Initialization(SetType S, int N)
{
    for(int i=0; i&lt;N; i++)
        S[i] = -1;
}

void Input_connection(SetType S)
{
    ElementType u,v;
    SetName Root1, Root2;
    scanf(&quot;%d %d\n&quot;,&amp;u,&amp;v);
    Root1 = Find(S, u-1);
    Root2 = Find(S, v-1);
    if(Root1 != Root2)
        Union(S, Root1, Root2);
}

void Check_connection(SetType S)
{
    ElementType u,v;
    SetName Root1,Root2;
    scanf(&quot;%d %d\n&quot;,&amp;u,&amp;v);
    Root1 = Find(S, u-1);
    Root2 = Find(S, v-1);
    if(Root1 == Root2)
        printf(&quot;yes\n&quot;);
    else
        printf(&quot;no\n&quot;);
}

void Check_network(SetType S, int n)
{
    int i,counter = 0;
    for(i=0; i&lt;n; i++)
    {
        if(S[i] &lt; 0)
            counter++;
    }
    if(counter == 1)
        printf(&quot;The network is connected.\n&quot;);
    else
        printf(&quot;There are %d components.\n&quot;,counter);
}

int main()
{
    int N;
    scanf(&quot;%d&quot;,&amp;N);
    SetType S;
    char in;
    Initialization(S, N);
    do
    {
        scanf(&quot;%c&quot;,&amp;in);
        switch(in)
        {
        case 'I':
            Input_connection(S);
            break;
        case 'C':
            Check_connection(S);
            break;
        case 'S':
            Check_network(S, N);
            break;
        }
    }while(in != 'S');
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="mooc-pta树题目"><a class="header" href="#mooc-pta树题目">MOOC-PTA树题目</a></h1>
<ul>
<li><a href="MOOC-PTA%E6%A0%91%E9%A2%98%E7%9B%AE.html#pta-03-%E6%A0%911-%E6%A0%91%E7%9A%84%E5%90%8C%E6%9E%84">PTA 03-树1 树的同构</a></li>
<li><a href="MOOC-PTA%E6%A0%91%E9%A2%98%E7%9B%AE.html#pta-03-%E6%A0%912-list-leaves">PTA 03-树2 List Leaves</a></li>
<li><a href="MOOC-PTA%E6%A0%91%E9%A2%98%E7%9B%AE.html#pta-03-%E6%A0%913-tree-traversals-again">PTA 03-树3 Tree Traversals Again</a></li>
<li><a href="MOOC-PTA%E6%A0%91%E9%A2%98%E7%9B%AE.html#pta-04-%E6%A0%914-%E6%98%AF%E5%90%A6%E5%90%8C%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">PTA 04-树4 是否同一棵二叉搜索树</a></li>
<li><a href="MOOC-PTA%E6%A0%91%E9%A2%98%E7%9B%AE.html#pta-04-%E6%A0%915-root-of-avl-tree">PTA 04-树5 Root of AVL Tree</a></li>
<li><a href="MOOC-PTA%E6%A0%91%E9%A2%98%E7%9B%AE.html#pta-04-%E6%A0%916-complete-binary-search-tree">PTA 04-树6 Complete Binary Search Tree</a></li>
<li><a href="MOOC-PTA%E6%A0%91%E9%A2%98%E7%9B%AE.html#pta-04-%E6%A0%917-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C%E9%9B%86">PTA 04-树7 二叉搜索树的操作集</a></li>
<li><a href="MOOC-PTA%E6%A0%91%E9%A2%98%E7%9B%AE.html#pta-05-%E6%A0%917-%E5%A0%86%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84">PTA 05-树7 堆中的路径</a></li>
<li><a href="MOOC-PTA%E6%A0%91%E9%A2%98%E7%9B%AE.html#pta-05-%E6%A0%918-file-transfer">PTA 05-树8 File Transfer</a></li>
<li><a href="MOOC-PTA%E6%A0%91%E9%A2%98%E7%9B%AE.html#pta-05-%E6%A0%919-huffman-codes">PTA 05-树9 Huffman Codes</a></li>
</ul>
<h2 id="pta-03-树1-树的同构"><a class="header" href="#pta-03-树1-树的同构">PTA 03-树1 树的同构</a></h2>
<p>给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。例如图1给出的两棵树就是同构的，因为我们把其中一棵树的结点A、B、G的左右孩子互换后，就得到另外一棵树。而图2就不是同构的。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"><img src="https://images.ptausercontent.com/0c8bbacf-d64e-4c6d-8d4e-1249e33fb0b1.jpg" alt="fig1.jpg" /></th></tr></thead><tbody>
<tr><td style="text-align: center">图1</td></tr>
<tr><td style="text-align: center"><img src="https://images.ptausercontent.com/29" alt="" /></td></tr>
<tr><td style="text-align: center">图2</td></tr>
</tbody></table>
</div>
<p>现给定两棵树，请你判断它们是否是同构的。</p>
<p>输入格式:</p>
<p>输入给出2棵二叉树树的信息。对于每棵树，首先在一行中给出一个非负整数N (≤10)，即该树的结点数（此时假设结点从0到N−1编号）；随后N行，第i行对应编号第i个结点，给出该结点中存储的1个英文大写字母、其左孩子结点的编号、右孩子结点的编号。如果孩子结点为空，则在相应位置上给出“-”。给出的数据间用一个空格分隔。注意：题目保证每个结点中存储的字母是不同的。</p>
<p>输出格式:</p>
<p>如果两棵树是同构的，输出“Yes”，否则输出“No”。</p>
<p>输入样例1（对应图1）：</p>
<pre><code class="language-in">8
A 1 2
B 3 4
C 5 -
D - -
E 6 -
G 7 -
F - -
H - -
8
G - 4
B 7 6
F - -
A 5 1
H - -
C 0 -
D - -
E 2 -
</code></pre>
<p>输出样例1:</p>
<pre><code class="language-out">Yes
</code></pre>
<p>输入样例2（对应图2）：</p>
<pre><code>8
B 5 7
F - -
A 0 3
C 6 -
H - -
D - -
G 4 -
E 1 -
8
D 6 -
B 5 -
E - -
H - -
C 0 2
G - 3
F - -
A 1 4
</code></pre>
<p>输出样例2:</p>
<pre><code>No
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311111547720.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311111558073.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311111601364.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311111602553.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311111602600.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311111603046.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311111603203.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311111604744.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311111605031.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311111606406.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MaxSize 10
#define Null -1
#define ElementType char
#define Tree int

struct TreeNode
{
    ElementType Element;
    Tree Left;
    Tree Right;
}T1[MaxSize],T2[MaxSize];

Tree BuildTree(struct TreeNode T[])
{
    int N;
    int Root = 0;
    scanf(&quot;%d&quot;,&amp;N);
    getchar();
    if(N)
    {
        int check[MaxSize];
        char cl,cr;
        for(int i = 0;i &lt; N;i++)
            check[i] = 0;
        for(int i = 0;i &lt; N;i++)
        {
            scanf(&quot;%c %c %c\n&quot;,&amp;T[i].Element,&amp;cl,&amp;cr);
            if(cl != '-')
            {
                T[i].Left = cl - '0';
                check[T[i].Left] = 1;
            }
            else
                T[i].Left = Null;

            if(cr != '-')
            {
                T[i].Right = cr - '0';
                check[T[i].Right] = 1;
            }
            else
                T[i].Right = Null;
            //getchar();
        }
        for(int i = 0;i &lt; N;i++)
            if(!check[i])
            {
                Root = i;
                break;
            }
    }
    else
        return Null;
    return Root;
}

int Isomorphic(Tree R1,Tree R2)
{
    if(R1 == Null &amp;&amp; R2 == Null)
        return 1;
    if((R1 != Null &amp;&amp; R2 == Null)||(R1 == Null &amp;&amp; R2 != Null))
        return 0;
    if(T1[R1].Element != T2[R2].Element)
        return 0;
    if((T1[R1].Left == Null)&amp;&amp;T2[R2].Left == Null)
        Isomorphic(T1[R1].Right,T2[R2].Right);
    if((T1[R1].Left != Null)&amp;&amp;T2[R2].Left != Null &amp;&amp; (T1[T1[R1].Left].Element) == (T2[T2[R2].Left].Element))
        return Isomorphic(T1[R1].Right,T2[R2].Right) &amp;&amp; Isomorphic(T1[R1].Left,T2[R2].Left);
    else
        Isomorphic(T1[R1].Left,T2[R2].Right) &amp;&amp; Isomorphic(T1[R1].Right,T2[R2].Left);
}


int main()
{
    Tree R1,R2;
    R1 = BuildTree(T1);
    R2 = BuildTree(T2);

    if(Isomorphic(R1,R2))
        printf(&quot;Yes\n&quot;);
    else
        printf(&quot;No\n&quot;);
    return 0;
}
</code></pre>
<h2 id="pta-03-树2-list-leaves"><a class="header" href="#pta-03-树2-list-leaves">PTA 03-树2 List Leaves</a></h2>
<p>Given a tree, you are supposed to list all the leaves in the order of top down, and left to right.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤10) which is the total number of nodes in the tree -- and hence the nodes are numbered from 0 to N−1. Then N lines follow, each corresponds to a node, and gives the indices of the left and right children of the node. If the child does not exist, a &quot;-&quot; will be put at the position. Any pair of children are separated by a space.</p>
<p>Output Specification:</p>
<p>For each test case, print in one line all the leaves' indices in the order of top down, and left to right. There must be exactly one space between any adjacent numbers, and no extra space at the end of the line.</p>
<p>Sample Input:</p>
<pre><code>8
1 -
- -
0 -
2 7
- -
- -
5 -
4 6
</code></pre>
<p>Sample Output:</p>
<pre><code>4 1 5
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MAXTREE 10
typedef int Tree;
#define Null -1
struct TreeNode
{
    Tree id;
    Tree left;
    Tree right;
}T[MAXTREE];

Tree BuildTree(struct TreeNode T[])
{
    for(int i=0; i&lt;MAXTREE; i++)
        T[i].left = T[i].right = 0;
    int N;
    scanf(&quot;%d&quot;,&amp;N);
    getchar();
    int check[MAXTREE];
    for(int i=0; i&lt;N; i++)
        check[i] = 0;
    char cl,cr;
    for(int i=0; i&lt;N; i++)
    {
        T[i].id = i;
        scanf(&quot;%c %c\n&quot;,&amp;cl,&amp;cr);
        if(cl != '-')
        {
            T[i].left = cl - '0';
            check[T[i].left] = 1;
        }
        else
            T[i].left = Null;
        if(cr != '-')
        {
            T[i].right = cr - '0';
            check[T[i].right] = 1;
        }
        else
            T[i].right = Null;
    }
    Tree root;
    for(int i=0; i&lt;N; i++)
    {
        if(check[i] == 0)
        {
            root = i;
            break;
        }
    }
    return root;
}

void Traversal(struct TreeNode T[], Tree root)
{
    Tree pMove = root;
    Tree queue[MAXTREE];
    int front = 0;
    int rear = 0;
    queue[rear++] = pMove;
    int IsFirst = 1;
    while(front != rear)
    {
        pMove = queue[front++];
        if(T[pMove].left == Null &amp;&amp; T[pMove].right == Null)
        {
            if(IsFirst)
            {
                printf(&quot;%d&quot;,T[pMove].id);
                IsFirst = 0;
            }
            else
                printf(&quot; %d&quot;,T[pMove].id);
        }
        if(T[pMove].left != Null)
        {
            queue[rear++] = T[pMove].left;
        }
        if(T[pMove].right != Null)
        {
            queue[rear++] = T[pMove].right;
        }
    }
}

int main()
{
    struct TreeNode T[MAXTREE];
    Tree root = BuildTree(T);
    Traversal(T, root);
    return 0;
}
</code></pre>
<p>核心要点：</p>
<ul>
<li>静态链表存储</li>
<li>读入数据创建相应的树，并找到相应的根节点</li>
<li>改造层次遍历</li>
</ul>
<h2 id="pta-03-树3-tree-traversals-again"><a class="header" href="#pta-03-树3-tree-traversals-again">PTA 03-树3 Tree Traversals Again</a></h2>
<p>An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary tree (with the keys numbered from 1 to 6) is traversed, the stack operations are: push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop(). Then a unique binary tree (shown in Figure 1) can be generated from this sequence of operations. Your task is to give the postorder traversal sequence of this tree.</p>
<p><img src="https://images.ptausercontent.com/30" alt="" /></p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line contains a positive integer N (≤30) which is the total number of nodes in a tree (and hence the nodes are numbered from 1 to N). Then 2N lines follow, each describes a stack operation in the format: &quot;Push X&quot; where X is the index of the node being pushed onto the stack; or &quot;Pop&quot; meaning to pop one node from the stack.</p>
<p>Output Specification:</p>
<p>For each test case, print the postorder traversal sequence of the corresponding tree in one line. A solution is guaranteed to exist. All the numbers must be separated by exactly one space, and there must be no extra space at the end of the line.</p>
<p>Sample Input:</p>
<pre><code>6
Push 1
Push 2
Push 3
Pop
Pop
Push 4
Pop
Pop
Push 5
Push 6
Pop
Pop
</code></pre>
<p>Sample Output:</p>
<pre><code>3 4 2 6 5 1
</code></pre>
<p>在这一道题里面，把树的三种遍历——前序遍历、中序遍历和后序遍历全部都包括了，而且最重要的是，你根本就不需要建一棵树。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202311241638330.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202311241643200.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#define MAXSIZE 30

int pre[MAXSIZE];
int in[MAXSIZE];
int post[MAXSIZE];

void Solve(int preIndex, int inIndex, int postIndex, int N)
{
    if(N == 0)
        return;
    if(N == 1)
    {
        post[postIndex] = pre[preIndex];
        return;
    }
    int root = pre[preIndex];
    post[postIndex+N-1] = root;
    int L,R,i;
    for(i=0; i&lt;N; i++)
    {
        if(in[inIndex+i] == root)
            break;
    }
    L = i;
    R = N - L -1;
    Solve(preIndex+1, inIndex, postIndex, L);
    Solve(preIndex+1+L, inIndex+L+1, postIndex+L, R);
}


int main()
{
    int N;
    scanf(&quot;%d&quot;, &amp;N);
    for(int i=0; i&lt;N; i++)
    {
        pre[i] = 0;
        in[i] = 0;
        post[i] = 0;
    }
    int preIndex = 0, inIndex = 0, postIndex = 0;
    int stack[6];
    int count = 0;
    for(int i=0; i&lt;N*2; i++)
    {
        char str[5];
        scanf(&quot;%s&quot;,str);
        if(strcmp(str,&quot;Push&quot;) == 0)
        {
            int num;
            scanf(&quot;%d\n&quot;,&amp;num);
            count++;
            stack[count] = num;
            pre[preIndex] = num;
            preIndex++;
        }
        else if(strcmp(str,&quot;Pop&quot;) == 0)
        {
            in[inIndex] = stack[count];
            count--;
            inIndex++;
        }
    }
    Solve(0, 0, 0, N);
    int First = 1;
    for(int i=0; i&lt;N; i++)
    {
        if(First)
        {
            printf(&quot;%d&quot;, post[i]);
            First = 0;
        }
        else
            printf(&quot; %d&quot;, post[i]);
    }
    return 0;

}
</code></pre>
<p>核心要点：</p>
<ul>
<li>读入字符串并比较</li>
<li>使用栈获得中序遍历相应数组</li>
<li>分治算法</li>
<li>递归结束条件要有n=0</li>
</ul>
<h2 id="pta-04-树4-是否同一棵二叉搜索树"><a class="header" href="#pta-04-树4-是否同一棵二叉搜索树">PTA 04-树4 是否同一棵二叉搜索树</a></h2>
<p>给定一个插入序列就可以唯一确定一棵二叉搜索树。然而，一棵给定的二叉搜索树却可以由多种不同的插入序列得到。例如分别按照序列{2, 1, 3}和{2, 3, 1}插入初始为空的二叉搜索树，都得到一样的结果。于是对于输入的各种插入序列，你需要判断它们是否能生成一样的二叉搜索树。</p>
<p>输入格式:</p>
<p>输入包含若干组测试数据。每组数据的第1行给出两个正整数N (≤10)和L，分别是每个序列插入元素的个数和需要检查的序列个数。第2行给出N个以空格分隔的正整数，作为初始插入序列。随后L行，每行给出N个插入的元素，属于L个需要检查的序列。</p>
<p>简单起见，我们保证每个插入序列都是1到N的一个排列。当读到N为0时，标志输入结束，这组数据不要处理。</p>
<p>输出格式:</p>
<p>对每一组需要检查的序列，如果其生成的二叉搜索树跟对应的初始序列生成的一样，输出“Yes”，否则输出“No”。</p>
<p>输入样例:</p>
<pre><code>4 2
3 1 4 2
3 4 1 2
3 2 4 1
2 1
2 1
1 2
0
</code></pre>
<p>输出样例:</p>
<pre><code>Yes
No
No
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311131726598.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311131738971.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311131738219.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311131739116.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311131739308.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311131740680.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311131740869.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311131741632.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311131741165.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311131741153.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202311131742656.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef int ElementType;
typedef struct TreeNode *Tree;

struct TreeNode
{
    ElementType Data;
    Tree Left;
    Tree Right;
    int flag;
};

Tree NewNode(ElementType v)
{
    Tree T = (Tree)malloc(sizeof(struct TreeNode));
    T-&gt;Data = v;
    T-&gt;Left = NULL;
    T-&gt;Right = NULL;
    T-&gt;flag = 0;
    return T;
}

Tree Insert(Tree T,ElementType v)
{
    if(!T)
        T = NewNode(v);
    else
    {
        if(T-&gt;Data &lt; v)
            T-&gt;Right = Insert(T-&gt;Right,v);
        else
            T-&gt;Left = Insert(T-&gt;Left,v);
    }
    return T;


}

Tree MakeTree(int N)
{
    Tree T;
    int i,v;
    scanf(&quot;%d&quot;,&amp;v);
    T = NewNode(v);
    for(i = 1;i &lt; N;i++)
    {
        scanf(&quot;%d&quot;,&amp;v);
        T = Insert(T,v);
    }
    return T;
}

void ResetT(Tree T)
{
    if(T-&gt;Left)
        ResetT(T-&gt;Left);
    if(T-&gt;Right)
        ResetT(T-&gt;Right);
    T-&gt;flag = 0;
}

void FreeTree(Tree T)
{
    if(T-&gt;Left)
        FreeTree(T-&gt;Left);
    if(T-&gt;Right)
        FreeTree(T-&gt;Right);
    free(T);
}

int check(Tree T, ElementType v)
{
    if(T-&gt;flag)
    {
        if(v &gt; T-&gt;Data)
            return check(T-&gt;Right, v);
        else if(v &lt; T-&gt;Data)
            return check(T-&gt;Left,v);
        else
            return 0;
    }
    else
    {
        if(v == T-&gt;Data)
        {
            T-&gt;flag = 1;
            return 1;
        }
        else
            return 0;
    }
}

int Judge(Tree T, int N)
{
    int i, V, flag = 0;
    scanf(&quot;%d&quot;,&amp;V);
    if(T-&gt;Data != V)
        flag = 1;
    else
        T-&gt;flag = 1;
    for(i = 1;i &lt; N;i++)
    {
        scanf(&quot;%d&quot;,&amp;V);
        if((!flag)&amp;&amp;(!check(T,V)))
            flag = 1;
    }
    if(flag)
        return 0;
    else
        return 1;
}

int main()
{
    int N,L,i;
    Tree T;
    scanf(&quot;%d&quot;,&amp;N);
    while(N != 0)
    {
        scanf(&quot;%d&quot;,&amp;L);
        T = MakeTree(N);
        for(i = 0;i &lt; L;i++)
        {
            if(Judge(T,N))
                printf(&quot;Yes\n&quot;);
            else
                printf(&quot;No\n&quot;);
            ResetT(T);
        }
        FreeTree(T);
        scanf(&quot;%d&quot;,&amp;N);
    }
    return 0;
}
</code></pre>
<h2 id="pta-04-树5-root-of-avl-tree"><a class="header" href="#pta-04-树5-root-of-avl-tree">PTA 04-树5 Root of AVL Tree</a></h2>
<p>An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules.</p>
<p><img src="https://images.ptausercontent.com/d265ae37-4348-4585-b39f-0b2e2e0a24f5.jpg" alt="F1.jpg" /></p>
<p><img src="https://images.ptausercontent.com/4a9f6fbd-e21e-4493-834d-7782e13bee4e.jpg" alt="F2.jpg" /></p>
<p><img src="https://images.ptausercontent.com/7dc0e66f-c458-4c92-bb8e-55b7bf6391ce.jpg" alt="F3.jpg" /></p>
<p><img src="https://images.ptausercontent.com/b17a9687-6be8-4256-873d-6a747154a58d.jpg" alt="F4.jpg" /></p>
<p>Now given a sequence of insertions, you are supposed to tell the root of the resulting AVL tree.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line contains a positive integer N (≤20) which is the total number of keys to be inserted. Then N distinct integer keys are given in the next line. All the numbers in a line are separated by a space.</p>
<p>Output Specification:</p>
<p>For each test case, print the root of the resulting AVL tree in one line.</p>
<p>Sample Input 1:</p>
<pre><code class="language-in">5
88 70 61 96 120
</code></pre>
<p>Sample Output 1:</p>
<pre><code class="language-out">70
</code></pre>
<p>Sample Input 2:</p>
<pre><code>7
88 70 61 96 120 90 65
</code></pre>
<p>Sample Output 2:</p>
<pre><code>88
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;


typedef int ElementType;
typedef struct AVLNode *Position;
typedef Position AVLTree; /* AVL树类型 */
struct AVLNode{
    ElementType Data; /* 结点数据 */
    AVLTree Left;     /* 指向左子树 */
    AVLTree Right;    /* 指向右子树 */
    int Height;       /* 树高 */
};

int Max ( int a, int b )
{
    return a &gt; b ? a : b;
}

int GetHeight(AVLTree T)
{
	if (!T)
		return -1;
	else
		return T-&gt;Height;
}


AVLTree SingleLeftRotation ( AVLTree A )
{ /* 注意：A必须有一个左子结点B */
  /* 将A与B做左单旋，更新A与B的高度，返回新的根结点B */

    AVLTree B = A-&gt;Left;
    A-&gt;Left = B-&gt;Right;
    B-&gt;Right = A;
    A-&gt;Height = Max( GetHeight(A-&gt;Left), GetHeight(A-&gt;Right) ) + 1;
    B-&gt;Height = Max( GetHeight(B-&gt;Left), A-&gt;Height ) + 1;

    return B;
}

AVLTree SingleRightRotation(AVLTree A)//麻烦结点存在右子树的右边
{
	AVLTree B=A-&gt;Right;
	A-&gt;Right=B-&gt;Left;//右子树的左儿子赋给A的右子树
	B-&gt;Left=A;//B变成A的父结点
	A-&gt;Height=Max(GetHeight(A-&gt;Left),GetHeight(A-&gt;Right))+1;
	B-&gt;Height=Max(A-&gt;Height,GetHeight(B-&gt;Right))+1;
	return B;
}


AVLTree DoubleRightLeftRotation(AVLTree A)//麻烦结点存在右子树的左边
{
	A-&gt;Right=SingleLeftRotation(A-&gt;Right);
	return SingleRightRotation(A);
}

AVLTree DoubleLeftRightRotation ( AVLTree A )
{ /* 注意：A必须有一个左子结点B，且B必须有一个右子结点C */
  /* 将A、B与C做两次单旋，返回新的根结点C */

    /* 将B与C做右单旋，C被返回 */
    A-&gt;Left = SingleRightRotation(A-&gt;Left);
    /* 将A与C做左单旋，C被返回 */
    return SingleLeftRotation(A);
}


AVLTree Insert( AVLTree T, ElementType X )
{ /* 将X插入AVL树T中，并且返回调整后的AVL树 */
    if ( !T ) { /* 若插入空树，则新建包含一个结点的树 */
        T = (AVLTree)malloc(sizeof(struct AVLNode));
        T-&gt;Data = X;
        T-&gt;Height = 0;
        T-&gt;Left = T-&gt;Right = NULL;
    } /* if (插入空树) 结束 */

    else if ( X &lt; T-&gt;Data ) {
        /* 插入T的左子树 */
        T-&gt;Left = Insert( T-&gt;Left, X);
        /* 如果需要左旋 */
        if ( GetHeight(T-&gt;Left)-GetHeight(T-&gt;Right) == 2 )
            if ( X &lt; T-&gt;Left-&gt;Data )
               T = SingleLeftRotation(T);      /* 左单旋 */
            else
               T = DoubleLeftRightRotation(T); /* 左-右双旋 */
    } /* else if (插入左子树) 结束 */

    else if ( X &gt; T-&gt;Data ) {
        /* 插入T的右子树 */
        T-&gt;Right = Insert( T-&gt;Right, X );
        /* 如果需要右旋 */
        if ( GetHeight(T-&gt;Left)-GetHeight(T-&gt;Right) == -2 )
            if ( X &gt; T-&gt;Right-&gt;Data )
               T = SingleRightRotation(T);     /* 右单旋 */
            else
               T = DoubleRightLeftRotation(T); /* 右-左双旋 */
    } /* else if (插入右子树) 结束 */

    /* else X == T-&gt;Data，无须插入 */

    /* 别忘了更新树高 */
    T-&gt;Height = Max( GetHeight(T-&gt;Left), GetHeight(T-&gt;Right) ) + 1;

    return T;
}

int main()
{
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    ElementType X;
    AVLTree T = NULL;
    for(int i=0; i&lt;n; i++)
    {
        scanf(&quot;%d&quot;, &amp;X);
        T = Insert(T,X);
    }
    if(T)
        printf(&quot;%d&quot;,T-&gt;Data);
    return 0;
}
</code></pre>
<h2 id="pta-04-树6-complete-binary-search-tree"><a class="header" href="#pta-04-树6-complete-binary-search-tree">PTA 04-树6 Complete Binary Search Tree</a></h2>
<p>A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys less than the node's key.</li>
<li>The right subtree of a node contains only nodes with keys greater than or equal to the node's key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p>A Complete Binary Tree (CBT) is a tree that is completely filled, with the possible exception of the bottom level, which is filled from left to right.</p>
<p>Now given a sequence of distinct non-negative integer keys, a unique BST can be constructed if it is required that the tree must also be a CBT. You are supposed to output the level order traversal sequence of this BST.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line contains a positive integer N (≤1000). Then N distinct non-negative integer keys are given in the next line. All the numbers in a line are separated by a space and are no greater than 2000.</p>
<p>Output Specification:</p>
<p>For each test case, print in one line the level order traversal sequence of the corresponding complete binary search tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.</p>
<p>Sample Input:</p>
<pre><code>10
1 2 3 4 5 6 7 8 9 0
</code></pre>
<p>Sample Output:</p>
<pre><code>6 3 8 1 5 7 9 0 2 4
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312121531437.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312121532669.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312121532742.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312121532200.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312121533450.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312121533063.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

int Nodes[1005] = {0};
int T[1005] = {0};

int compare(const void * a, const void * b)
{
     return *(int *)a - *(int *)b;
}

int GetLeftLength(int N)
{
    int L;
    int H = (int)(log(N+1)/log(2));
    int X = (N+1-pow(2,H));
    X = X&lt;pow(2,H-1)?X:pow(2,H-1);
    L = pow(2,H-1) - 1 + X;
    return L;
}

void solve(int ALeft, int ARight, int TRoot)
{
    int n = ARight - ALeft + 1;
    if(n==0)
        return;
    int L = GetLeftLength(n);
    T[TRoot] = Nodes[ALeft+L];
    int LeftRoot = TRoot * 2 + 1;
    int RightRoot = TRoot * 2 + 2;
    solve(ALeft, ALeft+L-1, LeftRoot);
    solve(ALeft+L+1, ARight,RightRoot);
}

int main()
{
    int n;
    scanf(&quot;%d&quot;,&amp;n);

    for(int i=0; i&lt;n; i++)
    {
        scanf(&quot;%d&quot;, &amp;Nodes[i]);
    }
    qsort(Nodes,n,sizeof(int),compare);
    solve(0, n-1, 0);
    int First = 1;
    for(int i=0; i&lt;n; i++)
    {
        if(First)
        {
            printf(&quot;%d&quot;, T[i]);
            First = 0;
        }
        else
        {
            printf(&quot; %d&quot;,T[i]);
        }
    }
    return 0;
}
</code></pre>
<p>柳婼cpp题解：</p>
<p>题目大意：给一串构成树的序列，已知该树是完全二叉搜索树，求它的层序遍历的序列 分析：总得概括来说，已知中序，从根节点开始中序遍历，按中序数组给出的顺序依次将值填入level数组对应的下标中，输出level数组可得层序遍历。 1. 因为二叉搜索树的中序满足：是一组序列的从小到大排列，所以只需将所给序列排序即可得到中序数组in 2. 假设把树按从左到右、从上到下的顺序依次编号，根节点为0，则从根结点root = 0开始中序遍历，root结点的左孩子下标是root_2+1，右孩子下标是root_2+2 3. 因为是中序遍历，所以遍历结果与中序数组in中的值从0开始依次递增的结果相同，即<code>in[t++]</code>（t从0开始），将<code>in[t++]</code>赋值给<code>level[root]</code>数组 4. 因为树是按从左到右、从上到下的顺序依次编号的，所以level数组从0到n-1的值即所求的层序遍历的值，输出level数组即可～</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
int in[1010], level[1010], n, t = 0;
void inOrder(int root) {
    if (root &gt;= n) return ;
    inOrder(root * 2 + 1);
    level[root] = in[t++];
    inOrder(root * 2 + 2);
}
int main() {
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 0; i &lt; n; i++)
        scanf(&quot;%d&quot;, &amp;in[i]);
    sort(in, in + n);
    inOrder(0);
    printf(&quot;%d&quot;, level[0]);
    for (int i = 1; i &lt; n; i++)
        printf(&quot; %d&quot;, level[i]);
    return 0;
}
</code></pre>
<h2 id="pta-04-树7-二叉搜索树的操作集"><a class="header" href="#pta-04-树7-二叉搜索树的操作集">PTA 04-树7 二叉搜索树的操作集</a></h2>
<p>本题要求实现给定二叉搜索树的5种常用操作。</p>
<p>函数接口定义：</p>
<pre><code class="language-c">BinTree Insert( BinTree BST, ElementType X );
BinTree Delete( BinTree BST, ElementType X );
Position Find( BinTree BST, ElementType X );
Position FindMin( BinTree BST );
Position FindMax( BinTree BST );
</code></pre>
<p>其中<code>BinTree</code>结构定义如下：</p>
<pre><code class="language-c">typedef struct TNode *Position;
typedef Position BinTree;
struct TNode{
    ElementType Data;
    BinTree Left;
    BinTree Right;
};
</code></pre>
<ul>
<li>函数<code>Insert</code>将<code>X</code>插入二叉搜索树<code>BST</code>并返回结果树的根结点指针；</li>
<li>函数<code>Delete</code>将<code>X</code>从二叉搜索树<code>BST</code>中删除，并返回结果树的根结点指针；如果<code>X</code>不在树中，则打印一行<code>Not Found</code>并返回原树的根结点指针；</li>
<li>函数<code>Find</code>在二叉搜索树<code>BST</code>中找到<code>X</code>，返回该结点的指针；如果找不到则返回空指针；</li>
<li>函数<code>FindMin</code>返回二叉搜索树<code>BST</code>中最小元结点的指针；</li>
<li>函数<code>FindMax</code>返回二叉搜索树<code>BST</code>中最大元结点的指针。</li>
</ul>
<p>裁判测试程序样例：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef int ElementType;
typedef struct TNode *Position;
typedef Position BinTree;
struct TNode{
    ElementType Data;
    BinTree Left;
    BinTree Right;
};

void PreorderTraversal( BinTree BT ); /* 先序遍历，由裁判实现，细节不表 */
void InorderTraversal( BinTree BT );  /* 中序遍历，由裁判实现，细节不表 */

BinTree Insert( BinTree BST, ElementType X );
BinTree Delete( BinTree BST, ElementType X );
Position Find( BinTree BST, ElementType X );
Position FindMin( BinTree BST );
Position FindMax( BinTree BST );

int main()
{
    BinTree BST, MinP, MaxP, Tmp;
    ElementType X;
    int N, i;

    BST = NULL;
    scanf(&quot;%d&quot;, &amp;N);
    for ( i=0; i&lt;N; i++ ) {
        scanf(&quot;%d&quot;, &amp;X);
        BST = Insert(BST, X);
    }
    printf(&quot;Preorder:&quot;); PreorderTraversal(BST); printf(&quot;\n&quot;);
    MinP = FindMin(BST);
    MaxP = FindMax(BST);
    scanf(&quot;%d&quot;, &amp;N);
    for( i=0; i&lt;N; i++ ) {
        scanf(&quot;%d&quot;, &amp;X);
        Tmp = Find(BST, X);
        if (Tmp == NULL) printf(&quot;%d is not found\n&quot;, X);
        else {
            printf(&quot;%d is found\n&quot;, Tmp-&gt;Data);
            if (Tmp==MinP) printf(&quot;%d is the smallest key\n&quot;, Tmp-&gt;Data);
            if (Tmp==MaxP) printf(&quot;%d is the largest key\n&quot;, Tmp-&gt;Data);
        }
    }
    scanf(&quot;%d&quot;, &amp;N);
    for( i=0; i&lt;N; i++ ) {
        scanf(&quot;%d&quot;, &amp;X);
        BST = Delete(BST, X);
    }
    printf(&quot;Inorder:&quot;); InorderTraversal(BST); printf(&quot;\n&quot;);

    return 0;
}
/* 你的代码将被嵌在这里 */
</code></pre>
<p>输入样例：</p>
<pre><code>10
5 8 6 2 4 1 0 10 9 7
5
6 3 10 0 5
5
5 7 0 10 3
</code></pre>
<p>输出样例：</p>
<pre><code>Preorder: 5 2 1 0 4 8 6 7 10 9
6 is found
3 is not found
10 is found
10 is the largest key
0 is found
0 is the smallest key
5 is found
Not Found
Inorder: 1 2 4 6 8 9
</code></pre>
<pre><code class="language-c">BinTree Insert(BinTree BST, ElementType X)
{
    if(!BST)
    {
        /*若原树为空，生成并返回一个结点的二叉搜索树*/
        BST = (BinTree)malloc(sizeof(struct TNode));
        BST-&gt;Data = X;
        BST-&gt;Left = NULL;
        BST-&gt;Right = NULL;
    }
    else   /*开始找要插入元素的位置*/
    {
        if(BST-&gt;Data &lt; X)
            BST-&gt;Right = Insert(BST-&gt;Right, X);
        else if(BST-&gt;Data &gt; X)
            BST-&gt;Left = Insert(BST-&gt;Left, X);
        /*else X已经存在，什么都不做 */
    }
    return BST;
}
BinTree Delete(BinTree BST, ElementType X)
{
    Position Tmp;
    if(!BST)
        printf(&quot;Not Found\n&quot;);
    else if(X &lt; BST-&gt;Data)
        BST-&gt;Left = Delete(BST-&gt;Left,X);
    else if(X &gt; BST-&gt;Data)
        BST-&gt;Right = Delete(BST-&gt;Right,X);
    else
    {
        if(BST-&gt;Left &amp;&amp; BST-&gt;Right)
        {
            Tmp = FindMin(BST-&gt;Right);
            BST-&gt;Data = Tmp-&gt;Data;
            BST-&gt;Right = Delete(BST-&gt;Right,BST-&gt;Data);
        }
        else
        {
            Tmp = BST;
            if(!BST-&gt;Left)
                BST = BST-&gt;Right;
            else if(!BST-&gt;Right)
                BST = BST-&gt;Left;
            free(Tmp);
        }
    }
    return BST;

}
Position Find(BinTree BST,ElementType X)
{
    if(!BST)
        return NULL;
    else
    {
        if(BST-&gt;Data == X)
            return BST; /*查找成功，返回找到结点的地址*/
        else if(BST-&gt;Data &gt; X)
            return Find(BST-&gt;Left, X);
        else
            return Find(BST-&gt;Right, X);
    }
    return NULL;
}


/*迭代、非递归方式*/
Position FindMax(BinTree BST)
{
    if(BST)
        while(BST-&gt;Right)
            BST = BST-&gt;Right;
    return BST;
}

Position FindMin(BinTree BST)
{
    if(!BST)
        return NULL;
    else if(!BST-&gt;Left)  /*有根结点，但没有左子树，直接返回根*/
            return BST;
    else
        return FindMin(BST-&gt;Left);
}
</code></pre>
<h2 id="pta-05-树7-堆中的路径"><a class="header" href="#pta-05-树7-堆中的路径">PTA 05-树7 堆中的路径</a></h2>
<p>将一系列给定数字依次插入一个初始为空的小顶堆<code>H[]</code>。随后对任意给定的下标<code>i</code>，打印从<code>H[i]</code>到根结点的路径。</p>
<p>输入格式:</p>
<p>每组测试第1行包含2个正整数N和M(≤1000)，分别是插入元素的个数、以及需要打印的路径条数。下一行给出区间<code>[-10000, 10000]</code>内的N个要被插入一个初始为空的小顶堆的整数。最后一行给出M个下标。</p>
<p>输出格式:</p>
<p>对输入中给出的每个下标<code>i</code>，在一行中输出从<code>H[i]</code>到根结点的路径上的数据。数字间以1个空格分隔，行末不得有多余空格。</p>
<p>输入样例:</p>
<pre><code>5 3
46 23 26 24 10
5 4 3
</code></pre>
<p>输出样例:</p>
<pre><code>24 23 10
46 23 10
26 10
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

#define ERROR -1

typedef int ElementType;
typedef struct HNode *Heap;
typedef Heap MaxHeap;
typedef Heap MinHeap;

struct HNode
{
    ElementType *Data;
    int Size;
    int Capacity;
};

MinHeap CreateHeap(int MaxSize)
{
    MinHeap H = (MinHeap)malloc(sizeof(struct HNode));
    H-&gt;Data = (ElementType*)malloc(sizeof(ElementType)*MaxSize);
    H-&gt;Size = 0;
    H-&gt;Capacity = MaxSize;
    H-&gt;Data[0] = -10001;
    return H;
}

bool IsFull(MinHeap H)
{
    return (H-&gt;Size == H-&gt;Capacity);
}

bool Insert(MinHeap H, ElementType X)
{
    if(IsFull(H))
    {
        printf(&quot;The heap is full!\n&quot;);
        return false;
    }
    int i = ++H-&gt;Size;
    for(; H-&gt;Data[i/2] &gt;= X; i /= 2)
    {
        H-&gt;Data[i] = H-&gt;Data[i/2];
    }
    H-&gt;Data[i] = X;
    return true;
}



bool IsEmpty(MinHeap H)
{
    return (H-&gt;Size == 0);
}



ElementType Delete(MinHeap H)
{
    if(IsEmpty(H))
    {
        printf(&quot;The heap is empty!\n&quot;);
        return ERROR;
    }
    int Parent, Child;
    ElementType MinItem,X;
    MinItem = H-&gt;Data[1];
    X = H-&gt;Data[H-&gt;Size--];
    for(Parent = 1; Parent * 2 &lt;= H-&gt;Size; Parent = Child)
    {
        Child = Parent * 2;
        if((Child!=H-&gt;Size)&amp;&amp;(H-&gt;Data[Child] &gt; H-&gt;Data[Child + 1]))
            Child++;
        if(X &lt; H-&gt;Data[Child])
            break;
        else
            H-&gt;Data[Parent] = H-&gt;Data[Child];
    }
    H-&gt;Data[Parent] = X;
    return MinItem;
}

int main()
{
    int MaxSize = 1001;
    MinHeap H = CreateHeap(MaxSize);
    int N,M;
    scanf(&quot;%d %d&quot;,&amp;N,&amp;M);
    for(int i=0; i&lt;N; i++)
    {
        int num;
        scanf(&quot;%d&quot;,&amp;num);
        Insert(H,num);
    }
    for(int i=0; i&lt;M; i++)
    {
        int idx;
        scanf(&quot;%d&quot;,&amp;idx);
        int Fisrt = 1;
        for(int j=idx; j&gt;=1; j/=2)
        {
            if(Fisrt)
            {
                printf(&quot;%d&quot;,H-&gt;Data[j]);
                Fisrt = 0;
            }
            else
            {
                printf(&quot; %d&quot;,H-&gt;Data[j]);
            }
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>
<h2 id="pta-05-树8-file-transfer"><a class="header" href="#pta-05-树8-file-transfer">PTA 05-树8 File Transfer</a></h2>
<p>We have a network of computers and a list of bi-directional connections. Each of these connections allows a file transfer from one computer to another. Is it possible to send a file from any computer on the network to any other?</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each test case, the first line contains N (2≤N≤104), the total number of computers in a network. Each computer in the network is then represented by a positive integer between 1 and N. Then in the following lines, the input is given in the format:</p>
<pre><code>I c1 c2  
</code></pre>
<p>where <code>I</code> stands for inputting a connection between <code>c1</code> and <code>c2</code>; or</p>
<pre><code>C c1 c2    
</code></pre>
<p>where <code>C</code> stands for checking if it is possible to transfer files between <code>c1</code> and <code>c2</code>; or</p>
<pre><code>S
</code></pre>
<p>where <code>S</code> stands for stopping this case.</p>
<p>Output Specification:</p>
<p>For each <code>C</code> case, print in one line the word &quot;yes&quot; or &quot;no&quot; if it is possible or impossible to transfer files between <code>c1</code> and <code>c2</code>, respectively. At the end of each case, print in one line &quot;The network is connected.&quot; if there is a path between any pair of computers; or &quot;There are <code>k</code> components.&quot; where <code>k</code> is the number of connected components in this network.</p>
<p>Sample Input 1:</p>
<pre><code>5
C 3 2
I 3 2
C 1 5
I 4 5
I 2 4
C 3 5
S
</code></pre>
<p>Sample Output 1:</p>
<pre><code>no
no
yes
There are 2 components.
</code></pre>
<p>Sample Input 2:</p>
<pre><code>5
C 3 2
I 3 2
C 1 5
I 4 5
I 2 4
C 3 5
I 1 3
C 1 5
S
</code></pre>
<p>Sample Output 2:</p>
<pre><code>no
no
yes
yes
The network is connected.
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312111738691.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312111741751.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312111741962.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312111744126.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312111745199.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312111745441.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312111745862.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312111746817.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312111746736.png" alt="" /></p>
<p>这里代码是伪递归形式的，会被编译器优化成循环形式。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312111746575.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

#define MAXN 10001                  /* 集合最大元素个数 */
typedef int ElementType;           /* 默认元素可以用非负整数表示 */
typedef int SetName;               /* 默认用根结点的下标作为集合名称 */
typedef ElementType SetType[MAXN]; /* 假设集合元素下标从0开始 */

void Union( SetType S, SetName Root1, SetName Root2 )
{ /* 这里默认Root1和Root2是不同集合的根结点 */
    /* 保证小集合并入大集合 */
    if ( S[Root2] &lt; S[Root1] ) { /* 如果集合2比较大 */
        S[Root2] += S[Root1];     /* 集合1并入集合2  */
        S[Root1] = Root2;
    }
    else {                         /* 如果集合1比较大 */
        S[Root1] += S[Root2];     /* 集合2并入集合1  */
        S[Root2] = Root1;
    }
}

SetName Find( SetType S, ElementType X )
{ /* 默认集合元素全部初始化为-1 */
    if ( S[X] &lt; 0 ) /* 找到集合的根 */
        return X;
    else
        return S[X] = Find( S, S[X] ); /* 路径压缩 */
}

void Initialization(SetType S, int N)
{
    for(int i=0; i&lt;N; i++)
        S[i] = -1;
}

void Input_connection(SetType S)
{
    ElementType u,v;
    SetName Root1, Root2;
    scanf(&quot;%d %d\n&quot;,&amp;u,&amp;v);
    Root1 = Find(S, u-1);
    Root2 = Find(S, v-1);
    if(Root1 != Root2)
        Union(S, Root1, Root2);
}

void Check_connection(SetType S)
{
    ElementType u,v;
    SetName Root1,Root2;
    scanf(&quot;%d %d\n&quot;,&amp;u,&amp;v);
    Root1 = Find(S, u-1);
    Root2 = Find(S, v-1);
    if(Root1 == Root2)
        printf(&quot;yes\n&quot;);
    else
        printf(&quot;no\n&quot;);
}

void Check_network(SetType S, int n)
{
    int i,counter = 0;
    for(i=0; i&lt;n; i++)
    {
        if(S[i] &lt; 0)
            counter++;
    }
    if(counter == 1)
        printf(&quot;The network is connected.\n&quot;);
    else
        printf(&quot;There are %d components.\n&quot;,counter);
}

int main()
{
    int N;
    scanf(&quot;%d&quot;,&amp;N);
    SetType S;
    char in;
    Initialization(S, N);
    do
    {
        scanf(&quot;%c&quot;,&amp;in);
        switch(in)
        {
        case 'I':
            Input_connection(S);
            break;
        case 'C':
            Check_connection(S);
            break;
        case 'S':
            Check_network(S, N);
            break;
        }
    }while(in != 'S');
    return 0;
}
</code></pre>
<h2 id="pta-05-树9-huffman-codes"><a class="header" href="#pta-05-树9-huffman-codes">PTA 05-树9 Huffman Codes</a></h2>
<p>In 1953, David A. Huffman published his paper &quot;A Method for the Construction of Minimum-Redundancy Codes&quot;, and hence printed his name in the history of computer science. As a professor who gives the final exam problem on Huffman codes, I am encountering a big problem: the Huffman codes are NOT unique. For example, given a string &quot;aaaxuaxz&quot;, we can observe that the frequencies of the characters 'a', 'x', 'u' and 'z' are 4, 2, 1 and 1, respectively. We may either encode the symbols as {'a'=0, 'x'=10, 'u'=110, 'z'=111}, or in another way as {'a'=1, 'x'=01, 'u'=001, 'z'=000}, both compress the string into 14 bits. Another set of code can be given as {'a'=0, 'x'=11, 'u'=100, 'z'=101}, but {'a'=0, 'x'=01, 'u'=011, 'z'=001} is NOT correct since &quot;aaaxuaxz&quot; and &quot;aazuaxax&quot; can both be decoded from the code 00001011001001. The students are submitting all kinds of codes, and I need a computer program to help me determine which ones are correct and which ones are not.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line gives an integer N (2≤N≤63), then followed by a line that contains all the N distinct characters and their frequencies in the following format:</p>
<pre><code>c[1] f[1] c[2] f[2] ... c[N] f[N]
</code></pre>
<p>where <code>c[i]</code> is a character chosen from <code>{'0' - '9', 'a' - 'z', 'A' - 'Z', '_'}</code>, and <code>f[i]</code> is the frequency of <code>c[i]</code> and is an integer no more than 1000. The next line gives a positive integer M (≤1000), then followed by M student submissions. Each student submission consists of N lines, each in the format:</p>
<pre><code>c[i] code[i]
</code></pre>
<p>where <code>c[i]</code> is the <code>i</code>-th character and <code>code[i]</code> is an non-empty string of no more than 63 '0's and '1's.</p>
<p>Output Specification:</p>
<p>For each test case, print in each line either &quot;Yes&quot; if the student's submission is correct, or &quot;No&quot; if not.</p>
<p>Note: The optimal solution is not necessarily generated by Huffman algorithm. Any prefix code with code length being optimal is considered correct.</p>
<p>Sample Input:</p>
<pre><code>7
A 1 B 1 C 1 D 3 E 3 F 6 G 6
4
A 00000
B 00001
C 0001
D 001
E 01
F 10
G 11
A 01010
B 01011
C 0100
D 011
E 10
F 11
G 00
A 000
B 001
C 010
D 011
E 100
F 101
G 110
A 00000
B 00001
C 0001
D 001
E 00
F 10
G 11
</code></pre>
<p>Sample Output:</p>
<pre><code>Yes
Yes
No
No
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312121347197.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312121347500.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312121348847.png" alt="" /></p>
<p>最优编码不一定通过Huffman算法得到。给定4个字符及其出现频率：  A:1; B:1; C:2; D:2<br />
下面哪一套不是用Huffman算法得到的正确的编码？</p>
<p>A.A:000; B:001; C:01; D:1</p>
<p>B.A:10; B:11; C:00; D:01</p>
<p>C.A:00; B:10; C:01; D:11</p>
<p>D.A:111; B:001; C:10; D:1</p>
<p>正确答案：C你选对了</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312121349602.png" alt="" /></p>
<p>这道题主要利用哈夫曼编码的两个性质：</p>
<ul>
<li>哈夫曼编码可能不唯一，但是哈夫曼编码的长度是唯一的。字符串编码成01串后的长度实际上就是其以频率为权值所构成的任意一颗哈夫曼树的带权路径长度。</li>
<li>对于任何一个叶子结点，其编号一定不会成为其他任何一个结点编号的前缀—也就是说，题目中给出需要判断的的每个字符的编码，它不会是其他字符编码的前缀。</li>
</ul>
<pre><code class="language-c">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

#define ERROR -1

typedef HuffmanTree ElementType;
typedef struct HNode *Heap;
typedef Heap MinHeap;
typedef struct TreeNode* HuffmanTree;

struct TreeNode
{	//A 1 B 1 C 1 D 3 E 3 F 6 G 6
	int Weight;//为什么不记录A B C 只记录频率1 1 1? 因为根据哈夫曼树的特点，待计算WPL的结点都位于叶结点（知道出现频率就可以了）
	HuffmanTree Left;
	HuffmanTree Right;
};

struct HNode
{
    ElementType *Data;
    int Size;
    int Capacity;
};

MinHeap CreateHeap(int MaxSize)
{
    MinHeap H = (MinHeap)malloc(sizeof(struct HNode));
    H-&gt;Data = (ElementType*)malloc(sizeof(ElementType)*MaxSize);
    H-&gt;Size = 0;
    H-&gt;Capacity = MaxSize;
    H-&gt;Data[0] = -10001;
    return H;
}

bool IsFull(MinHeap H)
{
    return (H-&gt;Size == H-&gt;Capacity);
}

bool Insert(MinHeap H, ElementType X)
{
    if(IsFull(H))
    {
        printf(&quot;The heap is full!\n&quot;);
        return false;
    }
    int i = ++H-&gt;Size;
    for(; H-&gt;Data[i/2] &gt;= X; i /= 2)
    {
        H-&gt;Data[i] = H-&gt;Data[i/2];
    }
    H-&gt;Data[i] = X;
    return true;
}

bool IsEmpty(MinHeap H)
{
    return (H-&gt;Size == 0);
}



ElementType Delete(MinHeap H)
{
    if(IsEmpty(H))
    {
        printf(&quot;The heap is empty!\n&quot;);
        return ERROR;
    }
    int Parent, Child;
    ElementType MinItem,X;
    MinItem = H-&gt;Data[1];
    X = H-&gt;Data[H-&gt;Size--];
    for(Parent = 1; Parent * 2 &lt;= H-&gt;Size; Parent = Child)
    {
        Child = Parent * 2;
        if((Child!=H-&gt;Size)&amp;&amp;(H-&gt;Data[Child] &gt; H-&gt;Data[Child + 1]))
            Child++;
        if(X &lt; H-&gt;Data[Child])
            break;
        else
            H-&gt;Data[Parent] = H-&gt;Data[Child];
    }
    H-&gt;Data[Parent] = X;
    return MinItem;
}

MinHeap ReadData(int N)
{
    MinHeap H = CreateHeap(N);
    char Symbol;
    int Weight;
    for(int i=0; i&lt;N; i++)
    {
        scanf(&quot;%c %d&quot;,&amp;Symbol,&amp;Weight);
        HuffmanTree HTree = (HuffmanTree)malloc(sizeof(struct TreeNode));
        HTree-&gt;Weight = Weight;
        HTree-&gt;Left = NULL;
        HTree-&gt;Right = NULL;
    }
}

int WPL(HuffmanTree T, int Depth)
{
	if (!T-&gt;Left &amp;&amp; !T-&gt;Right) //叶结点就是待计算的结点
		return T-&gt;Weight * Depth;
	else
		return WPL(T-&gt;Left, Depth + 1) + WPL(T-&gt;Right, Depth + 1);
}


int main()
{
    int N;
    scanf(&quot;%d&quot;,&amp;N);
    MinHeap H = CreateHeap(N);
    
    H = ReadData(N);
    HuffmanTree T = Huffman(H);
    int CodeLen = WPL(T, 0);
    
    
    int N,M;
    scanf(&quot;%d %d&quot;,&amp;N,&amp;M);
    for(int i=0; i&lt;N; i++)
    {
        int num;
        scanf(&quot;%d&quot;,&amp;num);
        Insert(H,num);
    }
    for(int i=0; i&lt;M; i++)
    {
        int idx;
        scanf(&quot;%d&quot;,&amp;idx);
        int Fisrt = 1;
        for(int j=idx; j&gt;=1; j/=2)
        {
            if(Fisrt)
            {
                printf(&quot;%d&quot;,H-&gt;Data[j]);
                Fisrt = 0;
            }
            else
            {
                printf(&quot; %d&quot;,H-&gt;Data[j]);
            }
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}





</code></pre>
<p>未完待续</p>
<p>C++实现代码如下：</p>
<pre><code class="language-c">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main(){
    int s = 0, n, m, x, a[100];
    char ch;
    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q; //优先队列
    cin&gt;&gt;n;getchar();
    for(int i = 0; i &lt; n; i++) {
        cin&gt;&gt;ch&gt;&gt;x;
        a[i] = x;
        q.push(x);
    }
    while(q.size() &gt; 1) {
        int x = q.top();
        q.pop();
        int y = q.top();
        q.pop();
        s = s + x + y;
        q.push(x + y);
    }
    cin&gt;&gt;m;
    while(m--) {
        int s1 = 0;
        string str[100];
        for(int i = 0; i &lt; n; i++) {
            cin&gt;&gt;ch&gt;&gt;str[i];
            s1 = s1 + str[i].size() * a[i];
        }
        if(s == s1) {
            bool jdg = true;
            for (int i = 0; i &lt; n-1; i++) {
                for (int j = i+1; j &lt; n; j++) {
                    int flag = 0;
                    int size = str[i].size() &gt; str[j].size() ? str[j].size() : str[i].size();
                    for(int k = 0; k &lt; size; k++)
                        if(str[i][k] != str[j][k])
                            flag = 1;
                    if (!flag)
                        jdg = false;
                }
            }
            if(jdg)
                cout&lt;&lt;&quot;Yes\n&quot;;
            else
                cout&lt;&lt;&quot;No\n&quot;;
        }
        else
            cout&lt;&lt;&quot;No\n&quot;;
    }
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="图"><a class="header" href="#图">图</a></h1>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202311301605836.png" alt="" /></p>
<p>多对多的数据结构</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202311301606904.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="图的存储"><a class="header" href="#图的存储">图的存储</a></h1>
<ul>
<li><a href="%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8.html#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5">邻接矩阵</a>
<ul>
<li><a href="%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8.html#%E5%AE%8C%E6%95%B4%E7%89%88%E6%9C%AC%E4%BB%A3%E7%A0%81">完整版本代码</a></li>
<li><a href="%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8.html#%E7%AE%80%E5%8C%96%E7%89%88%E6%9C%AC%E4%BB%A3%E7%A0%81">简化版本代码</a></li>
</ul>
</li>
<li><a href="%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8.html#%E9%82%BB%E6%8E%A5%E8%A1%A8">邻接表</a>
<ul>
<li><a href="%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8.html#%E5%AE%8C%E6%95%B4%E7%89%88%E6%9C%AC%E4%BB%A3%E7%A0%81-1">完整版本代码</a></li>
<li><a href="%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8.html#%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AD%98%E5%82%A8dfs%E9%81%8D%E5%8E%86%E5%AE%9E%E4%BE%8B">邻接表存储、DFS遍历实例</a></li>
</ul>
</li>
<li><a href="%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8.html#%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8">十字链表</a></li>
<li><a href="%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8.html#%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8">邻接多重表</a></li>
</ul>
<h2 id="邻接矩阵"><a class="header" href="#邻接矩阵">邻接矩阵</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202311301606913.png" alt="" /></p>
<p>对于有N个顶点的无向图，怎样存储可以省一半空间？</p>
<p>正确答案：用一个长度为N(N+1)/2的1维数组</p>
<p>用一维数组<code>G[ ]</code>存储有4个顶点的无向图如下：<code>G[ ] = { 0, 1, 0, 1, 1, 0, 0, 0, 1, 0 }</code></p>
<p>则顶点2和顶点0之间是有边的。  ✔</p>
<p>有N个顶点的无向完全图有多少条边？N(N-1)/2</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202311301607069.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202311301607187.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202311301608277.png" alt="" /></p>
<h3 id="完整版本代码"><a class="header" href="#完整版本代码">完整版本代码</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* 图的邻接矩阵表示法 */

#define MaxVertexNum 100    /* 最大顶点数设为100 */
#define INFINITY 65535        /* ∞设为双字节无符号整数的最大值65535*/
typedef int Vertex;         /* 用顶点下标表示顶点,为整型 */
typedef int WeightType;        /* 边的权值设为整型 */
typedef char DataType;        /* 顶点存储的数据类型设为字符型 */

/* 边的定义 */
typedef struct ENode *PtrToENode;
struct ENode{
    Vertex V1, V2;      /* 有向边&lt;V1, V2&gt; */
    WeightType Weight;  /* 权重 */
};
typedef PtrToENode Edge;
       
/* 图结点的定义 */
typedef struct GNode *PtrToGNode;
struct GNode{
    int Nv;  /* 顶点数 */
    int Ne;  /* 边数   */
    WeightType G[MaxVertexNum][MaxVertexNum]; /* 邻接矩阵 */
    DataType Data[MaxVertexNum];      /* 存顶点的数据 */
    /* 注意：很多情况下，顶点无数据，此时Data[]可以不用出现 */
};
typedef PtrToGNode MGraph; /* 以邻接矩阵存储的图类型 */



MGraph CreateGraph( int VertexNum )
{ /* 初始化一个有VertexNum个顶点但没有边的图 */
    Vertex V, W;
    MGraph Graph;
    
    Graph = (MGraph)malloc(sizeof(struct GNode)); /* 建立图 */
    Graph-&gt;Nv = VertexNum;
    Graph-&gt;Ne = 0;
    /* 初始化邻接矩阵 */
    /* 注意：这里默认顶点编号从0开始，到(Graph-&gt;Nv - 1) */
    for (V=0; V&lt;Graph-&gt;Nv; V++)
        for (W=0; W&lt;Graph-&gt;Nv; W++)  
            Graph-&gt;G[V][W] = INFINITY;
            
    return Graph; 
}
       
void InsertEdge( MGraph Graph, Edge E )
{
     /* 插入边 &lt;V1, V2&gt; */
     Graph-&gt;G[E-&gt;V1][E-&gt;V2] = E-&gt;Weight;    
     /* 若是无向图，还要插入边&lt;V2, V1&gt; */
     Graph-&gt;G[E-&gt;V2][E-&gt;V1] = E-&gt;Weight;
}

MGraph BuildGraph()
{
    MGraph Graph;
    Edge E;
    Vertex V;
    int Nv, i;
    
    scanf(&quot;%d&quot;, &amp;Nv);   /* 读入顶点个数 */
    Graph = CreateGraph(Nv); /* 初始化有Nv个顶点但没有边的图 */ 
    
    scanf(&quot;%d&quot;, &amp;(Graph-&gt;Ne));   /* 读入边数 */
    if ( Graph-&gt;Ne != 0 ) { /* 如果有边 */ 
        E = (Edge)malloc(sizeof(struct ENode)); /* 建立边结点 */ 
        /* 读入边，格式为&quot;起点 终点 权重&quot;，插入邻接矩阵 */
        for (i=0; i&lt;Graph-&gt;Ne; i++) {
            scanf(&quot;%d %d %d&quot;, &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight); 
            /* 注意：如果权重不是整型，Weight的读入格式要改 */
            InsertEdge( Graph, E );
        }
    } 

    /* 如果顶点有数据的话，读入数据 */
    for (V=0; V&lt;Graph-&gt;Nv; V++) 
        scanf(&quot; %c&quot;, &amp;(Graph-&gt;Data[V]));

    return Graph;
}
</code></pre>
<h3 id="简化版本代码"><a class="header" href="#简化版本代码">简化版本代码</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MAXN 100

int G[MAXN][MAXN];
int visited[MAXN];
int Ne,Nv;


void InitVisited()
{
    for(int i=0; i&lt;MAXN; i++)
        visited[i] = 0;
}

void BuildGraph()
{
    for(int i=0; i&lt;MAXN; i++)
    {
        for(int j=0; j&lt;MAXN; j++)
        {
            G[i][j] = 0;
        }
    }
    scanf(&quot;%d %d&quot;,&amp;Nv, &amp;Ne);
    if(Ne)
    {
        for(int i=0; i&lt;Ne; i++)
        {
            int v1,v2,weight;
            scanf(&quot;%d %d %d&quot;,&amp;v1,&amp;v2,&amp;weight);
            G[v1][v2] = weight;
            G[v2][v1] = weight;
        }
    }
}

void dfs(int v)
{
    visited[v] = 1;
    printf(&quot;%d &quot;,v);
    for(int i=0; i&lt;Nv; i++)
    {
        if(visited[i]==0 &amp;&amp;G[v][i]!=0)
        {
            dfs(i);
        }
    }
}

int main()
{
    BuildGraph();
    InitVisited();
    dfs(0);
    return 0;
}
</code></pre>
<p>输入数据：</p>
<pre><code>6 7  
0 1 1  
0 2 1  
0 4 1  
1 4 1  
2 5 1  
3 4 1  
3 5 1  
</code></pre>
<p>输出结果：</p>
<pre><code>0 1 4 3 5 2
</code></pre>
<h2 id="邻接表"><a class="header" href="#邻接表">邻接表</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202311301608777.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202311301609554.png" alt="" /></p>
<p>用邻接表表示有N个顶点、E条边的图，则遍历图中所有边的时间复杂度为：O(N+E)</p>
<p>需要N个头指针 + 2E个结点（每个结点至少2个域），则E小于多少是省空间的？</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202311201430423.png" alt="" /></p>
<p>《数据结构》课程给出的图的邻接表表示法如下：</p>
<h3 id="完整版本代码-1"><a class="header" href="#完整版本代码-1">完整版本代码</a></h3>
<pre><code class="language-c">/* 图的邻接表表示法 */

#define MaxVertexNum 100    /* 最大顶点数设为100 */
typedef int Vertex;         /* 用顶点下标表示顶点,为整型 */
typedef int WeightType;        /* 边的权值设为整型 */
typedef char DataType;        /* 顶点存储的数据类型设为字符型 */

/* 边的定义 */
typedef struct ENode *PtrToENode;
struct ENode{
    Vertex V1, V2;      /* 有向边&lt;V1, V2&gt; */
    WeightType Weight;  /* 权重 */
};
typedef PtrToENode Edge;

/* 邻接点的定义 */
typedef struct AdjVNode *PtrToAdjVNode; 
struct AdjVNode{
    Vertex AdjV;        /* 邻接点下标 */
    WeightType Weight;  /* 边权重 */
    PtrToAdjVNode Next;    /* 指向下一个邻接点的指针 */
};

/* 顶点表头结点的定义 */
typedef struct Vnode{
    PtrToAdjVNode FirstEdge;/* 边表头指针 */
    DataType Data;            /* 存顶点的数据 */
    /* 注意：很多情况下，顶点无数据，此时Data可以不用出现 */
} AdjList[MaxVertexNum];    /* AdjList是邻接表类型 */

/* 图结点的定义 */
typedef struct GNode *PtrToGNode;
struct GNode{  
    int Nv;     /* 顶点数 */
    int Ne;     /* 边数   */
    AdjList G;  /* 邻接表 */
};
typedef PtrToGNode LGraph; /* 以邻接表方式存储的图类型 */



LGraph CreateGraph( int VertexNum )
{ /* 初始化一个有VertexNum个顶点但没有边的图 */
    Vertex V;
    LGraph Graph;
    
    Graph = (LGraph)malloc( sizeof(struct GNode) ); /* 建立图 */
    Graph-&gt;Nv = VertexNum;
    Graph-&gt;Ne = 0;
    /* 初始化邻接表头指针 */
    /* 注意：这里默认顶点编号从0开始，到(Graph-&gt;Nv - 1) */
    for (V=0; V&lt;Graph-&gt;Nv; V++)
        Graph-&gt;G[V].FirstEdge = NULL;
            
    return Graph; 
}
       
void InsertEdge( LGraph Graph, Edge E )
{
    PtrToAdjVNode NewNode;
    
    /* 插入边 &lt;V1, V2&gt; */
    /* 为V2建立新的邻接点 */
    NewNode = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode));
    NewNode-&gt;AdjV = E-&gt;V2;
    NewNode-&gt;Weight = E-&gt;Weight;
    /* 将V2插入V1的表头 */
    NewNode-&gt;Next = Graph-&gt;G[E-&gt;V1].FirstEdge;
    Graph-&gt;G[E-&gt;V1].FirstEdge = NewNode;
        
    /* 若是无向图，还要插入边 &lt;V2, V1&gt; */
    /* 为V1建立新的邻接点 */
    NewNode = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode));
    NewNode-&gt;AdjV = E-&gt;V1;
    NewNode-&gt;Weight = E-&gt;Weight;
    /* 将V1插入V2的表头 */
    NewNode-&gt;Next = Graph-&gt;G[E-&gt;V2].FirstEdge;
    Graph-&gt;G[E-&gt;V2].FirstEdge = NewNode;
}

LGraph BuildGraph()
{
    LGraph Graph;
    Edge E;
    Vertex V;
    int Nv, i;
    
    scanf(&quot;%d&quot;, &amp;Nv);   /* 读入顶点个数 */
    Graph = CreateGraph(Nv); /* 初始化有Nv个顶点但没有边的图 */ 
    
    scanf(&quot;%d&quot;, &amp;(Graph-&gt;Ne));   /* 读入边数 */
    if ( Graph-&gt;Ne != 0 ) { /* 如果有边 */ 
        E = (Edge)malloc( sizeof(struct ENode) ); /* 建立边结点 */ 
        /* 读入边，格式为&quot;起点 终点 权重&quot;，插入邻接矩阵 */
        for (i=0; i&lt;Graph-&gt;Ne; i++) {
            scanf(&quot;%d %d %d&quot;, &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight); 
            /* 注意：如果权重不是整型，Weight的读入格式要改 */
            InsertEdge( Graph, E );
        }
    } 

    /* 如果顶点有数据的话，读入数据 */
    for (V=0; V&lt;Graph-&gt;Nv; V++) 
        scanf(&quot; %c&quot;, &amp;(Graph-&gt;G[V].Data));

    return Graph;
}
</code></pre>
<h3 id="邻接表存储dfs遍历实例"><a class="header" href="#邻接表存储dfs遍历实例">邻接表存储、DFS遍历实例</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;


#define MaxVertexNum 100    /* 最大顶点数设为100 */
typedef int Vertex;         /* 用顶点下标表示顶点,为整型 */
typedef int WeightType;        /* 边的权值设为整型 */
typedef char DataType;        /* 顶点存储的数据类型设为字符型 */

int Visited[MaxVertexNum];

void InitVisited()
{
    for(int i=0; i&lt;MaxVertexNum; i++)
        Visited[i] = 0;
}

/* 边的定义 */
typedef struct ENode *PtrToENode;
struct ENode{
    Vertex V1, V2;      /* 有向边&lt;V1, V2&gt; */
    WeightType Weight;  /* 权重 */
};
typedef PtrToENode Edge;

typedef struct AdjVNode *PtrToAdjVNode;
struct AdjVNode
{
    Vertex AdjV;
    WeightType Weight;
    PtrToAdjVNode Next;
};

typedef struct VNode
{
    PtrToAdjVNode FirstEdge;
}AdjList[MaxVertexNum];

typedef struct GNode *PtrToGNode;

struct GNode
{
    int Ne;
    int Nv;
    AdjList G;
};

typedef PtrToGNode LGraph;

LGraph CreateGraph(int VertexNum)
{
    LGraph Graph = (LGraph)malloc(sizeof(struct GNode));
    Graph-&gt;Nv = VertexNum;
    Graph-&gt;Ne = 0;
    for(int i=0; i&lt;Graph-&gt;Nv; i++)
    {
        Graph-&gt;G[i].FirstEdge = NULL;
    }
    return Graph;
}

void InsertEdge(LGraph Graph, Edge E)
{
    PtrToAdjVNode newNode = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode));
    newNode-&gt;AdjV = E-&gt;V2;
    newNode-&gt;Weight = E-&gt;Weight;
    newNode-&gt;Next = Graph-&gt;G[E-&gt;V1].FirstEdge;
    Graph-&gt;G[E-&gt;V1].FirstEdge = newNode;

    newNode = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode));
    newNode-&gt;AdjV = E-&gt;V1;
    newNode-&gt;Weight = E-&gt;Weight;
    newNode-&gt;Next = Graph-&gt;G[E-&gt;V2].FirstEdge;
    Graph-&gt;G[E-&gt;V2].FirstEdge = newNode;
}

LGraph BuildGraph()
{
    LGraph Graph = (LGraph)malloc(sizeof(struct GNode));
    Edge E;
    int Nv;
    scanf(&quot;%d&quot;, &amp;Nv);
    Graph = CreateGraph(Nv);
    scanf(&quot;%d&quot;, &amp;(Graph-&gt;Ne));
    if(Graph-&gt;Ne != 0)
    {
        for(int i=0; i&lt;Graph-&gt;Ne; i++)
        {
            E = (Edge)malloc(sizeof(struct ENode));
            scanf(&quot;%d %d %d&quot;,&amp;E-&gt;V1,&amp;E-&gt;V2,&amp;E-&gt;Weight);
            InsertEdge(Graph, E);
        }
    }
    return Graph;
}

/* 邻接表存储的图 - DFS */

void Visit( Vertex V )
{
    printf(&quot;正在访问顶点%d\n&quot;, V);
}

/* Visited[]为全局变量，已经初始化为false */
void DFS( LGraph Graph, Vertex V, void (*Visit)(Vertex) )
{   /* 以V为出发点对邻接表存储的图Graph进行DFS搜索 */
    PtrToAdjVNode W;

    Visit( V ); /* 访问第V个顶点 */
    Visited[V] = 1; /* 标记V已访问 */

    for( W=Graph-&gt;G[V].FirstEdge; W; W=W-&gt;Next ) /* 对V的每个邻接点W-&gt;AdjV */
        if ( !Visited[W-&gt;AdjV] )    /* 若W-&gt;AdjV未被访问 */
            DFS( Graph, W-&gt;AdjV, Visit );    /* 则递归访问之 */
}

void PrintList(LGraph Graph)
{
    for(int i=0; i&lt;Graph-&gt;Nv; i++)
    {
        PtrToAdjVNode W = Graph-&gt;G[i].FirstEdge;
        printf(&quot;G[%d]:&quot;, i);
        int IsFirst = 1;
        while(W)
        {
            if(IsFirst)
            {
                printf(&quot;%d&quot;, W-&gt;AdjV);
                IsFirst = 0;
            }
            else
                printf(&quot;-&gt;%d&quot;, W-&gt;AdjV);
            W = W-&gt;Next;
        }
        printf(&quot;\n&quot;);
    }
}

int main()
{
    LGraph Graph = BuildGraph();
    InitVisited();
    DFS(Graph, 0, Visit);
    PrintList(Graph);
    return 0;
}
</code></pre>
<p>输入数据：</p>
<pre><code>6  
7  
0 1 1  
0 2 1  
0 4 1  
1 4 1  
2 5 1  
3 4 1  
3 5 1  
</code></pre>
<p>输出结果：</p>
<pre><code>正在访问顶点0
正在访问顶点4
正在访问顶点3
正在访问顶点5
正在访问顶点2
正在访问顶点1
G[0]:4-&gt;2-&gt;1
G[1]:4-&gt;0
G[2]:5-&gt;0
G[3]:5-&gt;4
G[4]:3-&gt;1-&gt;0
G[5]:3-&gt;2
</code></pre>
<h2 id="十字链表"><a class="header" href="#十字链表">十字链表</a></h2>
<h2 id="邻接多重表"><a class="header" href="#邻接多重表">邻接多重表</a></h2>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="图的遍历"><a class="header" href="#图的遍历">图的遍历</a></h1>
<ul>
<li><a href="%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86.html#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2dfs">深度优先搜索DFS</a>
<ul>
<li><a href="%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86.html#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AD%98%E5%82%A8">邻接矩阵存储</a></li>
<li><a href="%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86.html#%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AD%98%E5%82%A8">邻接表存储</a></li>
</ul>
</li>
<li><a href="%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86.html#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2bfs">广度优先搜索BFS</a>
<ul>
<li><a href="%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86.html#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AD%98%E5%82%A8-1">邻接矩阵存储</a></li>
<li><a href="%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86.html#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AD%98%E5%82%A8bfs%E5%AE%9E%E4%BE%8B">邻接矩阵存储、BFS实例</a></li>
</ul>
</li>
<li><a href="%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86.html#%E8%BF%9E%E9%80%9A%E5%9B%BE">连通图</a></li>
</ul>
<h2 id="深度优先搜索dfs"><a class="header" href="#深度优先搜索dfs">深度优先搜索DFS</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312150017889.png" alt="" /></p>
<h3 id="邻接矩阵存储"><a class="header" href="#邻接矩阵存储">邻接矩阵存储</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MAXN 100

int G[MAXN][MAXN], Nv, Ne;

void BuildGraph()
{
    int i,j,v1,v2,w;
    scanf(&quot;%d&quot;,&amp;Nv);
    for(i=0; i&lt;Nv; i++)
    {
        for(j=0; j&lt;Nv; j++)
        {
            G[i][j] = 0;
        }
    }
    scanf(&quot;%d&quot;,&amp;Ne);
    for(i=0; i&lt;Ne; i++)
    {
        scanf(&quot;%d %d %d&quot;,&amp;v1,&amp;v2,&amp;w);
        G[v1][v2] = w;
        G[v2][v1] = w;
    }
}

void printGraph()
{
    for(int i=0;i &lt; Nv; i++)
    {
        for(int j=0; j&lt;Nv; j++)
        {
            printf(&quot;%d &quot;, G[i][j]);
        }
        printf(&quot;\n&quot;);
    }
}

typedef int Vertex;
#define TRUE 1
#define FALSE 0
typedef int Boolean;
Boolean visited[MAXN];
Boolean IsFirst = TRUE;

void dfs(Vertex V)
{
    visited[V] = TRUE;
    if(IsFirst)
    {
        printf(&quot;%c&quot;,(char)(97 + V));
        IsFirst = FALSE;
    }
    else
        printf(&quot;-&gt;%c&quot;,(char)(97 + V));
    for(int j=0; j&lt;Nv; j++)
    {
        if(G[V][j]==1 &amp;&amp; visited[j] == FALSE)
            dfs(j);
    }
}

int main()
{
    BuildGraph();
    printGraph();
    bfs(0);
    return 0;
}
</code></pre>
<pre><code>6  
7  
0 1 1  
0 2 1  
0 4 1  
1 4 1  
2 5 1  
3 4 1  
3 5 1  
</code></pre>
<pre><code>0 1 1 0 1 0
1 0 0 0 1 0
1 0 0 0 0 1
0 0 0 0 1 1
1 1 0 1 0 0
0 0 1 1 0 0
a-&gt;b-&gt;e-&gt;d-&gt;f-&gt;c
</code></pre>
<h3 id="邻接表存储"><a class="header" href="#邻接表存储">邻接表存储</a></h3>
<pre><code class="language-c">/* 邻接表存储的图 - DFS */

void Visit( Vertex V )
{
    printf(&quot;正在访问顶点%d\n&quot;, V);
}

/* Visited[]为全局变量，已经初始化为false */
void DFS( LGraph Graph, Vertex V, void (*Visit)(Vertex) )
{   /* 以V为出发点对邻接表存储的图Graph进行DFS搜索 */
    PtrToAdjVNode W;
    
    Visit( V ); /* 访问第V个顶点 */
    Visited[V] = true; /* 标记V已访问 */

    for( W=Graph-&gt;G[V].FirstEdge; W; W=W-&gt;Next ) /* 对V的每个邻接点W-&gt;AdjV */
        if ( !Visited[W-&gt;AdjV] )    /* 若W-&gt;AdjV未被访问 */
            DFS( Graph, W-&gt;AdjV, Visit );    /* 则递归访问之 */
}
</code></pre>
<h2 id="广度优先搜索bfs"><a class="header" href="#广度优先搜索bfs">广度优先搜索BFS</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312150018452.png" alt="" /></p>
<h3 id="邻接矩阵存储-1"><a class="header" href="#邻接矩阵存储-1">邻接矩阵存储</a></h3>
<pre><code class="language-c">/* 邻接矩阵存储的图 - BFS */

/* IsEdge(Graph, V, W)检查&lt;V, W&gt;是否图Graph中的一条边，即W是否V的邻接点。  */
/* 此函数根据图的不同类型要做不同的实现，关键取决于对不存在的边的表示方法。*/
/* 例如对有权图, 如果不存在的边被初始化为INFINITY, 则函数实现如下:         */
bool IsEdge( MGraph Graph, Vertex V, Vertex W )
{
    return Graph-&gt;G[V][W]&lt;INFINITY ? true : false;
}

/* Visited[]为全局变量，已经初始化为false */
void BFS ( MGraph Graph, Vertex S, void (*Visit)(Vertex) )
{   /* 以S为出发点对邻接矩阵存储的图Graph进行BFS搜索 */
    Queue Q;     
    Vertex V, W;

    Q = CreateQueue( MaxSize ); /* 创建空队列, MaxSize为外部定义的常数 */
    /* 访问顶点S：此处可根据具体访问需要改写 */
    Visit( S );
    Visited[S] = true; /* 标记S已访问 */
    AddQ(Q, S); /* S入队列 */
    
    while ( !IsEmpty(Q) ) {
        V = DeleteQ(Q);  /* 弹出V */
        for( W=0; W&lt;Graph-&gt;Nv; W++ ) /* 对图中的每个顶点W */
            /* 若W是V的邻接点并且未访问过 */
            if ( !Visited[W] &amp;&amp; IsEdge(Graph, V, W) ) {
                /* 访问顶点W */
                Visit( W );
                Visited[W] = true; /* 标记W已访问 */
                AddQ(Q, W); /* W入队列 */
            }
    } /* while结束*/
}
</code></pre>
<h3 id="邻接矩阵存储bfs实例"><a class="header" href="#邻接矩阵存储bfs实例">邻接矩阵存储、BFS实例</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MAXN 100

int G[MAXN][MAXN], Nv, Ne;

void BuildGraph()
{
    int i,j,v1,v2,w;
    scanf(&quot;%d&quot;,&amp;Nv);
    for(i=0; i&lt;Nv; i++)
    {
        for(j=0; j&lt;Nv; j++)
        {
            G[i][j] = 0;
        }
    }
    scanf(&quot;%d&quot;,&amp;Ne);
    for(i=0; i&lt;Ne; i++)
    {
        scanf(&quot;%d %d %d&quot;,&amp;v1,&amp;v2,&amp;w);
        G[v1][v2] = w;
        G[v2][v1] = w;
    }
}

void printGraph()
{
    for(int i=0;i &lt; Nv; i++)
    {
        for(int j=0; j&lt;Nv; j++)
        {
            printf(&quot;%d &quot;, G[i][j]);
        }
        printf(&quot;\n&quot;);
    }
}

typedef int Vertex;
#define TRUE 1
#define FALSE 0
typedef int Boolean;
Boolean visited[MAXN];
Boolean IsFirst = TRUE;

void bfs(Vertex V)
{
    int queue[100];
    int front = 0;
    int tail = 0;
    visited[V] = TRUE;
    queue[tail++] = V;
    int temp;
    while(front != tail)
    {
        temp = queue[front++];
        if(IsFirst)
        {
            printf(&quot;%c&quot;,(char)(97 + temp));
            IsFirst = FALSE;
        }
        else
            printf(&quot;-&gt;%c&quot;,(char)(97 + temp));
        for(int i=0;i &lt;Nv; i++)
        {
            if(G[temp][i] == 1 &amp;&amp; visited[i] == FALSE)
            {
                visited[i] = TRUE;
                queue[tail++] = i;
            }
        }
    }
}

int main()
{
    BuildGraph();
    printGraph();
    bfs(0);
    return 0;
}
</code></pre>
<pre><code>0 1 1 0 1 0
1 0 0 0 1 0
1 0 0 0 0 1
0 0 0 0 1 1
1 1 0 1 0 0
0 0 1 1 0 0
a-&gt;b-&gt;c-&gt;e-&gt;f-&gt;d
</code></pre>
<h2 id="连通图"><a class="header" href="#连通图">连通图</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312150019290.png" alt="" /></p>
<p>具有N个顶点的无向图至多有多少个连通分量？N</p>
<p>如果从无向图的任一顶点出发进行一次深度优先搜索可访问所有顶点，则该图一定是连通图</p>
<p>具有N个顶点的无向图至少有多少个连通分量？1</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312150020524.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312150020711.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312150021924.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="最短路径算法"><a class="header" href="#最短路径算法">最短路径算法</a></h1>
<ul>
<li><a href="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95.html#%E5%8D%95%E6%BA%90%E6%97%A0%E6%9D%83%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95">单源无权图最短路算法</a>
<ul>
<li><a href="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95.html#%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AD%98%E5%82%A8---%E6%97%A0%E6%9D%83%E5%9B%BE%E7%9A%84%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95">邻接表存储 - 无权图的单源最短路算法</a></li>
</ul>
</li>
<li><a href="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95.html#%E5%8D%95%E6%BA%90%E6%9C%89%E6%9D%83%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95dijkstra%E7%AE%97%E6%B3%95">单源有权图最短路径算法——Dijkstra算法</a>
<ul>
<li><a href="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95.html#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AD%98%E5%82%A8---%E6%9C%89%E6%9D%83%E5%9B%BE%E7%9A%84%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95">邻接矩阵存储 - 有权图的单源最短路算法</a></li>
<li><a href="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95.html#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AD%98%E5%82%A8---%E6%9C%89%E6%9D%83%E5%9B%BE%E7%9A%84%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95%E5%AE%9E%E4%BE%8B">邻接矩阵存储 - 有权图的单源最短路算法实例</a></li>
</ul>
</li>
<li><a href="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95.html#%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95floyd%E7%AE%97%E6%B3%95">多源最短路算法——Floyd算法</a>
<ul>
<li><a href="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95.html#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AD%98%E5%82%A8---%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95">邻接矩阵存储 - 多源最短路算法</a></li>
</ul>
</li>
<li><a href="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95.html#%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95">分支限界法</a></li>
<li><a href="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95.html#bellman-ford%E7%AE%97%E6%B3%95">Bellman-Ford算法</a></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312150023866.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312150023476.png" alt="" /></p>
<h2 id="单源无权图最短路算法"><a class="header" href="#单源无权图最短路算法">单源无权图最短路算法</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312150023847.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312150023914.png" alt="" /></p>
<p><code>dist[W]</code> = V 到 W 的最短距离；那么<code>dist[W]</code>应该被初始化为多少呢？D</p>
<ul>
<li>A.正无穷</li>
<li>B.负无穷</li>
<li>C.-1</li>
<li>D.这三种都可以</li>
</ul>
<p>随便一个不可能的数字即可表示没被访问，注意这里是无权图。</p>
<p>如果有|V|个顶点和|E|条边的图用邻接表存储，则算法的时间复杂度是多少？</p>
<pre><code class="language-c">void Unweighted ( Vertex S ) 
{ 
	Enqueue(S, Q);
	while(!IsEmpty(Q)){
	    V = Dequeue(Q); 
	    for ( V 的每个邻接点 W )
	      if ( dist[W] == -1  ) {
	        dist[W] = dist[V]+1;
	        path[W] = V;
	        Enqueue(W, Q);
      }
  }
}
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312180956024.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312180959798.png" alt="" /></p>
<h3 id="邻接表存储---无权图的单源最短路算法"><a class="header" href="#邻接表存储---无权图的单源最短路算法">邻接表存储 - 无权图的单源最短路算法</a></h3>
<pre><code class="language-c">/* 邻接表存储 - 无权图的单源最短路算法 */

/* dist[]和path[]全部初始化为-1 */
void Unweighted ( LGraph Graph, int dist[], int path[], Vertex S )
{
    Queue Q;
    Vertex V;
    PtrToAdjVNode W;
    
    Q = CreateQueue( Graph-&gt;Nv ); /* 创建空队列, MaxSize为外部定义的常数 */
    dist[S] = 0; /* 初始化源点 */
    AddQ (Q, S);

    while( !IsEmpty(Q) ){
        V = DeleteQ(Q);
        for ( W=Graph-&gt;G[V].FirstEdge; W; W=W-&gt;Next ) /* 对V的每个邻接点W-&gt;AdjV */
            if ( dist[W-&gt;AdjV]==-1 ) { /* 若W-&gt;AdjV未被访问过 */
                dist[W-&gt;AdjV] = dist[V]+1; /* W-&gt;AdjV到S的距离更新 */
                path[W-&gt;AdjV] = V; /* 将V记录在S到W-&gt;AdjV的路径上 */
                AddQ(Q, W-&gt;AdjV);
            }
    } /* while结束*/
}
</code></pre>
<h2 id="单源有权图最短路径算法dijkstra算法"><a class="header" href="#单源有权图最短路径算法dijkstra算法">单源有权图最短路径算法——Dijkstra算法</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312150024318.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312150024396.png" alt="" /></p>
<p>如果收录v使得s到w的路径变短，则：s到w的路径一定经过v，并且v到w有一条边</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312150024069.png" alt="" /></p>
<p>Dijkstra算法中的dist应该如何初始化？如果s到w有直接的边，则<code>dist[w]=&lt;s,w&gt;的权重</code>；否则<code>dist[w]</code>定义为A</p>
<ul>
<li>A.正无穷</li>
<li>B.负无穷</li>
<li>C. -1</li>
<li>D.这三种都可以</li>
</ul>
<p>注：这里是根据不等式结果更新dist数组的，不能随便初始化</p>
<pre><code class="language-c">void Dijkstra( Vertex s )
{ while (1) {
    V = 未收录顶点中dist最小者;
    if ( 这样的V不存在 )
      break; 
    collected[V] = true;
    for ( V 的每个邻接点 W )
      if ( collected[W] == false ) 
    if ( dist[V]+E&lt;V,W&gt; &lt; dist[W] ) {
         dist[W] = dist[V] + E&lt;V,W&gt; ;
         path[W] = V;
    }
  }
}
</code></pre>
<p>算法的时间复杂度是多少？</p>
<p>不好计算，取决于如何从未收录顶点中选出dist最小者</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312150025731.png" alt="" /></p>
<h3 id="邻接矩阵存储---有权图的单源最短路算法"><a class="header" href="#邻接矩阵存储---有权图的单源最短路算法">邻接矩阵存储 - 有权图的单源最短路算法</a></h3>
<pre><code class="language-c">/* 邻接矩阵存储 - 有权图的单源最短路算法 */

Vertex FindMinDist( MGraph Graph, int dist[], int collected[] )
{ /* 返回未被收录顶点中dist最小者 */
    Vertex MinV, V;
    int MinDist = INFINITY;

    for (V=0; V&lt;Graph-&gt;Nv; V++) {
        if ( collected[V]==false &amp;&amp; dist[V]&lt;MinDist) {
            /* 若V未被收录，且dist[V]更小 */
            MinDist = dist[V]; /* 更新最小距离 */
            MinV = V; /* 更新对应顶点 */
        }
    }
    if (MinDist &lt; INFINITY) /* 若找到最小dist */
        return MinV; /* 返回对应的顶点下标 */
    else return ERROR;  /* 若这样的顶点不存在，返回错误标记 */
}

bool Dijkstra( MGraph Graph, int dist[], int path[], Vertex S )
{
    int collected[MaxVertexNum];
    Vertex V, W;

    /* 初始化：此处默认邻接矩阵中不存在的边用INFINITY表示 */
    for ( V=0; V&lt;Graph-&gt;Nv; V++ ) {
        dist[V] = Graph-&gt;G[S][V];
        if ( dist[V]&lt;INFINITY )
            path[V] = S;
        else
            path[V] = -1;
        collected[V] = false;
    }
    /* 先将起点收入集合 */
    dist[S] = 0;
    collected[S] = true;

    while (1) {
        /* V = 未被收录顶点中dist最小者 */
        V = FindMinDist( Graph, dist, collected );
        if ( V==ERROR ) /* 若这样的V不存在 */
            break;      /* 算法结束 */
        collected[V] = true;  /* 收录V */
        for( W=0; W&lt;Graph-&gt;Nv; W++ ) /* 对图中的每个顶点W */
            /* 若W是V的邻接点并且未被收录 */
            if ( collected[W]==false &amp;&amp; Graph-&gt;G[V][W]&lt;INFINITY ) {
                if ( Graph-&gt;G[V][W]&lt;0 ) /* 若有负边 */
                    return false; /* 不能正确解决，返回错误标记 */
                /* 若收录V使得dist[W]变小 */
                if ( dist[V]+Graph-&gt;G[V][W] &lt; dist[W] ) {
                    dist[W] = dist[V]+Graph-&gt;G[V][W]; /* 更新dist[W] */
                    path[W] = V; /* 更新S到W的路径 */
                }
            }
    } /* while结束*/
    return true; /* 算法执行完毕，返回正确标记 */
}
</code></pre>
<h3 id="邻接矩阵存储---有权图的单源最短路算法实例"><a class="header" href="#邻接矩阵存储---有权图的单源最短路算法实例">邻接矩阵存储 - 有权图的单源最短路算法实例</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

#define MaxVertexNum 100
#define INFINITY 65535

int visited[MaxVertexNum];
int dist[MaxVertexNum];
int path[MaxVertexNum];

typedef int Vertex;
typedef int WeightType;

typedef struct ENode *PtrToENode;
struct ENode
{
    Vertex V1;
    Vertex V2;
    WeightType Weight;
};
typedef PtrToENode Edge;

typedef struct GNode *PtrToGNode;
struct GNode
{
    int Nv;
    int Ne;
    WeightType G[MaxVertexNum][MaxVertexNum];
};
typedef PtrToGNode MGraph;

MGraph CreateGraph(int VertexNum)
{
    MGraph Graph = (MGraph)malloc(sizeof(struct GNode));
    Graph-&gt;Nv = VertexNum;
    Graph-&gt;Ne = 0;
    Vertex V1,V2;
    for(Vertex V1=0; V1&lt;Graph-&gt;Nv; V1++)
        for(Vertex V2=0; V2&lt;Graph-&gt;Nv; V2++)
            Graph-&gt;G[V1][V2] = 0;

    return Graph;
}

void InsertEdge(MGraph Graph, Edge E)
{
    Graph-&gt;G[E-&gt;V1][E-&gt;V2] = E-&gt;Weight;
}

MGraph BuildGraph()
{
    int Nv;
    Edge E;
    scanf(&quot;%d&quot;, &amp;Nv);
    MGraph Graph = CreateGraph(Nv);
    scanf(&quot;%d&quot;, &amp;(Graph-&gt;Ne));
    if((Graph-&gt;Ne) != 0)
    {
        E = (Edge)malloc(sizeof(struct ENode));
        for(int i=0; i&lt;Graph-&gt;Ne; i++)
        {
            scanf(&quot;%d %d %d&quot;,&amp;E-&gt;V1,&amp;E-&gt;V2,&amp;E-&gt;Weight);
            InsertEdge(Graph, E);
        }
    }
    return Graph;
}

void ResetVisited()
{
    for(int i=0; i&lt;MaxVertexNum; i++)
        visited[i] = 0;
}

void Dijkstra(MGraph Graph, Vertex V)
{
    ResetVisited();
    for(int i=0; i&lt;Graph-&gt;Nv; i++)
    {
        if(Graph-&gt;G[V][i]&gt;0 &amp;&amp; V!=i)
        {
            dist[i] = Graph-&gt;G[V][i];
            path[i] = V;
        }
        else
        {
            dist[i] = INFINITY;
            path[i] = -1;
        }
    }
    dist[V] = 0;
    path[V] = V;
    visited[V] = 1;
    for(int i=1; i&lt;Graph-&gt;Nv; i++)
    {
        int minDist = INT_MAX;
        int index;
        for(int j=0; j&lt;Graph-&gt;Nv; j++)
        {
            if(visited[j]==0 &amp;&amp; dist[j]&lt;minDist)
            {
                minDist = dist[j];
                index = j;
            }
        }
        visited[index] = 1;
        for(int k=0; k&lt;Graph-&gt;Nv; k++)
        {
            if(visited[k]==0 &amp;&amp; Graph-&gt;G[index][k]&gt;0 &amp;&amp; minDist+Graph-&gt;G[index][k]&lt;dist[k])
            {
                dist[k] = minDist+Graph-&gt;G[index][k];
                path[k] = index;
            }
        }
    }

}

void PrintPath(int path[], int distance)
{
    int temp = distance;
    int count = 1;
    int collected[MaxVertexNum] = {0};

    while(path[temp]!=0)
    {
        collected[count] = path[temp];
        count++;
        temp = path[temp];
    }
    collected[count] = path[temp];
    while(count!=0)
    {
        printf(&quot;v%d-&gt;&quot;, collected[count]);
        count--;
    }
    printf(&quot;v%d&quot;,distance);
}

int main()
{
    MGraph Graph = BuildGraph();
    Dijkstra(Graph, 0);
    int distance = 5;
    PrintPath(path, distance);
    printf(&quot;\ncost distance :%d&quot;,dist[distance]);
    return 0;
}
</code></pre>
<p>输入数据：</p>
<pre><code>7 12
2 0 4
2 5 5
0 1 2
0 3 1
1 4 10
1 3 3
3 2 2
3 5 8
3 6 4
3 4 2
4 6 6
6 5 1
</code></pre>
<p>输出结果：</p>
<pre><code>v0-&gt;v3-&gt;v6-&gt;v5
cost distance :6
</code></pre>
<h2 id="多源最短路算法floyd算法"><a class="header" href="#多源最短路算法floyd算法">多源最短路算法——Floyd算法</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312150025085.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312150027534.png" alt="" /></p>
<p>D矩阵应该初始化为什么？</p>
<ul>
<li>A.带权的邻接矩阵，对角元是0</li>
<li>B.带权的邻接矩阵，对角元是无穷大</li>
<li>C.全是0的矩阵</li>
<li>D.全是无穷大的矩阵</li>
</ul>
<p>正确答案：A你选对了</p>
<p>如果i和j之间没有直接的边，<code>D[i][j]</code>应该定义为什么？</p>
<ul>
<li>A.正无穷</li>
<li>B.0</li>
<li>C.负无穷</li>
<li>D.这三种都可以</li>
</ul>
<p>正确答案：A你选对了</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312150027520.png" alt="" /></p>
<h3 id="邻接矩阵存储---多源最短路算法"><a class="header" href="#邻接矩阵存储---多源最短路算法">邻接矩阵存储 - 多源最短路算法</a></h3>
<pre><code class="language-c">/* 邻接矩阵存储 - 多源最短路算法 */

bool Floyd( MGraph Graph, WeightType D[][MaxVertexNum], Vertex path[][MaxVertexNum] )
{
    Vertex i, j, k;

    /* 初始化 */
    for ( i=0; i&lt;Graph-&gt;Nv; i++ )
        for( j=0; j&lt;Graph-&gt;Nv; j++ ) {
            D[i][j] = Graph-&gt;G[i][j];
            path[i][j] = -1;
        }

    for( k=0; k&lt;Graph-&gt;Nv; k++ )
        for( i=0; i&lt;Graph-&gt;Nv; i++ )
            for( j=0; j&lt;Graph-&gt;Nv; j++ )
                if( D[i][k] + D[k][j] &lt; D[i][j] ) {
                    D[i][j] = D[i][k] + D[k][j];
                    if ( i==j &amp;&amp; D[i][j]&lt;0 ) /* 若发现负值圈 */
                        return false; /* 不能正确解决，返回错误标记 */
                    path[i][j] = k;
                }
    return true; /* 算法执行完毕，返回正确标记 */
}
</code></pre>
<h2 id="分支限界法"><a class="header" href="#分支限界法"><strong>分支限界法</strong></a></h2>
<p>https://blog.csdn.net/lcw_2015/article/details/52892501</p>
<h2 id="bellman-ford算法"><a class="header" href="#bellman-ford算法"><strong>Bellman-Ford算法</strong></a></h2>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="最小生成树算法"><a class="header" href="#最小生成树算法">最小生成树算法</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="mooc-pta图题目"><a class="header" href="#mooc-pta图题目">MOOC-PTA图题目</a></h1>
<ul>
<li><a href="MOOC-PTA%E5%9B%BE%E9%A2%98%E7%9B%AE.html#pta-06-%E5%9B%BE1-%E5%88%97%E5%87%BA%E8%BF%9E%E9%80%9A%E9%9B%86">PTA 06-图1 列出连通集</a></li>
<li><a href="MOOC-PTA%E5%9B%BE%E9%A2%98%E7%9B%AE.html#pta-06-%E5%9B%BE2-saving-james-bond---easy-version">PTA 06-图2 Saving James Bond - Easy Version</a></li>
<li><a href="MOOC-PTA%E5%9B%BE%E9%A2%98%E7%9B%AE.html#pta-06-%E5%9B%BE3-%E5%85%AD%E5%BA%A6%E7%A9%BA%E9%97%B4">PTA 06-图3 六度空间</a></li>
<li><a href="MOOC-PTA%E5%9B%BE%E9%A2%98%E7%9B%AE.html#pta-07-%E5%9B%BE4-%E5%93%88%E5%88%A9%E6%B3%A2%E7%89%B9%E7%9A%84%E8%80%83%E8%AF%95">PTA 07-图4 哈利·波特的考试</a></li>
<li><a href="MOOC-PTA%E5%9B%BE%E9%A2%98%E7%9B%AE.html#pta-07-%E5%9B%BE5-saving-james-bond---hard-version">PTA 07-图5 Saving James Bond - Hard Version</a></li>
<li><a href="MOOC-PTA%E5%9B%BE%E9%A2%98%E7%9B%AE.html#pta-07-%E5%9B%BE6-%E6%97%85%E6%B8%B8%E8%A7%84%E5%88%92">PTA 07-图6 旅游规划</a></li>
<li><a href="MOOC-PTA%E5%9B%BE%E9%A2%98%E7%9B%AE.html#pta-08-%E5%9B%BE7-%E5%85%AC%E8%B7%AF%E6%9D%91%E6%9D%91%E9%80%9A">PTA 08-图7 公路村村通</a></li>
<li><a href="MOOC-PTA%E5%9B%BE%E9%A2%98%E7%9B%AE.html#pta-08-%E5%9B%BE8-how-long-does-it-take">PTA 08-图8 How Long Does It Take</a></li>
<li><a href="MOOC-PTA%E5%9B%BE%E9%A2%98%E7%9B%AE.html#pta-08-%E5%9B%BE9-%E5%85%B3%E9%94%AE%E6%B4%BB%E5%8A%A8">PTA 08-图9 关键活动</a></li>
</ul>
<h2 id="pta-06-图1-列出连通集"><a class="header" href="#pta-06-图1-列出连通集">PTA 06-图1 列出连通集</a></h2>
<p>给定一个有N个顶点和E条边的无向图，请用DFS和BFS分别列出其所有的连通集。假设顶点从0到N−1编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。</p>
<p>输入格式:</p>
<p>输入第1行给出2个整数N(0&lt;N≤10)和E，分别是图的顶点数和边数。随后E行，每行给出一条边的两个端点。每行中的数字之间用1空格分隔。</p>
<p>输出格式:</p>
<p>按照&quot;{ v1​ v2​ ... vk​ }&quot;的格式，每行输出一个连通集。先输出DFS的结果，再输出BFS的结果。</p>
<p>输入样例:</p>
<pre><code>8 6
0 7
0 1
2 0
4 1
2 4
3 5
</code></pre>
<p>输出样例:</p>
<pre><code>{ 0 1 4 2 7 }
{ 3 5 }
{ 6 }
{ 0 1 2 7 4 }
{ 3 5 }
{ 6 }
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MAXN 100

int G[MAXN][MAXN], Nv, Ne;

void BuildGraph()
{
    int i,j,v1,v2,w;
    scanf(&quot;%d&quot;,&amp;Nv);
    for(i=0; i&lt;Nv; i++)
    {
        for(j=0; j&lt;Nv; j++)
        {
            G[i][j] = 0;
        }
    }
    scanf(&quot;%d&quot;,&amp;Ne);
    for(i=0; i&lt;Ne; i++)
    {
        scanf(&quot;%d %d&quot;,&amp;v1,&amp;v2);
        G[v1][v2] = 1;
        G[v2][v1] = 1;
    }
}

void printGraph()
{
    for(int i=0;i &lt; Nv; i++)
    {
        for(int j=0; j&lt;Nv; j++)
        {
            printf(&quot;%d &quot;, G[i][j]);
        }
        printf(&quot;\n&quot;);
    }
}

typedef int Vertex;
#define TRUE 1
#define FALSE 0
typedef int Boolean;
Boolean visited[MAXN];
Boolean IsFirst = TRUE;

void dfs(Vertex V)
{
    visited[V] = TRUE;
    if(IsFirst)
    {
        printf(&quot;%d&quot;,V);
        IsFirst = FALSE;
    }
    else
        printf(&quot; %d&quot;,V);
    for(int j=0; j&lt;Nv; j++)
    {
        if(G[V][j]==1 &amp;&amp; visited[j] == FALSE)
            dfs(j);
    }
}

void bfs(Vertex V)
{
    int queue[100];
    int front = 0;
    int tail = 0;
    visited[V] = TRUE;
    queue[tail++] = V;
    int temp;
    while(front != tail)
    {
        temp = queue[front++];
        if(IsFirst)
        {
            printf(&quot;%d&quot;, temp);
            IsFirst = FALSE;
        }
        else
            printf(&quot; %d&quot;,temp);
        for(int i=0;i &lt;Nv; i++)
        {
            if(G[temp][i] == 1 &amp;&amp; visited[i] == FALSE)
            {
                visited[i] = TRUE;
                queue[tail++] = i;
            }
        }
    }
}

int main()
{
    BuildGraph();
    //printGraph();
    for(int i=0; i&lt;Nv;i++)
    {
        if(visited[i] == FALSE)
        {
            printf(&quot;{ &quot;);
            dfs(i);
            printf(&quot; }\n&quot;);
        }
        IsFirst = TRUE;
    }
    for(int i=0; i&lt;Nv; i++)
        visited[i] = FALSE;
    for(int i=0; i&lt;Nv;i++)
    {
        if(visited[i] == FALSE)
        {
            printf(&quot;{ &quot;);
            bfs(i);
            printf(&quot; }\n&quot;);
        }
        IsFirst = TRUE;
    }
    return 0;
}
</code></pre>
<h2 id="pta-06-图2-saving-james-bond---easy-version"><a class="header" href="#pta-06-图2-saving-james-bond---easy-version">PTA 06-图2 Saving James Bond - Easy Version</a></h2>
<p>This time let us consider the situation in the movie &quot;Live and Let Die&quot; in which James Bond, the world's most famous spy, was captured by a group of drug dealers. He was sent to a small piece of land at the center of a lake filled with crocodiles. There he performed the most daring action to escape -- he jumped onto the head of the nearest crocodile! Before the animal realized what was happening, James jumped again onto the next big head... Finally he reached the bank before the last crocodile could bite him (actually the stunt man was caught by the big mouth and barely escaped with his extra thick boot).</p>
<p>Assume that the lake is a 100 by 100 square one. Assume that the center of the lake is at (0,0) and the northeast corner at (50,50). The central island is a disk centered at (0,0) with the diameter of 15. A number of crocodiles are in the lake at various positions. Given the coordinates of each crocodile and the distance that James could jump, you must tell him whether or not he can escape.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. Each case starts with a line containing two positive integers N (≤100), the number of crocodiles, and D, the maximum distance that James could jump. Then N lines follow, each containing the (x,y) location of a crocodile. Note that no two crocodiles are staying at the same position.</p>
<p>Output Specification:</p>
<p>For each test case, print in a line &quot;Yes&quot; if James can escape, or &quot;No&quot; if not.</p>
<p>Sample Input 1:</p>
<pre><code>14 20
25 -15
-25 28
8 49
29 15
-35 -2
5 28
27 -29
-8 -28
-20 -35
-25 -20
-13 29
-30 15
-35 40
12 12
</code></pre>
<p>Sample Output 1:</p>
<pre><code>Yes
</code></pre>
<p>Sample Input 2:</p>
<pre><code>4 13
-12 12
12 12
-12 -12
12 -12
</code></pre>
<p>Sample Output 2:</p>
<pre><code>No
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312150021730.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312150022304.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MAXN 100
#define TRUE 1
#define FALSE 0

typedef int Boolean;
Boolean visited[MAXN];

struct coordinate
{
    int x;
    int y;
}Points[MAXN];

int D = 0;

/*初始化标记矩阵*/
void ResetVisit()
{
    for(int i=0;i&lt;MAXN;i++)
        visited[i]=0;
}

Boolean FirstJump(int i)
{
    int x = Points[i].x;
    int y = Points[i].y;
    if((7.5+D)*(7.5+D) &gt;= (x*x + y*y))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

Boolean Jump(int i, int j)
{
    int x1 = Points[i].x;
    int y1 = Points[i].y;
    int x2 = Points[j].x;
    int y2 = Points[j].y;
    if(D*D &gt;= ((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2)))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

Boolean IsSafe(int i)
{
    int x = Points[i].x;
    int y = Points[i].y;
    if(x&lt;0)
        x = -x;
    if(y&lt;0)
        y = -y;
    if(50-x&lt;=D || 50-y&lt;=D)
        return TRUE;
    else
        return FALSE;
}

Boolean dfs(int i)
{
    visited[i] = TRUE;
    int answer;
    if(IsSafe(i))
        answer = TRUE;
    else
    {
        for(int j=0; j&lt;MAXN; j++)
        {
            //如果j节点未被访问，且能从j结点跳至j结点
            if(Jump(i,j) &amp;&amp; visited[j]!=TRUE)
            {
                answer = dfs(j);
                if(answer == TRUE)
                    break;
            }
        }
    }
    return answer;
}

void Save007()
{
    int answer;
    ResetVisit();
    for(int i=0; i&lt;MAXN; i++)
    {
        if(FirstJump(i) &amp;&amp; visited[i]!=TRUE)
        {
            answer = dfs(i);
            if(answer==TRUE)
                break;
        }
    }
    if(answer==TRUE)
        printf(&quot;Yes\n&quot;);
    else
        printf(&quot;No\n&quot;);
}

int main()
{
    int N;
    scanf(&quot;%d %d&quot;,&amp;N,&amp;D);
    for(int i=0; i&lt;N; i++)
    {
        scanf(&quot;%d %d&quot;,&amp;(Points[i].x),&amp;(Points[i].y));
    }
    Save007();

    return 0;
}
</code></pre>
<h2 id="pta-06-图3-六度空间"><a class="header" href="#pta-06-图3-六度空间">PTA 06-图3 六度空间</a></h2>
<p>“六度空间”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”如图1所示。</p>
<p><img src="https://images.ptausercontent.com/35" alt="" /></p>
<p>图1 六度空间示意图</p>
<p>“六度空间”理论虽然得到广泛的认同，并且正在得到越来越多的应用。但是数十年来，试图验证这个理论始终是许多社会学家努力追求的目标。然而由于历史的原因，这样的研究具有太大的局限性和困难。随着当代人的联络主要依赖于电话、短信、微信以及因特网上即时通信等工具，能够体现社交网络关系的一手数据已经逐渐使得“六度空间”理论的验证成为可能。</p>
<p>假如给你一个社交网络图，请你对每个节点计算符合“六度空间”理论的结点占结点总数的百分比。</p>
<p>输入格式:</p>
<p>输入第1行给出两个正整数，分别表示社交网络图的结点数N（1&lt;N≤10^3，表示人数）、边数M（≤33×N，表示社交关系数）。随后的M行对应M条边，每行给出一对正整数，分别是该条边直接连通的两个结点的编号（节点从1到N编号）。</p>
<p>输出格式:</p>
<p>对每个结点输出与该结点距离不超过6的结点数占结点总数的百分比，精确到小数点后2位。每个结节点输出一行，格式为“结点编号:（空格）百分比%”。</p>
<p>输入样例:</p>
<pre><code>10 9
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 9
9 10
</code></pre>
<p>输出样例:</p>
<pre><code>1: 70.00%
2: 80.00%
3: 90.00%
4: 100.00%
5: 100.00%
6: 100.00%
7: 100.00%
8: 90.00%
9: 80.00%
10: 70.00%
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202311231748469.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202311231748692.png" alt="" /></p>
<p>注意：</p>
<ol>
<li>不要忘记初始化，每个顶点统计完毕后都需要进行 /(ㄒoㄒ)/~~</li>
<li>统计结果的变量count需要设定初始值为1，因为该节点也满足统计要求</li>
</ol>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define TRUE 1
#define FALSE 0

int G[1001][1001];
int visited[1001];

int N = 0;
int last = 0;
int tail = 0;

void ResetVisited()
{
    for(int i=0; i&lt;1001; i++)
        visited[i] = 0;
}

int bfs(int v)
{
    visited[v] = TRUE;
    int count = 1;
    int level = 0;
    last = v;
    tail = 0;
    int queue[1001];
    int front = 0;
    int rear = 0;
    queue[rear++] = v;
    while(rear != front)
    {
        int temp = queue[front++];
        for(int i=1; i&lt;=N; i++)
        {
            if(visited[i]==FALSE &amp;&amp; G[temp][i]==1)
            {
                visited[i] = TRUE;
                queue[rear++] = i;
                tail = i;
                count++;
            }
        }
        if(temp == last)
        {
            level++;
            last = tail;
        }
        if(level == 6)
            break;
    }
    return count;
}

int main()
{
    int M,v1,v2;
    scanf(&quot;%d %d&quot;,&amp;N,&amp;M);
    for(int i=0; i&lt;N; i++)
    {
        for(int j=0; j&lt;N; j++)
            G[i][j] = 0;
    }
    for(int i=0; i&lt;M; i++)
    {
        scanf(&quot;%d %d&quot;,&amp;v1, &amp;v2);
        G[v1][v2] = 1;
        G[v2][v1] = 1;
    }
    for(int i=1; i&lt;=N; i++)
    {
        ResetVisited();
        int count = bfs(i);
        printf(&quot;%d: %.2f%%\n&quot;,i, count*1.0*100/N);
    }
}
</code></pre>
<h2 id="pta-07-图4-哈利波特的考试"><a class="header" href="#pta-07-图4-哈利波特的考试">PTA 07-图4 哈利·波特的考试</a></h2>
<p>哈利·波特要考试了，他需要你的帮助。这门课学的是用魔咒将一种动物变成另一种动物的本事。例如将猫变成老鼠的魔咒是haha，将老鼠变成鱼的魔咒是hehe等等。反方向变化的魔咒就是简单地将原来的魔咒倒过来念，例如ahah可以将老鼠变成猫。另外，如果想把猫变成鱼，可以通过念一个直接魔咒lalala，也可以将猫变老鼠、老鼠变鱼的魔咒连起来念：hahahehe。</p>
<p>现在哈利·波特的手里有一本教材，里面列出了所有的变形魔咒和能变的动物。老师允许他自己带一只动物去考场，要考察他把这只动物变成任意一只指定动物的本事。于是他来问你：带什么动物去可以让最难变的那种动物（即该动物变为哈利·波特自己带去的动物所需要的魔咒最长）需要的魔咒最短？例如：如果只有猫、鼠、鱼，则显然哈利·波特应该带鼠去，因为鼠变成另外两种动物都只需要念4个字符；而如果带猫去，则至少需要念6个字符才能把猫变成鱼；同理，带鱼去也不是最好的选择。</p>
<p>输入格式:</p>
<p>输入说明：输入第1行给出两个正整数N (≤100)和M，其中N是考试涉及的动物总数，M是用于直接变形的魔咒条数。为简单起见，我们将动物按1~N编号。随后M行，每行给出了3个正整数，分别是两种动物的编号、以及它们之间变形需要的魔咒的长度(≤100)，数字之间用空格分隔。</p>
<p>输出格式:</p>
<p>输出哈利·波特应该带去考场的动物的编号、以及最长的变形魔咒的长度，中间以空格分隔。如果只带1只动物是不可能完成所有变形要求的，则输出0。如果有若干只动物都可以备选，则输出编号最小的那只。</p>
<p>输入样例:</p>
<pre><code>6 11
3 4 70
1 2 1
5 4 50
2 6 50
5 6 60
1 3 70
4 6 60
3 6 80
5 1 100
2 4 60
5 2 80
</code></pre>
<p>输出样例:</p>
<pre><code>4 70
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202311281641009.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202311281642927.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MaxVertexNum 100
#define INFINITY 65535

typedef int Vertex;
typedef int WeightType;

typedef struct ENode *PtrToENode;
struct ENode
{
    Vertex V1;
    Vertex V2;
    WeightType Weight;
};
typedef PtrToENode Edge;

typedef struct GNode *PtrToGNode;
struct GNode
{
    int Nv;
    int Ne;
    WeightType G[MaxVertexNum][MaxVertexNum];
};
typedef PtrToGNode MGraph;

MGraph CreateGraph(int VertexNum)
{
    MGraph Graph = (MGraph)malloc(sizeof(struct GNode));
    Graph-&gt;Nv = VertexNum;
    Graph-&gt;Ne = 0;
    Vertex V1,V2;
    for(Vertex V1=0; V1&lt;Graph-&gt;Nv; V1++)
        for(Vertex V2=0; V2&lt;Graph-&gt;Nv; V2++)
            Graph-&gt;G[V1][V2] = INFINITY;

    return Graph;
}

void InsertEdge(MGraph Graph, Edge E)
{
    Graph-&gt;G[E-&gt;V1][E-&gt;V2] = E-&gt;Weight;
    Graph-&gt;G[E-&gt;V2][E-&gt;V1] = E-&gt;Weight;
}

MGraph BuildGraph()
{
    int Nv;
    Edge E;
    scanf(&quot;%d&quot;, &amp;Nv);
    MGraph Graph = CreateGraph(Nv);
    scanf(&quot;%d&quot;, &amp;(Graph-&gt;Ne));
    if((Graph-&gt;Ne) != 0)
    {
        E = (Edge)malloc(sizeof(struct ENode));
        for(int i=0; i&lt;Graph-&gt;Ne; i++)
        {
            scanf(&quot;%d %d %d&quot;,&amp;E-&gt;V1,&amp;E-&gt;V2,&amp;E-&gt;Weight);
            E-&gt;V1--;
            E-&gt;V2--;
            InsertEdge(Graph, E);
        }
    }
    return Graph;
}

void Floyd(MGraph Graph, WeightType D[][MaxVertexNum])
{
    Vertex i,j,k;
    //初始化
    for(i=0; i&lt;Graph-&gt;Nv; i++)
        for(j=0; j&lt;Graph-&gt;Nv; j++)
            D[i][j] = Graph-&gt;G[i][j];

    for(k = 0; k &lt; Graph-&gt;Nv; ++k){
        for(i = 0; i &lt; Graph-&gt;Nv; ++i){
            for(j = 0; j &lt; Graph-&gt;Nv; ++j){
                if(D[i][k] + D[k][j] &lt; D[i][j]){
                    D[i][j] = D[i][k] + D[k][j];
                }
            }
        }
    }
}

WeightType FindMaxDist(WeightType D[MaxVertexNum][MaxVertexNum], Vertex i, int N)
{
    WeightType MaxDist = 0;
    for(Vertex j=0; j&lt;N; j++)
    {
        if(i!=j &amp;&amp; D[i][j]&gt;MaxDist)
            MaxDist = D[i][j];
    }
    return MaxDist;
}

void FindAnimal(MGraph Graph)
{
    WeightType D[MaxVertexNum][MaxVertexNum], MaxDist, MinDist;
    Vertex Animal, i;

    Floyd(Graph, D);
    MinDist = INFINITY;
    for(i=0; i&lt;Graph-&gt;Nv; i++)
    {
        MaxDist = FindMaxDist(D, i, Graph-&gt;Nv);
        if(MaxDist == INFINITY)
        {
            printf(&quot;0\n&quot;);
            return;
        }
        if(MaxDist &lt; MinDist)
        {
            MinDist = MaxDist;
            Animal = i + 1;
        }
    }
    printf(&quot;%d %d\n&quot;, Animal, MinDist);

}

int main()
{
    MGraph Graph = BuildGraph();
    FindAnimal(Graph);
    return 0;
}
</code></pre>
<p>注意：Floyd算法中的三重循环顺序不能更改，写成下面这样就无法通过部分测试用例。</p>
<pre><code class="language-c">for(i=0; i&lt;Graph-&gt;Nv; i++)
    {
        for(j=0; j&lt;Graph-&gt;Nv; j++)
        {
            for(k=0; k&lt;Graph-&gt;Nv; k++)
            {
                if(D[i][k] + D[k][j] &lt; D[i][j])
                {
                    D[i][j] = D[i][k] + D[k][j];
                }
            }
        }
</code></pre>
<h2 id="pta-07-图5-saving-james-bond---hard-version"><a class="header" href="#pta-07-图5-saving-james-bond---hard-version">PTA 07-图5 Saving James Bond - Hard Version</a></h2>
<p>This time let us consider the situation in the movie &quot;Live and Let Die&quot; in which James Bond, the world's most famous spy, was captured by a group of drug dealers. He was sent to a small piece of land at the center of a lake filled with crocodiles. There he performed the most daring action to escape -- he jumped onto the head of the nearest crocodile! Before the animal realized what was happening, James jumped again onto the next big head... Finally he reached the bank before the last crocodile could bite him (actually the stunt man was caught by the big mouth and barely escaped with his extra thick boot).</p>
<p>Assume that the lake is a 100 by 100 square one. Assume that the center of the lake is at (0,0) and the northeast corner at (50,50). The central island is a disk centered at (0,0) with the diameter of 15. A number of crocodiles are in the lake at various positions. Given the coordinates of each crocodile and the distance that James could jump, you must tell him a shortest path to reach one of the banks. The length of a path is the number of jumps that James has to make.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. Each case starts with a line containing two positive integers N (≤100), the number of crocodiles, and D, the maximum distance that James could jump. Then N lines follow, each containing the (x,y) location of a crocodile. Note that no two crocodiles are staying at the same position.</p>
<p>Output Specification:</p>
<p>For each test case, if James can escape, output in one line the minimum number of jumps he must make. Then starting from the next line, output the position (x,y) of each crocodile on the path, each pair in one line, from the island to the bank. If it is impossible for James to escape that way, simply give him 0 as the number of jumps. If there are many shortest paths, just output the one with the minimum first jump, which is guaranteed to be unique.</p>
<p>Sample Input 1:</p>
<pre><code>17 15
10 -21
10 21
-40 10
30 -50
20 40
35 10
0 -10
-25 22
40 -40
-30 30
-10 22
0 11
25 21
25 10
10 10
10 35
-30 10
</code></pre>
<p>Sample Output 1:</p>
<pre><code class="language-out">4
0 11
10 21
10 35
</code></pre>
<p>Sample Input 2:</p>
<pre><code>4 13
-12 12
12 12
-12 -12
12 -12
</code></pre>
<p>Sample Output 2:</p>
<pre><code>0
</code></pre>
<p>思路：</p>
<p>单源无权图最短路径问题</p>
<p>我们可以看到 If there are many shortest paths, just output the one with the minimum first jump, which is guaranteed to be unique.（当有多条最短路时，输出第一跳最小的最短路） 首先需要对图中的相关顶点（鳄鱼坐标），按第一跳的距离从小到大排序。</p>
<p>从岛中心开始进行BFS，按第一跳从小到大的顺序收入顶点，在遍历顶点的过程中，实时记录各顶点到源点的距离(dist数组) 以及当前顶点的前一跳顶点(path数组)，这样才能满足题目的输出要求。</p>
<pre><code class="language-c">

</code></pre>
<h2 id="pta-07-图6-旅游规划"><a class="header" href="#pta-07-图6-旅游规划">PTA 07-图6 旅游规划</a></h2>
<p>有了一张自驾旅游路线图，你会知道城市间的高速公路长度、以及该公路要收取的过路费。现在需要你写一个程序，帮助前来咨询的游客找一条出发地和目的地之间的最短路径。如果有若干条路径都是最短的，那么需要输出最便宜的一条路径。</p>
<p>输入格式:</p>
<p>输入说明：输入数据的第1行给出4个正整数N、M、S、D，其中N（2≤N≤500）是城市的个数，顺便假设城市的编号为0~(N−1)；M是高速公路的条数；S是出发地的城市编号；D是目的地的城市编号。随后的M行中，每行给出一条高速公路的信息，分别是：城市1、城市2、高速公路长度、收费额，中间用空格分开，数字均为整数且不超过500。输入保证解的存在。</p>
<p>输出格式:</p>
<p>在一行里输出路径的长度和收费总额，数字间以空格分隔，输出结尾不能有多余空格。</p>
<p>输入样例:</p>
<pre><code>4 5 0 3
0 1 1 20
1 3 2 30
0 3 4 10
0 2 2 20
2 3 1 20
</code></pre>
<p>输出样例:</p>
<pre><code>3 40
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312141442435.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312141443891.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312141443188.png" alt="" /></p>
<pre><code class="language-c">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
class vertexNode{
public:
    int s;//源城市
    int d;//目的城市
    int weight;//路程长 权值
    int charge;//收费
    vertexNode()=default;
    vertexNode(int s_,int d_,int w_,int c_):s{s_},d{d_},weight{w_},charge{c_}{};
};
class AdjacencyLinkGraphic{
public:
    vector&lt;vector&lt;vertexNode*&gt;&gt; vertexs;//二维数组, 存的值是结点 包含该点的路径和收费 vertexs[i][j] i是起点 j是终点
    int cityNum{0};
    int highwayNum{0};
    int s;//出发城市
    int d;//目的城市
    AdjacencyLinkGraphic()=default;
    AdjacencyLinkGraphic(int n_,int m_,int s_,int d_):cityNum{n_},highwayNum{m_},s{s_},d{d_}{};
    void build(){
        vertexs=vector&lt;vector&lt;vertexNode*&gt;&gt;(cityNum,vector&lt;vertexNode*&gt;(cityNum,nullptr));
        int s,d,w,c;
        for(int i=0;i&lt;highwayNum;i++){
            scanf(&quot;%d %d %d %d&quot;,&amp;s,&amp;d,&amp;w,&amp;c);
            vertexs[s][d]=new vertexNode{s,d,w,c};
            vertexs[d][s]=new vertexNode{d,s,w,c};
        }
    }
    void dijkstra(){
        vector&lt;int&gt; visited(cityNum);
        visited[s]=1;
        int u;//起点 的 未访问的 最小权值的 邻接点
        // 先将s的访问位置为1,
        // 1.找到u 然后将u的访问位置为1
        // 2.先由起点的最小权值邻接点 u 开始, 寻找起点s 经由 u 到u的邻接点 j 的总权值是否小于 s到j的权值
        // 3.如果经由 s 经由 u 到 j 的的路径权值小于s到j的权值 ,就更新s到j的权值为 (s到u的权值)+(u到j的权值)
        // 循环直到s的邻接点全部遍历完毕,这时就得到了s到任意连通点的最小路径长 和 对应的收费
        //直接输出 vertexs[s][d]的路径长 和 收费
        for(int i=0;i&lt;cityNum;i++){
            int min=999999;
            for(int j=0;j&lt;cityNum;j++){
                if( vertexs[s][j] &amp;&amp; !visited[j] &amp;&amp; vertexs[s][j]-&gt;weight &lt; min){
                    min=  vertexs[s][j]-&gt;weight;
                    u = j;
                }
            }
            visited[u]=1;
            for(int j=0; j&lt;cityNum; j++){
                if( vertexs[u][j] &amp;&amp; vertexs[u][j]-&gt;weight &lt;= 99999 ){
                    if( vertexs[u][j] &amp;&amp; vertexs[s][u] &amp;&amp; vertexs[s][j] ){//确认为连通点
                        if(vertexs[s][j]-&gt;weight == vertexs[s][u]-&gt;weight + vertexs[u][j]-&gt;weight){
                            if(vertexs[s][j]-&gt;charge &gt; vertexs[s][u]-&gt;charge + vertexs[u][j]-&gt;charge)
                            vertexs[s][j]-&gt;charge=vertexs[s][u]-&gt;charge+vertexs[u][j]-&gt;charge;
                        }else if(vertexs[s][j]-&gt;weight &gt; vertexs[s][u]-&gt;weight + vertexs[u][j]-&gt;weight){
                            //更新由s到j的最小权值和对应的路费
                            vertexs[s][j]-&gt;weight = vertexs[s][u]-&gt;weight + vertexs[u][j]-&gt;weight;
                            vertexs[s][j]-&gt;charge = vertexs[s][u]-&gt;charge + vertexs[u][j]-&gt;charge;
                        }
                    }
                }
            }
        }
        cout &lt;&lt; vertexs[s][d]-&gt;weight &lt;&lt;&quot; &quot;&lt;&lt; vertexs[s][d]-&gt;charge&lt;&lt;endl;
    }
};
int main(){
    int n,m,s,d;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; d ;
    AdjacencyLinkGraphic ALG{n,m,s,d};
    ALG.build();
    ALG.dijkstra();
    return 0;
}
</code></pre>
<p>注：下面是我自己写的，只通过了第一个测试样例，过几天考完试接着搞！！</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

#define MaxVertexNum 10000
#define INFINITY 65535
#define INT_MAX 65535
int visited[MaxVertexNum];
int dist[MaxVertexNum];
int path[MaxVertexNum];
int cost[MaxVertexNum];

typedef int Vertex;
typedef int WeightType;

typedef struct ENode *PtrToENode;
struct ENode
{
    Vertex V1;
    Vertex V2;
    WeightType Weight;
    WeightType Charge;
};
typedef PtrToENode Edge;

typedef struct GNode *PtrToGNode;
struct GNode
{
    int Nv;
    int Ne;
    WeightType G[MaxVertexNum][MaxVertexNum];
    WeightType Cost[MaxVertexNum][MaxVertexNum];
};
typedef PtrToGNode MGraph;

MGraph CreateGraph(int VertexNum)
{
    MGraph Graph = (MGraph)malloc(sizeof(struct GNode));
    Graph-&gt;Nv = VertexNum;
    Graph-&gt;Ne = 0;
    for(Vertex V1=0; V1&lt;Graph-&gt;Nv; V1++)
        for(Vertex V2=0; V2&lt;Graph-&gt;Nv; V2++)
        {
            Graph-&gt;G[V1][V2] = 0;
            Graph-&gt;Cost[V1][V2] = 0;
        }

    return Graph;
}

void InsertEdge(MGraph Graph, Edge E)
{
    Graph-&gt;G[E-&gt;V1][E-&gt;V2] = E-&gt;Weight;
    Graph-&gt;Cost[E-&gt;V1][E-&gt;V2] = E-&gt;Charge;
}

void ResetVisited()
{
    for(int i=0; i&lt;MaxVertexNum; i++)
        visited[i] = 0;
}

void Dijkstra(MGraph Graph, Vertex V, Vertex dest)
{
    ResetVisited();
    for(int i=0; i&lt;Graph-&gt;Nv; i++)
    {
        if(Graph-&gt;G[V][i]&gt;0 &amp;&amp; V!=i)
        {
            dist[i] = Graph-&gt;G[V][i];
            path[i] = V;
            cost[i] = Graph-&gt;Cost[V][i];
        }
        else
        {
            dist[i] = INFINITY;
            path[i] = -1;
            cost[i] = 0;
        }
    }
    dist[V] = 0;
    path[V] = V;
    cost[V] = 0;
    visited[V] = 1;
    for(int i=1; i&lt;Graph-&gt;Nv; i++)
    {
        int minDist = INT_MAX;
        int index;
        for(int j=0; j&lt;Graph-&gt;Nv; j++)
        {
            if(visited[j]==0 &amp;&amp; dist[j]&lt;minDist)
            {
                minDist = dist[j];
                index = j;
            }
        }
        visited[index] = 1;
        for(int k=0; k&lt;Graph-&gt;Nv; k++)
        {
            if(visited[k]==0)
            {
                if(Graph-&gt;G[index][k]&gt;0 &amp;&amp; minDist+Graph-&gt;G[index][k]&lt;dist[k])
                {
                    dist[k] = minDist+Graph-&gt;G[index][k];
                    path[k] = index;
                    cost[k] = cost[index] + Graph-&gt;Cost[index][k];
                }
                else if(Graph-&gt;G[index][k]&gt;0 &amp;&amp; minDist+Graph-&gt;G[index][k]==dist[k] &amp;&amp; cost[V] + Graph-&gt;Cost[index][k]&lt;cost[k])
                {
                    cost[k] = cost[index] +  Graph-&gt;Cost[index][k];
                }

            }

        }
    }
    printf(&quot;%d %d\n&quot;,dist[dest],cost[dest]);

}

int main()
{
    int Nv;
    Edge E;
    scanf(&quot;%d&quot;, &amp;Nv);
    MGraph Graph = CreateGraph(Nv);
    scanf(&quot;%d&quot;, &amp;(Graph-&gt;Ne));
    int src, dest;
    scanf(&quot;%d %d&quot;,&amp;src,&amp;dest);
    int fee;
    if((Graph-&gt;Ne) != 0)
    {
        E = (Edge)malloc(sizeof(struct ENode));
        for(int i=0; i&lt;Graph-&gt;Ne; i++)
        {
            scanf(&quot;%d %d %d %d&quot;,&amp;E-&gt;V1,&amp;E-&gt;V2,&amp;E-&gt;Weight,&amp;E-&gt;Charge);
            InsertEdge(Graph, E);
        }
    }
    Dijkstra(Graph, src, dest);
    return 0;
}



</code></pre>
<h2 id="pta-08-图7-公路村村通"><a class="header" href="#pta-08-图7-公路村村通">PTA 08-图7 公路村村通</a></h2>
<p>现有村落间道路的统计数据表中，列出了有可能建设成标准公路的若干条道路的成本，求使每个村落都有公路连通所需要的最低成本。</p>
<p>输入格式:</p>
<p>输入数据包括城镇数目正整数N（≤1000）和候选道路数目M（≤3N）；随后的M行对应M条道路，每行给出3个正整数，分别是该条道路直接连通的两个城镇的编号以及该道路改建的预算成本。为简单起见，城镇从1到N编号。</p>
<p>输出格式:</p>
<p>输出村村通需要的最低成本。如果输入数据不足以保证畅通，则输出−1，表示需要建设更多公路。</p>
<p>输入样例:</p>
<pre><code>6 15
1 2 5
1 3 3
1 4 7
1 5 4
1 6 2
2 3 4
2 4 6
2 5 2
2 6 6
3 4 6
3 5 1
3 6 1
4 5 10
4 6 8
5 6 3
</code></pre>
<p>输出样例:</p>
<pre><code class="language-out">12
</code></pre>
<pre><code class="language-c">

</code></pre>
<h2 id="pta-08-图8-how-long-does-it-take"><a class="header" href="#pta-08-图8-how-long-does-it-take">PTA 08-图8 How Long Does It Take</a></h2>
<p>Given the relations of all the activities of a project, you are supposed to find the earliest completion time of the project.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. Each case starts with a line containing two positive integers N (≤100), the number of activity check points (hence it is assumed that the check points are numbered from 0 to N−1), and M, the number of activities. Then M lines follow, each gives the description of an activity. For the <code>i</code>-th activity, three non-negative numbers are given: <code>S[i]</code>, <code>E[i]</code>, and <code>L[i]</code>, where <code>S[i]</code> is the index of the starting check point, <code>E[i]</code> of the ending check point, and <code>L[i]</code> the lasting time of the activity. The numbers in a line are separated by a space.</p>
<p>Output Specification:</p>
<p>For each test case, if the scheduling is possible, print in a line its earliest completion time; or simply output &quot;Impossible&quot;.</p>
<p>Sample Input 1:</p>
<pre><code>9 12
0 1 6
0 2 4
0 3 5
1 4 1
2 4 1
3 5 2
5 4 0
4 6 9
4 7 7
5 7 4
6 8 2
7 8 4
</code></pre>
<p>Sample Output 1:</p>
<pre><code class="language-out">18
</code></pre>
<p>Sample Input 2:</p>
<pre><code>4 5
0 1 1
0 2 2
2 1 3
1 3 4
3 2 5
</code></pre>
<p>Sample Output 2:</p>
<pre><code>Impossible
</code></pre>
<pre><code class="language-c">
</code></pre>
<h2 id="pta-08-图9-关键活动"><a class="header" href="#pta-08-图9-关键活动">PTA 08-图9 关键活动</a></h2>
<p>假定一个工程项目由一组子任务构成，子任务之间有的可以并行执行，有的必须在完成了其它一些子任务后才能执行。“任务调度”包括一组子任务、以及每个子任务可以执行所依赖的子任务集。</p>
<p>比如完成一个专业的所有课程学习和毕业设计可以看成一个本科生要完成的一项工程，各门课程可以看成是子任务。有些课程可以同时开设，比如英语和C程序设计，它们没有必须先修哪门的约束；有些课程则不可以同时开设，因为它们有先后的依赖关系，比如C程序设计和数据结构两门课，必须先学习前者。</p>
<p>但是需要注意的是，对一组子任务，并不是任意的任务调度都是一个可行的方案。比如方案中存在“子任务A依赖于子任务B，子任务B依赖于子任务C，子任务C又依赖于子任务A”，那么这三个任务哪个都不能先执行，这就是一个不可行的方案。</p>
<p>任务调度问题中，如果还给出了完成每个子任务需要的时间，则我们可以算出完成整个工程需要的最短时间。在这些子任务中，有些任务即使推迟几天完成，也不会影响全局的工期；但是有些任务必须准时完成，否则整个项目的工期就要因此延误，这种任务就叫“关键活动”。</p>
<p>请编写程序判定一个给定的工程项目的任务调度是否可行；如果该调度方案可行，则计算完成整个工程项目需要的最短时间，并输出所有的关键活动。</p>
<p>输入格式:</p>
<p>输入第1行给出两个正整数N(≤100)和M，其中N是任务交接点（即衔接相互依赖的两个子任务的节点，例如：若任务2要在任务1完成后才开始，则两任务之间必有一个交接点）的数量。交接点按1~N编号，M是子任务的数量，依次编号为1~M。随后M行，每行给出了3个正整数，分别是该任务开始和完成涉及的交接点编号以及该任务所需的时间，整数间用空格分隔。</p>
<p>输出格式:</p>
<p>如果任务调度不可行，则输出0；否则第1行输出完成整个工程项目需要的时间，第2行开始输出所有关键活动，每个关键活动占一行，按格式“V-&gt;W”输出，其中V和W为该任务开始和完成涉及的交接点编号。关键活动输出的顺序规则是：任务开始的交接点编号小者优先，起点编号相同时，与输入时任务的顺序相反。</p>
<p>输入样例:</p>
<pre><code>7 8
1 2 4
1 3 3
2 4 5
3 4 3
4 5 1
4 6 6
5 7 5
6 7 2
</code></pre>
<p>输出样例:</p>
<pre><code>17
1-&gt;2
2-&gt;4
4-&gt;6
6-&gt;7
</code></pre>
<pre><code class="language-c">


</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="排序算法"><a class="header" href="#排序算法">排序算法</a></h1>
<ul>
<li><a href="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">选择排序</a></li>
<li><a href="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序</a></li>
</ul>
<h2 id="选择排序"><a class="header" href="#选择排序">选择排序</a></h2>
<ul>
<li>从所有元素中找到最小的元素放到数组的第0个位置</li>
<li>从剩余元素中找出最小的放到第1个位置，以此类推，直到所有元素都放到了适当的位置</li>
</ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main() {

    int lh,rh,k,tmp;
    int array[]={2,5,1,9,10,0,4,8,7,6};
    for(lh=0;lh&lt;10;lh++)
    {
        rh=lh;
        for(k=lh;k&lt;10;++k)
            if(array[k]&lt;array[rh])
                rh=k;
        tmp=array[lh];
        array[lh]=array[rh];
        array[rh]=tmp;
    }
    for(lh=0;lh&lt;10;lh++) cout&lt;&lt;array[lh]&lt;&lt;' ';

    return 0;
}
</code></pre>
<h2 id="冒泡排序"><a class="header" href="#冒泡排序">冒泡排序</a></h2>
<ul>
<li>大数沉淀、小数冒泡</li>
</ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main() {

    int i,j,tmp,n=10;
    int array[]={9,8,5,4,2,0,10,6,11,7};

    for(j=0;j&lt;n-1;j++)
        for(i=0;i&lt;n-1-j;i++)
            if(array[i]&gt;array[i+1])
            {
                tmp=array[i];
                array[i]=array[i+1];
                array[i+1]=tmp;
            }
    cout&lt;&lt;endl;

    for(i=0;i&lt;n;i++) cout&lt;&lt;array[i]&lt;&lt;' ';

    return 0;
}
</code></pre>
<p>改进版：增加一个标志变量，若数组已排好序，则只用扫描一遍</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main() {

    int i,j,tmp,n=10;
    bool flag;
    int array[]={9,8,5,4,2,0,10,6,11,7};

    for(j=0;j&lt;n-1;j++){
        flag=false;
        for(i=0;i&lt;n-1-j;i++)
            if(array[i]&gt;array[i+1])
            {
                tmp=array[i];
                array[i]=array[i+1];
                array[i+1]=tmp;
                flag=true;
            }
        if(!flag) break;
    }
    cout&lt;&lt;endl;

    for(i=0;i&lt;n;i++) cout&lt;&lt;array[i]&lt;&lt;' ';

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="mooc-pta排序题目"><a class="header" href="#mooc-pta排序题目">MOOC-PTA排序题目</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="查找算法"><a class="header" href="#查找算法">查找算法</a></h1>
<ul>
<li><a href="%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.html#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE">顺序查找</a></li>
<li><a href="%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.html#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">二分查找</a></li>
</ul>
<h2 id="顺序查找"><a class="header" href="#顺序查找">顺序查找</a></h2>
<ul>
<li>被查找的数存放在一个数组中</li>
<li>从数组的第一个元素开始，依次往下比较，直到找到要找的元素为止</li>
</ul>
<p>下面程序能在一整数数组中查找元素x的存储位置</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main() {

    int k,x;
    int array[]={2,3,1,7,5,8,9,0,4,6};
    cout&lt;&lt;&quot;输入要查找的元素值：&quot;;
    cin&gt;&gt;x;
    for(k=0;k&lt;10;k++)
    {
        if(x==array[k])
        {
            cout&lt;&lt;k;
            break;
        }
    }
    if(k==10) cout&lt;&lt;&quot;not found&quot;;
    return 0;
}
</code></pre>
<h2 id="二分查找"><a class="header" href="#二分查找">二分查找</a></h2>
<p>前提：数组已排序</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main() {

    int x;
    int array[]={5,13,19,21,37,56,64,74,80,88,92};
    int high,low,mid;
    cout&lt;&lt;&quot;输入要查找的元素值：&quot;;
    cin&gt;&gt;x;
    low=0;
    high=10;

    while(low&lt;=high)
    {
        mid=(high-low)/2+low;
        if(x==array[mid])
        {
            cout&lt;&lt;x&lt;&lt;&quot;的位置是：&quot;&lt;&lt;mid&lt;&lt;endl;
            break;
        }
        if(x&lt;array[mid]) high=mid-1;
        else low=mid+1;
    }
    if(low&gt;high) cout&lt;&lt;&quot;找不到&quot;&lt;&lt;x&lt;&lt;endl;

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="mooc-pta查找题目"><a class="header" href="#mooc-pta查找题目">MOOC-PTA查找题目</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
