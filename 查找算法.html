<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>查找算法 - 资料结构与演算法</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="弁言.html"><strong aria-hidden="true">1.</strong> 弁言</a></li><li class="chapter-item expanded "><a href="数据结构与算法概论.html"><strong aria-hidden="true">2.</strong> 数据结构与算法概论</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="主定理.html"><strong aria-hidden="true">2.1.</strong> 主定理</a></li><li class="chapter-item expanded "><a href="MOOC-PTA复杂度题目.html"><strong aria-hidden="true">2.2.</strong> MOOC-PTA复杂度题目</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Data Structure</li><li class="chapter-item expanded "><a href="线性结构.html"><strong aria-hidden="true">3.</strong> 线性结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="线性表.html"><strong aria-hidden="true">3.1.</strong> 线性表</a></li><li class="chapter-item expanded "><a href="栈.html"><strong aria-hidden="true">3.2.</strong> 栈</a></li><li class="chapter-item expanded "><a href="队列.html"><strong aria-hidden="true">3.3.</strong> 队列</a></li><li class="chapter-item expanded "><a href="MOOC-PTA线性结构题目.html"><strong aria-hidden="true">3.4.</strong> MOOC-PTA线性结构题目</a></li></ol></li><li class="chapter-item expanded "><a href="树.html"><strong aria-hidden="true">4.</strong> 树</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="二叉树.html"><strong aria-hidden="true">4.1.</strong> 二叉树</a></li><li class="chapter-item expanded "><a href="二叉搜索树.html"><strong aria-hidden="true">4.2.</strong> 二叉搜索树</a></li><li class="chapter-item expanded "><a href="平衡二叉树.html"><strong aria-hidden="true">4.3.</strong> 平衡二叉树</a></li><li class="chapter-item expanded "><a href="堆.html"><strong aria-hidden="true">4.4.</strong> 堆</a></li><li class="chapter-item expanded "><a href="哈夫曼树.html"><strong aria-hidden="true">4.5.</strong> 哈夫曼树</a></li><li class="chapter-item expanded "><a href="并查集.html"><strong aria-hidden="true">4.6.</strong> 并查集</a></li><li class="chapter-item expanded "><a href="MOOC-PTA树题目.html"><strong aria-hidden="true">4.7.</strong> MOOC-PTA树题目</a></li></ol></li><li class="chapter-item expanded "><a href="图.html"><strong aria-hidden="true">5.</strong> 图</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="图的存储.html"><strong aria-hidden="true">5.1.</strong> 图的存储</a></li><li class="chapter-item expanded "><a href="图的遍历.html"><strong aria-hidden="true">5.2.</strong> 图的遍历</a></li><li class="chapter-item expanded "><a href="最短路径算法.html"><strong aria-hidden="true">5.3.</strong> 最短路径算法</a></li><li class="chapter-item expanded "><a href="最小生成树算法.html"><strong aria-hidden="true">5.4.</strong> 最小生成树算法</a></li><li class="chapter-item expanded "><a href="拓扑排序和关键路径.html"><strong aria-hidden="true">5.5.</strong> 拓扑排序和关键路径</a></li><li class="chapter-item expanded "><a href="MOOC-PTA图题目.html"><strong aria-hidden="true">5.6.</strong> MOOC-PTA图题目</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Algorithm Analysis & Design</li><li class="chapter-item expanded "><a href="排序算法.html"><strong aria-hidden="true">6.</strong> 排序算法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="MOOC-PTA排序题目.html"><strong aria-hidden="true">6.1.</strong> MOOC-PTA排序题目</a></li></ol></li><li class="chapter-item expanded "><a href="查找算法.html" class="active"><strong aria-hidden="true">7.</strong> 查找算法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="MOOC-PTA查找题目.html"><strong aria-hidden="true">7.1.</strong> MOOC-PTA查找题目</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">资料结构与演算法</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="查找算法"><a class="header" href="#查找算法">查找算法</a></h1>
<ul>
<li><a href="#%E6%99%AE%E9%80%9A%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95">普通查找算法</a>
<ul>
<li><a href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE">顺序查找</a></li>
<li><a href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">二分查找</a></li>
</ul>
</li>
<li><a href="#%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE">散列查找</a>
<ul>
<li><a href="#%E6%95%A3%E5%88%97%E8%A1%A8">散列表</a></li>
<li><a href="#%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">散列函数的构造方法</a>
<ul>
<li><a href="#%E6%95%B0%E5%AD%97%E5%85%B3%E9%94%AE%E8%AF%8D%E7%9A%84%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E6%9E%84%E9%80%A0">数字关键词的散列函数构造</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%85%B3%E9%94%AE%E8%AF%8D%E7%9A%84%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E6%9E%84%E9%80%A0">字符串关键词的散列函数构造</a></li>
</ul>
</li>
<li><a href="#%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95">冲突处理方法</a>
<ul>
<li><a href="#%E5%BC%80%E6%94%BE%E5%AE%9A%E5%9D%80%E6%B3%95">开放定址法</a></li>
<li><a href="#%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B">线性探测</a></li>
<li><a href="#%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BE%8B%E5%AD%90">线性探测—字符串的例子</a></li>
<li><a href="#%E5%B9%B3%E6%96%B9%E6%8E%A2%E6%B5%8B%E6%B3%95">平方探测法</a></li>
<li><a href="#%E5%B9%B3%E6%96%B9%E6%8E%A2%E6%B5%8B%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0">平方探测法的实现</a></li>
<li><a href="#%E5%88%86%E7%A6%BB%E9%93%BE%E6%8E%A5%E6%B3%95">分离链接法</a></li>
</ul>
</li>
<li><a href="#%E6%95%A3%E5%88%97%E8%A1%A8%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90">散列表的性能分析</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84%E7%9A%84%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AE%9E%E7%8E%B0">基于数组的哈希表实现</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AE%9E%E7%8E%B0">基于链表的哈希表实现</a></li>
<li><a href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B%E7%BB%9F%E8%AE%A1%E8%AF%8D%E9%A2%91">哈希表应用实例：统计词频</a></li>
</ul>
</li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D">字符串匹配</a>
<ul>
<li><a href="#%E6%99%AE%E9%80%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%AE%9E%E7%8E%B0">普通字符串匹配实现</a></li>
<li><a href="#kmp%E7%AE%97%E6%B3%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D">KMP算法——字符串匹配</a>
<ul>
<li><a href="#%E5%AE%9E%E4%BE%8Bpta-kmp-%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D">实例：PTA KMP 串的模式匹配</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="普通查找算法"><a class="header" href="#普通查找算法">普通查找算法</a></h1>
<h2 id="顺序查找"><a class="header" href="#顺序查找">顺序查找</a></h2>
<ul>
<li>被查找的数存放在一个数组中</li>
<li>从数组的第一个元素开始，依次往下比较，直到找到要找的元素为止</li>
</ul>
<p>下面程序能在一整数数组中查找元素x的存储位置</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main() {

    int k,x;
    int array[]={2,3,1,7,5,8,9,0,4,6};
    cout&lt;&lt;"输入要查找的元素值：";
    cin&gt;&gt;x;
    for(k=0;k&lt;10;k++)
    {
        if(x==array[k])
        {
            cout&lt;&lt;k;
            break;
        }
    }
    if(k==10) cout&lt;&lt;"not found";
    return 0;
}
</code></pre>
<h2 id="二分查找"><a class="header" href="#二分查找">二分查找</a></h2>
<p>前提：数组已排序</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main() {

    int x;
    int array[]={5,13,19,21,37,56,64,74,80,88,92};
    int high,low,mid;
    cout&lt;&lt;"输入要查找的元素值：";
    cin&gt;&gt;x;
    low=0;
    high=10;

    while(low&lt;=high)
    {
        mid=(high-low)/2+low;
        if(x==array[mid])
        {
            cout&lt;&lt;x&lt;&lt;"的位置是："&lt;&lt;mid&lt;&lt;endl;
            break;
        }
        if(x&lt;array[mid]) high=mid-1;
        else low=mid+1;
    }
    if(low&gt;high) cout&lt;&lt;"找不到"&lt;&lt;x&lt;&lt;endl;

    return 0;
}
</code></pre>
<h1 id="散列查找"><a class="header" href="#散列查找">散列查找</a></h1>
<h2 id="散列表"><a class="header" href="#散列表">散列表</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061500055.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061501172.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061502931.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061502696.png" alt="" /></p>
<p>哈希是一种数据按照特定关系存储的存储结构</p>
<p>哈希函数：值与地址的特定关系</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061503876.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061503348.png" alt="" /></p>
<h2 id="散列函数的构造方法"><a class="header" href="#散列函数的构造方法">散列函数的构造方法</a></h2>
<h3 id="数字关键词的散列函数构造"><a class="header" href="#数字关键词的散列函数构造">数字关键词的散列函数构造</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061512060.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061512803.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061513372.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061513532.png" alt="" /></p>
<h3 id="字符串关键词的散列函数构造"><a class="header" href="#字符串关键词的散列函数构造">字符串关键词的散列函数构造</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061514023.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061514920.png" alt="" /></p>
<p>如果直接计算<code>'a'*32^4+'b'*32^3+'c'*32^2+'d'*32+'e'</code>所需要的乘法总次数是4+3+2+1=10次。</p>
<p>采用<code> ((('a'*32+'b')*32+'c')*32+'d')*32+'e'</code>的计算方法，乘法总次数是多少？</p>
<p>（顺便思考一下两者时间效率的差别）</p>
<p>正确答案：4</p>
<h2 id="冲突处理方法"><a class="header" href="#冲突处理方法">冲突处理方法</a></h2>
<h3 id="开放定址法"><a class="header" href="#开放定址法">开放定址法</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061522677.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061524430.png" alt="" /></p>
<p>开放地址法代码：</p>
<pre><code class="language-c">#define MAXTABLESIZE 100000 /* 允许开辟的最大散列表长度 */
typedef int ElementType;    /* 关键词类型用整型 */
typedef int Index;          /* 散列地址类型 */
typedef Index Position;     /* 数据所在位置与散列地址是同一类型 */
/* 散列单元状态类型，分别对应：有合法元素、空单元、有已删除元素 */
typedef enum { Legitimate, Empty, Deleted } EntryType;

typedef struct HashEntry Cell; /* 散列表单元类型 */
struct HashEntry{
    ElementType Data; /* 存放元素 */
    EntryType Info;   /* 单元状态 */
};

typedef struct TblNode *HashTable; /* 散列表类型 */
struct TblNode {   /* 散列表结点定义 */
    int TableSize; /* 表的最大长度 */
    Cell *Cells;   /* 存放散列单元数据的数组 */
};

int NextPrime( int N )
{ /* 返回大于N且不超过MAXTABLESIZE的最小素数 */
    int i, p = (N%2)? N+2 : N+1; /*从大于N的下一个奇数开始 */

    while( p &lt;= MAXTABLESIZE ) {
        for( i=(int)sqrt(p); i&gt;2; i-- )
            if ( !(p%i) ) break; /* p不是素数 */
        if ( i==2 ) break; /* for正常结束，说明p是素数 */
        else  p += 2; /* 否则试探下一个奇数 */
    }
    return p;
}

HashTable CreateTable( int TableSize )
{
    HashTable H;
    int i;

    H = (HashTable)malloc(sizeof(struct TblNode));
    /* 保证散列表最大长度是素数 */
    H-&gt;TableSize = NextPrime(TableSize);
    /* 声明单元数组 */
    H-&gt;Cells = (Cell *)malloc(H-&gt;TableSize*sizeof(Cell));
    /* 初始化单元状态为“空单元” */
    for( i=0; i&lt;H-&gt;TableSize; i++ )
        H-&gt;Cells[i].Info = Empty;

    return H;
}
</code></pre>
<h3 id="线性探测"><a class="header" href="#线性探测">线性探测</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061525833.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061526052.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061526360.png" alt="" /></p>
<h3 id="线性探测字符串的例子"><a class="header" href="#线性探测字符串的例子">线性探测—字符串的例子</a></h3>
<p>与例子相似,如果已知散列表的前8个位置有元素(但元素内容与例子不一样）而且后面18个位置也全是空位,那么平均不成功查找次数还是一样的.</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061527687.png" alt="" /></p>
<h3 id="平方探测法"><a class="header" href="#平方探测法">平方探测法</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061527234.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061527483.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061528811.png" alt="" /></p>
<h3 id="平方探测法的实现"><a class="header" href="#平方探测法的实现">平方探测法的实现</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061529436.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061530199.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061530343.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061530753.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061531409.png" alt="" /></p>
<pre><code class="language-c">Position Find( HashTable H, ElementType Key )
{
    Position CurrentPos, NewPos;
    int CNum = 0; /* 记录冲突次数 */

    NewPos = CurrentPos = Hash( Key, H-&gt;TableSize ); /* 初始散列位置 */
    /* 当该位置的单元非空，并且不是要找的元素时，发生冲突 */
    while( H-&gt;Cells[NewPos].Info!=Empty &amp;&amp; H-&gt;Cells[NewPos].Data!=Key ) {
                                           /* 字符串类型的关键词需要 strcmp 函数!! */
        /* 统计1次冲突，并判断奇偶次 */
        if( ++CNum%2 ){ /* 奇数次冲突 */
            NewPos = CurrentPos + (CNum+1)*(CNum+1)/4; /* 增量为+[(CNum+1)/2]^2 */
            if ( NewPos &gt;= H-&gt;TableSize )
                NewPos = NewPos % H-&gt;TableSize; /* 调整为合法地址 */
        }
        else { /* 偶数次冲突 */
            NewPos = CurrentPos - CNum*CNum/4; /* 增量为-(CNum/2)^2 */
            while( NewPos &lt; 0 )
                NewPos += H-&gt;TableSize; /* 调整为合法地址 */
        }
    }
    return NewPos; /* 此时NewPos或者是Key的位置，或者是一个空单元的位置（表示找不到）*/
}

bool Insert( HashTable H, ElementType Key )
{
    Position Pos = Find( H, Key ); /* 先检查Key是否已经存在 */

    if( H-&gt;Cells[Pos].Info != Legitimate ) { /* 如果这个单元没有被占，说明Key可以插入在此 */
        H-&gt;Cells[Pos].Info = Legitimate;
        H-&gt;Cells[Pos].Data = Key;
        /*字符串类型的关键词需要 strcpy 函数!! */
        return true;
    }
    else {
        printf("键值已存在");
        return false;
    }
}
</code></pre>
<h3 id="分离链接法"><a class="header" href="#分离链接法">分离链接法</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061531434.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061532850.png" alt="" /></p>
<pre><code class="language-c">#define KEYLENGTH 15                   /* 关键词字符串的最大长度 */
typedef char ElementType[KEYLENGTH+1]; /* 关键词类型用字符串 */
typedef int Index;                     /* 散列地址类型 */
/******** 以下是单链表的定义 ********/
typedef struct LNode *PtrToLNode;
struct LNode {
    ElementType Data;
    PtrToLNode Next;
};
typedef PtrToLNode Position;
typedef PtrToLNode List;
/******** 以上是单链表的定义 ********/

typedef struct TblNode *HashTable; /* 散列表类型 */
struct TblNode {   /* 散列表结点定义 */
    int TableSize; /* 表的最大长度 */
    List Heads;    /* 指向链表头结点的数组 */
};

HashTable CreateTable( int TableSize )
{
    HashTable H;
    int i;

    H = (HashTable)malloc(sizeof(struct TblNode));
    /* 保证散列表最大长度是素数，具体见代码5.3 */
    H-&gt;TableSize = NextPrime(TableSize);

    /* 以下分配链表头结点数组 */
    H-&gt;Heads = (List)malloc(H-&gt;TableSize*sizeof(struct LNode));
    /* 初始化表头结点 */
    for( i=0; i&lt;H-&gt;TableSize; i++ ) {
         H-&gt;Heads[i].Data[0] = '\0';
         H-&gt;Heads[i].Next = NULL;
    }

    return H;
}

Position Find( HashTable H, ElementType Key )
{
    Position P;
    Index Pos;
    
    Pos = Hash( Key, H-&gt;TableSize ); /* 初始散列位置 */
    P = H-&gt;Heads[Pos].Next; /* 从该链表的第1个结点开始 */
    /* 当未到表尾，并且Key未找到时 */ 
    while( P &amp;&amp; strcmp(P-&gt;Data, Key) )
        P = P-&gt;Next;

    return P; /* 此时P或者指向找到的结点，或者为NULL */
}

bool Insert( HashTable H, ElementType Key )
{
    Position P, NewCell;
    Index Pos;
    
    P = Find( H, Key );
    if ( !P ) { /* 关键词未找到，可以插入 */
        NewCell = (Position)malloc(sizeof(struct LNode));
        strcpy(NewCell-&gt;Data, Key);
        Pos = Hash( Key, H-&gt;TableSize ); /* 初始散列位置 */
        /* 将NewCell插入为H-&gt;Heads[Pos]链表的第1个结点 */
        NewCell-&gt;Next = H-&gt;Heads[Pos].Next;
        H-&gt;Heads[Pos].Next = NewCell; 
        return true;
    }
    else { /* 关键词已存在 */
        printf("键值已存在");
        return false;
    }
}

void DestroyTable( HashTable H )
{
    int i;
    Position P, Tmp;
    
    /* 释放每个链表的结点 */
    for( i=0; i&lt;H-&gt;TableSize; i++ ) {
        P = H-&gt;Heads[i].Next;
        while( P ) {
            Tmp = P-&gt;Next;
            free( P );
            P = Tmp;
        }
    }
    free( H-&gt;Heads ); /* 释放头结点数组 */
    free( H );        /* 释放散列表结点 */
}
</code></pre>
<h2 id="散列表的性能分析"><a class="header" href="#散列表的性能分析">散列表的性能分析</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061546296.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061546465.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061547419.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061547056.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061547353.png" alt="" /></p>
<p>一个大小为11的散列表，散列函数为H(key)=key mod 11，采用线性探测冲突解决策略。如果现有散列表中仅有的5个元素均位于下标为奇数的位置，问：该散列表的平均不成功查找次数是多少？<br />
16/11</p>
<p>在一个大小为K的空散列表中，按照线性探测冲突解决策略连续插入散列值相同的N个元素（N&lt;K）。问：此时，该散列表的平均成功查找次数是多少？(N+1)/2</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061551478.png" alt="" /></p>
<p>当采用线性探测冲突解决策略时，非空且有空闲空间的散列表中无论有多少元素，不成功情况下的期望查找次数总是大于成功情况下的期望查找次数。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061548756.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061548330.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061549295.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312061549070.png" alt="" /></p>
<h2 id="基于数组的哈希表实现"><a class="header" href="#基于数组的哈希表实现">基于数组的哈希表实现</a></h2>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

typedef struct pair
{
    int key;
    char element[20];
}DATA, *LPDATA;

typedef struct hashTable
{
    int divisor;        //哈希表长度
    int curSize;        //当前元素个数
    LPDATA *table;      //用二级指针，便于初始化
}HASH, *LPHASH;

LPHASH createHash(int divisor)
{
    LPHASH pHash = (LPHASH)malloc(sizeof(struct hashTable));
    assert(pHash);
    pHash-&gt;divisor = divisor;
    pHash-&gt;curSize = 0;
    pHash-&gt;table = (LPDATA*)malloc(sizeof(LPDATA) * pHash-&gt;divisor);
    assert(pHash-&gt;table);
    for(int i=0; i &lt; pHash-&gt;divisor; i++)
    {
        pHash-&gt;table[i] = NULL;
    }
    return pHash;
}

int searchCorrectPos(LPHASH pHash, int key)
{
    int Pos = key % pHash-&gt;divisor;
    int curPos = Pos;
    do
    {
        if(pHash-&gt;table[curPos] == NULL || pHash-&gt;table[curPos]-&gt;key == key)
            return curPos;
        curPos = (curPos + 1) % pHash-&gt;divisor;
    }while(curPos != Pos);
    return curPos;
}

void insertHash(LPHASH pHash, DATA data)
{
    int pos = searchCorrectPos(pHash, data.key);
    if(pHash-&gt;table[pos] == NULL)
    {
        pHash-&gt;table[pos] = (LPDATA)malloc(sizeof(DATA));
        assert(pHash-&gt;table[pos]);
        memcpy(pHash-&gt;table[pos], &amp;data, sizeof(DATA));
        pHash-&gt;curSize++;
    }
    else
    {
        if(pHash-&gt;table[pos]-&gt;key == data.key)
        {
            strcpy(pHash-&gt;table[pos]-&gt;element, data.element);      //遇到冲突，覆盖相同key
        }
        else
        {
            printf("表满了，无法插入！\n");
            return;
        }
    }
}

void printHash(LPHASH pHash)
{
    for(int i=0; i&lt;pHash-&gt;divisor; i++)
    {
        if(pHash-&gt;table[i] == NULL)
        {
            printf("NULL\n");
        }
        else
        {
            printf("%d:%s\n",pHash-&gt;table[i]-&gt;key,pHash-&gt;table[i]-&gt;element);
        }
    }
}


int main()
{
    DATA array[3] = {29,"Young",35,"蓬蒿人",39,"哦哦哦"};
    LPHASH pHash = createHash(10);
    for(int i=0; i&lt;3; i++)
    {
        insertHash(pHash,array[i]);
    }
    printHash(pHash);
    return 0;
}
</code></pre>
<pre><code>39:哦哦哦
NULL
NULL
NULL
NULL
35:蓬蒿人
NULL
NULL
NULL
29:Young
</code></pre>
<h2 id="基于链表的哈希表实现"><a class="header" href="#基于链表的哈希表实现">基于链表的哈希表实现</a></h2>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

typedef struct pair
{
    int key;
    char element[20];
}DATA, *LPDATA;

typedef struct Node
{
    DATA data;
    struct Node *Next;
}NODE, *LPNODE;

LPNODE createNode(DATA data)
{
    LPNODE newNode = (LPNODE)malloc(sizeof(NODE));
    newNode-&gt;data = data;
    newNode-&gt;Next = NULL;
    return newNode;
}

typedef struct skipListNode
{
    DATA data;
    LPNODE fisrtNode;
    struct skipListNode *Next;
}SLNODE, *LPSLNODE;

LPSLNODE createSkipListNode(DATA data)
{
    LPSLNODE newNode = (LPSLNODE)malloc(sizeof(SLNODE));
    newNode-&gt;data = data;
    newNode-&gt;fisrtNode = NULL;
    newNode-&gt;Next = NULL;
    return newNode;
}

typedef struct Hash
{
    LPSLNODE headNode;
    int curSize;
    int divisor;
}HASH, *LPHASH;

LPHASH createHash(int divisor)
{
    LPHASH pHash = (LPHASH)malloc(sizeof(HASH));
    assert(pHash);
    pHash-&gt;curSize = 0;
    pHash-&gt;divisor = divisor;
    pHash-&gt;headNode = NULL;
    return pHash;
}

void insertHash(LPHASH pHash, DATA data)
{
    int dataHashPos = data.key % pHash-&gt;divisor;
    LPSLNODE newSkipNode = createSkipListNode(data);
    //第一次插入
    if(pHash-&gt;headNode == NULL)
    {
        pHash-&gt;headNode = newSkipNode;
        pHash-&gt;curSize++;
    }
    else
    {
        //纵向是要有序的
        LPSLNODE pMove = pHash-&gt;headNode;
        LPSLNODE prePmove = NULL;
        //表头元素的地址大于要插入元素的地址，用头插法
        if(pMove-&gt;data.key % pHash-&gt;divisor &gt; dataHashPos)
        {
            newSkipNode-&gt;Next = pHash-&gt;headNode;
            pHash-&gt;headNode = newSkipNode;
            pHash-&gt;curSize++;
        }
        else
        {
            //向下找
            while(pMove!=NULL &amp;&amp; pMove-&gt;data.key%pHash-&gt;divisor &lt; dataHashPos)
            {
                prePmove = pMove;
                pMove = prePmove-&gt;Next;
            }
            //结果：找到、没找到
            //找到的话，单独分析等于的情况，等于就是哈希冲突
            if(pMove!=NULL &amp;&amp; pMove-&gt;data.key%pHash-&gt;divisor == dataHashPos)
            {
                //相同键采用覆盖方式
                //不同键、相同哈希地址插入横向链表
                if(pMove-&gt;data.key == data.key)
                {
                    strcpy(pMove-&gt;data.element, data.element);
                }
                else
                {
                    LPNODE newNode = createNode(data);
                    LPNODE ppMove = pMove-&gt;fisrtNode;
                    //横向链表的插入
                    if(ppMove == NULL)
                    {
                        newNode-&gt;Next = pMove-&gt;fisrtNode;
                        pMove-&gt;fisrtNode = newNode;
                        pHash-&gt;curSize++;
                    }
                    else
                    {
                        //横向处理相同key的问题
                        while(ppMove != NULL &amp;&amp; ppMove-&gt;data.key != data.key)
                        {
                            ppMove = ppMove-&gt;Next;
                        }
                        if(ppMove == NULL)
                        {
                            //表头法插入
                            newNode-&gt;Next = pMove-&gt;fisrtNode;
                            pMove-&gt;fisrtNode = newNode;
                            pHash-&gt;curSize++;
                        }
                        else
                        {
                            //相同则覆盖
                            strcpy(ppMove-&gt;data.element, data.element);

                        }
                    }
                }

            }
            else
            {
                prePmove-&gt;Next = newSkipNode;
                newSkipNode-&gt;Next = pMove;
                pHash-&gt;curSize++;
            }
        }
    }
}

void printHash(LPHASH pHash)
{
    LPSLNODE pMove = pHash-&gt;headNode;
    while(pMove != NULL)
    {
        printf("%d:%s   ",pMove-&gt;data.key, pMove-&gt;data.element);
        LPNODE ppMove = pMove-&gt;fisrtNode;
        while(ppMove != NULL)
        {
            printf("%d:%s   ",ppMove-&gt;data.key, ppMove-&gt;data.element);
            ppMove = ppMove-&gt;Next;
        }
        pMove = pMove-&gt;Next;
        printf("\n");
    }
}

int main()
{
    DATA array[3] = {29,"Young",35,"蓬蒿人",39,"哦哦哦"};
    LPHASH pHash = createHash(10);
    for(int i=0; i&lt;3; i++)
    {
        insertHash(pHash,array[i]);
    }
    printHash(pHash);
    return 0;
}
</code></pre>
<pre><code>35:蓬蒿人
29:Young   39:哦哦哦
</code></pre>
<h2 id="哈希表应用实例统计词频"><a class="header" href="#哈希表应用实例统计词频">哈希表应用实例：统计词频</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312181705164.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312181705375.png" alt="" /></p>
<h1 id="字符串匹配"><a class="header" href="#字符串匹配">字符串匹配</a></h1>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312181711736.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312181711758.png" alt="" /></p>
<h2 id="普通字符串匹配实现"><a class="header" href="#普通字符串匹配实现">普通字符串匹配实现</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312181712185.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312181712051.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312181712723.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312181713791.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

typedef char* Position;
#define NotFound NULL
int main()
{
	char string[] = "This is a simple example.";
	char pattern[] = "simple";
	Position p = strstr(string, pattern);
	if (p==NotFound) 
		printf("Not Found.\n");
	else
        printf("%s\n",p);
	return 0;
}

</code></pre>
<pre><code>simple example.
</code></pre>
<h2 id="kmp算法字符串匹配"><a class="header" href="#kmp算法字符串匹配">KMP算法——字符串匹配</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312181713171.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312181713690.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312181714862.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312181714583.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312181714709.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312181715273.png" alt="" /></p>
<p>当<code>pattern[match[j-1]+1] != pattern[j]</code> 时，下一个待与<code> pattern[j]</code> 比较的元素下标是：D</p>
<ul>
<li>A.<code>match[j-2]</code></li>
<li>B.<code>match[j-2]+1</code></li>
<li>C<code>.match[match[j-1]]</code></li>
<li>D. <code>match[match[j-1]]+1</code></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312181715587.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost03/img/202312181715659.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt; 
#include &lt;stdlib.h&gt;

typedef int Position;
#define NotFound -1

void BuildMatch( char *pattern, int *match )
{
	Position i, j;
	int m = strlen(pattern);
	match[0] = -1;
	
	for ( j=1; j&lt;m; j++ ) {
		i = match[j-1];
		while ( (i&gt;=0) &amp;&amp; (pattern[i+1]!=pattern[j]) )
			i = match[i];
		if ( pattern[i+1]==pattern[j] )
		     match[j] = i+1;
		else match[j] = -1;
	}
}

Position KMP( char *string, char *pattern )
{
	int n = strlen(string);
	int m = strlen(pattern);
	Position s, p, *match;
	
	if ( n &lt; m ) return NotFound;
	match = (Position *)malloc(sizeof(Position) * m);
	BuildMatch(pattern, match);
	s = p = 0;
	while ( s&lt;n &amp;&amp; p&lt;m ) {
		if ( string[s]==pattern[p] ) {
			s++; p++;
		}
		else if (p&gt;0) p = match[p-1]+1;
		else s++;
	}
	return ( p==m )? (s-m) : NotFound;
}

int main()
{
	char string[] = "This is a simple example.";
	char pattern[] = "simple";
	Position p = KMP(string, pattern);
	if (p==NotFound) printf("Not Found.\n");
	else printf("%s\n", string+p);
	return 0;	
}
</code></pre>
<h3 id="实例pta-kmp-串的模式匹配"><a class="header" href="#实例pta-kmp-串的模式匹配">实例：PTA KMP 串的模式匹配</a></h3>
<p>给定两个由英文字母组成的字符串 String 和 Pattern，要求找到 Pattern 在 String 中第一次出现的位置，并将此位置后的 String 的子串输出。如果找不到，则输出“Not Found”。</p>
<p>本题旨在测试各种不同的匹配算法在各种数据情况下的表现。各组测试数据特点如下：</p>
<ul>
<li>数据0：小规模字符串，测试基本正确性；</li>
<li>数据1：随机数据，String 长度为 105，Pattern 长度为 10；</li>
<li>数据2：随机数据，String 长度为 105，Pattern 长度为 102；</li>
<li>数据3：随机数据，String 长度为 105，Pattern 长度为 103；</li>
<li>数据4：随机数据，String 长度为 105，Pattern 长度为 104；</li>
<li>数据5：String 长度为 106，Pattern 长度为 105；测试尾字符不匹配的情形；</li>
<li>数据6：String 长度为 106，Pattern 长度为 105；测试首字符不匹配的情形。</li>
</ul>
<p>输入格式:</p>
<p>输入第一行给出 String，为由英文字母组成的、长度不超过 106 的字符串。第二行给出一个正整数 N（≤10），为待匹配的模式串的个数。随后 N 行，每行给出一个 Pattern，为由英文字母组成的、长度不超过 105 的字符串。每个字符串都非空，以回车结束。</p>
<p>输出格式:</p>
<p>对每个 Pattern，按照题面要求输出匹配结果。</p>
<p>输入样例:</p>
<pre><code>abcabcabcabcacabxy
3
abcabcacab
cabcabcd
abcabcabcabcacabxyz
</code></pre>
<p>输出样例:</p>
<pre><code>abcabcacabxy
Not Found
Not Found
</code></pre>
<p>使用KMP算法的解法如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

typedef int Position;
#define NotFound -1

void BuildMatch( char *pattern, int *match )
{
    Position i, j;
    int m = strlen(pattern);
    match[0] = -1;

    for ( j=1; j&lt;m; j++ ) {
        i = match[j-1];
        while ( (i&gt;=0) &amp;&amp; (pattern[i+1]!=pattern[j]) )
            i = match[i];
        if ( pattern[i+1]==pattern[j] )
             match[j] = i+1;
        else match[j] = -1;
    }
}

Position KMP( char *string, char *pattern )
{
    int n = strlen(string);
    int m = strlen(pattern);
    Position s, p, *match;

    if ( n &lt; m ) return NotFound;
    match = (Position *)malloc(sizeof(Position) * m);
    BuildMatch(pattern, match);
    s = p = 0;
    while ( s&lt;n &amp;&amp; p&lt;m ) {
        if ( string[s]==pattern[p] ) {
            s++; p++;
        }
        else if (p&gt;0) p = match[p-1]+1;
        else s++;
    }
    return ( p==m )? (s-m) : NotFound;
}

int main()
{
    char string[1000005];
    scanf("%s",string);
    int N;
    scanf("%d",&amp;N);
    for(int i=0; i&lt;N; i++)
    {
        char pattern[100005];
        scanf("%s",pattern);
        Position p = KMP(string, pattern);
        if (p==NotFound)
            printf("Not Found\n");
        else
            printf("%s\n", string+p);
    }
    return 0;
}
</code></pre>
<p>使用strstr函数的解法如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

typedef char* Position;
#define NotFound NULL

int main()
{
    char string[1000005];
    scanf("%s",string);
    int N;
    scanf("%d",&amp;N);
    for(int i=0; i&lt;N; i++)
    {
        char pattern[100005];
        scanf("%s",pattern);
        Position p = strstr(string, pattern);
        if (p==NotFound)
            printf("Not Found\n");
        else
            printf("%s\n", p);
    }
    return 0;
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="MOOC-PTA排序题目.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="MOOC-PTA查找题目.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="MOOC-PTA排序题目.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="MOOC-PTA查找题目.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
